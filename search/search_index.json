{
    "docs": [
        {
            "location": "/",
            "text": "zend-form\n\n\n\n\n\n\nzend-form is intended primarily as a bridge between your domain models and\nthe View Layer. It composes a thin layer of objects representing form elements,\nan InputFilter, and a small number of methods for binding data to and from the\nform and attached objects.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-form/issues\n\n\nAsk questions at https://discourse.zendframework.com/c/questions/components\n  (use the tag zend-form)\n\n\nDocumentation is at https://docs.zendframework.com/zend-form/",
            "title": "zend-form"
        },
        {
            "location": "/#zend-form",
            "text": "zend-form is intended primarily as a bridge between your domain models and\nthe View Layer. It composes a thin layer of objects representing form elements,\nan InputFilter, and a small number of methods for binding data to and from the\nform and attached objects.   File issues at https://github.com/zendframework/zend-form/issues  Ask questions at https://discourse.zendframework.com/c/questions/components\n  (use the tag zend-form)  Documentation is at https://docs.zendframework.com/zend-form/",
            "title": "zend-form"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-form is a bridge between your domain models and the view layer. It composes\na thin layer of objects representing form elements, an\n\nInputFilter\n, and a small\nnumber of methods for binding data to and from the form and attached objects.\n\n\nThe component consists of the following objects:\n\n\n\n\nElements, which consist of a name and attributes.\n\n\nFieldsets, which extend from elements, but allow composing other fieldsets and\n  elements.\n\n\nForms, which extend from Fieldsets (and thus Elements). They provide data and\n  object binding, and compose \nInputFilters\n.\n  Data binding is done via \nzend-hydrator\n.\n\n\n\n\nTo facilitate usage with the view layer, zend-form also aggregates a number of\nform-specific view helpers. These accept elements, fieldsets, and/or forms, and\nuse the attributes they compose to render markup.\n\n\nA small number of specialized elements are provided for accomplishing\napplication-centric tasks.  These include the \nCsrf\n element, used to prevent\nCross Site Request Forgery attacks, and the \nCaptcha\n element, used to display\nand validate \nCAPTCHAs\n.\n\n\nA \nFactory\n is provided to facilitate creation of elements, fieldsets, forms,\nand the related input filter. The default \nForm\n implementation is backed by a\nfactory to facilitate extension and ease the process of form creation.\n\n\nThe code related to forms can often spread between a variety of concerns: a form\ndefinition, an input filter definition, a domain model class, and one or more\nhydrator implementations. As such, finding the various bits of code and how they\nrelate can become tedious. To simplify the situation, you can also annotate your\ndomain model class, detailing the various input filter definitions, attributes,\nand hydrators that should all be used together. \nZend\\Form\\Annotation\\AnnotationBuilder\n\ncan then be used to build the various objects you need.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-form is a bridge between your domain models and the view layer. It composes\na thin layer of objects representing form elements, an InputFilter , and a small\nnumber of methods for binding data to and from the form and attached objects.  The component consists of the following objects:   Elements, which consist of a name and attributes.  Fieldsets, which extend from elements, but allow composing other fieldsets and\n  elements.  Forms, which extend from Fieldsets (and thus Elements). They provide data and\n  object binding, and compose  InputFilters .\n  Data binding is done via  zend-hydrator .   To facilitate usage with the view layer, zend-form also aggregates a number of\nform-specific view helpers. These accept elements, fieldsets, and/or forms, and\nuse the attributes they compose to render markup.  A small number of specialized elements are provided for accomplishing\napplication-centric tasks.  These include the  Csrf  element, used to prevent\nCross Site Request Forgery attacks, and the  Captcha  element, used to display\nand validate  CAPTCHAs .  A  Factory  is provided to facilitate creation of elements, fieldsets, forms,\nand the related input filter. The default  Form  implementation is backed by a\nfactory to facilitate extension and ease the process of form creation.  The code related to forms can often spread between a variety of concerns: a form\ndefinition, an input filter definition, a domain model class, and one or more\nhydrator implementations. As such, finding the various bits of code and how they\nrelate can become tedious. To simplify the situation, you can also annotate your\ndomain model class, detailing the various input filter definitions, attributes,\nand hydrators that should all be used together.  Zend\\Form\\Annotation\\AnnotationBuilder \ncan then be used to build the various objects you need.",
            "title": "Introduction"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nForms are composed of elements and fieldsets. At the bare minimum, each element\nor fieldset requires a name; in most situations, you'll also provide some\nattributes to hint to the view layer how it might render the item. The form\nitself generally composes an \nInputFilter\n \u2014 which you can also create\ndirectly in the form via a factory. Individual elements can hint as to what\ndefaults to use when generating a related input for the input filter.\n\n\nPerform form validation by providing an array of data to the \nsetData()\n method,\nand calling the \nisValid()\n method. If you want to simplify your work even more,\nyou can bind an object to the form; on successful validation, it will be\npopulated from the validated values.\n\n\nProgrammatic Form Creation\n\n\nThe following example demonstrates element, fieldset, and form creation, and how\nthey are wired together.\n\n\nuse Zend\\Captcha;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n// Create a text element to capture the user name:\n$name = new Element('name');\n$name->setLabel('Your name');\n$name->setAttributes([\n    'type' => 'text',\n]);\n\n// Create a text element to capture the user email address:\n$email = new Element\\Email('email');\n$email->setLabel('Your email address');\n\n// Create a text element to capture the message subject:\n$subject = new Element('subject');\n$subject->setLabel('Subject');\n$subject->setAttributes([\n    'type' => 'text',\n]);\n\n// Create a textarea element to capture a message:\n$message = new Element\\Textarea('message');\n$message->setLabel('Message');\n\n// Create a CAPTCHA:\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n// Create a CSRF token:\n$csrf = new Element\\Csrf('security');\n\n// Create a submit button:\n$send = new Element('send');\n$send->setValue('Submit');\n$send->setAttributes([\n    'type' => 'submit',\n]);\n\n// Create the form and add all elements:\n$form = new Form('contact');\n$form->add($name);\n$form->add($email);\n$form->add($subject);\n$form->add($message);\n$form->add($captcha);\n$form->add($csrf);\n$form->add($send);\n\n// Create an input for the \"name\" element:\n$nameInput = new Input('name');\n\n/* ... configure the input, and create and configure all others ... */\n\n// Create the input filter:\n$inputFilter = new InputFilter();\n\n// Attach inputs:\n$inputFilter->add($nameInput);\n/* ... */\n\n// Attach the input filter to the form:\n$form->setInputFilter($inputFilter);\n\n\n\nAs a demonstration of fieldsets, let's alter the above slightly. We'll create\ntwo fieldsets, one for the sender information, and another for the message\ndetails.\n\n\n// Create the fieldset for sender details:\n$sender = new Fieldset('sender');\n$sender->add($name);\n$sender->add($email);\n\n// Create the fieldset for message details:\n$details = new Fieldset('details');\n$details->add($subject);\n$details->add($message);\n\n$form = new Form('contact');\n$form->add($sender);\n$form->add($details);\n$form->add($captcha);\n$form->add($csrf);\n$form->add($send);\n\n\n\nThis manual approach gives maximum flexibility over form creation; however, it\ncomes at the expense of verbosity. In the next section, we'll look at another\napproach.\n\n\nCreation via Factory\n\n\nYou can create the entire form and input filter at once using the \nFactory\n.\nThis is particularly nice if you want to store your forms as pure configuration;\nyou can then pass the configuration to the factory and be done.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Factory;\nuse Zend\\Hydrator\\ArraySerializable;\n\n$factory = new Factory();\n$form    = $factory->createForm([\n    'hydrator' => ArraySerializable::class,\n    'elements' => [\n        [\n            'spec' => [\n                'name' => 'name',\n                'options' => [\n                    'label' => 'Your name',\n                ],\n                'type'  => 'Text',\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Email::class,\n                'name' => 'email',\n                'options' => [\n                    'label' => 'Your email address',\n                ]\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'subject',\n                'options' => [\n                    'label' => 'Subject',\n                ],\n                'type'  => 'Text',\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Textarea::class,\n                'name' => 'message',\n                'options' => [\n                    'label' => 'Message',\n                ]\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Captcha::class,\n                'name' => 'captcha',\n                'options' => [\n                    'label' => 'Please verify you are human.',\n                    'captcha' => [\n                        'class' => 'Dumb',\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Csrf::class,\n                'name' => 'security',\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'send',\n                'type'  => 'Submit',\n                'attributes' => [\n                    'value' => 'Submit',\n                ],\n            ],\n        ],\n    ],\n\n    /* If we had fieldsets, they'd go here; fieldsets contain\n     * \"elements\" and \"fieldsets\" keys, and potentially a \"type\"\n     * key indicating the specific FieldsetInterface\n     * implementation to use.\n    'fieldsets' => [\n    ],\n     */\n\n    // Configuration to pass on to\n    // Zend\\InputFilter\\Factory::createInputFilter()\n    'input_filter' => [\n        /* ... */\n    ],\n]);\n\n\n\nIf we wanted to use fieldsets, as we demonstrated in the previous example, we\ncould do the following:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Factory;\nuse Zend\\Hydrator\\ArraySerializable;\n\n$factory = new Factory();\n$form    = $factory->createForm([\n    'hydrator'  => ArraySerializable::class,\n\n    // Top-level fieldsets to define:\n    'fieldsets' => [\n        [\n            'spec' => [\n                'name' => 'sender',\n                'elements' => [\n                    [\n                        'spec' => [\n                            'name' => 'name',\n                            'options' => [\n                                'label' => 'Your name',\n                            ],\n                            'type' => 'Text'\n                        ],\n                    ],\n                    [\n                        'spec' => [\n                            'type' => Element\\Email::class,\n                            'name' => 'email',\n                            'options' => [\n                                'label' => 'Your email address',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'details',\n                'elements' => [\n                    [\n                        'spec' => [\n                            'name' => 'subject',\n                            'options' => [\n                                'label' => 'Subject',\n                            ],\n                            'type' => 'Text',\n                        ],\n                    ],\n                    [\n                        'spec' => [\n                            'name' => 'message',\n                            'type' => Element\\Textarea::class,\n                            'options' => [\n                                'label' => 'Message',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    // You can specify an \"elements\" key explicitly:\n    'elements' => [\n        [\n            'spec' => [\n                'type' => Element\\Captcha::class,\n                'name' => 'captcha',\n                'options' => [\n                    'label' => 'Please verify you are human.',\n                    'captcha' => [\n                        'class' => 'Dumb',\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n            'type' => Element\\Csrf::class,\n            'name' => 'security',\n        ],\n    ],\n\n    // But entries without string keys are also considered elements:\n    [\n        'spec' => [\n            'name' => 'send',\n            'type'  => 'Submit',\n            'attributes' => [\n                'value' => 'Submit',\n            ],\n        ],\n    ],\n\n    // Configuration to pass on to\n    // Zend\\InputFilter\\Factory::createInputFilter()\n    'input_filter' => [\n        /* ... */\n    ],\n]);\n\n\n\nNote that the chief difference is nesting; otherwise, the information is\nbasically the same.\n\n\nThe chief benefits to using the \nFactory\n are allowing you to store definitions\nin configuration, and usage of significant whitespace.\n\n\nFactory-backed Form Extension\n\n\nThe default \nForm\n implementation is backed by the \nFactory\n. This allows you to\nextend it, and define your form internally. This has the benefit of allowing a\nmixture of programmatic and factory-backed creation, as well as defining a form\nfor re-use in your application.\n\n\nnamespace Contact;\n\nuse Zend\\Captcha\\AdapterInterface as CaptchaAdapter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass ContactForm extends Form\n{\n    protected $captcha;\n\n    public function __construct(CaptchaAdapter $captcha)\n    {\n        parent::__construct();\n\n        $this->captcha = $captcha;\n\n        // add() can take an Element/Fieldset instance, or a specification, from\n        // which the appropriate object will be built.\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Your name',\n            ],\n            'type'  => 'Text',\n        ]);\n        $this->add([\n            'type' => Element\\Email::class,\n            'name' => 'email',\n            'options' => [\n                'label' => 'Your email address',\n            ],\n        ]);\n        $this->add([\n            'name' => 'subject',\n            'options' => [\n                'label' => 'Subject',\n            ],\n            'type'  => 'Text',\n        ]);\n        $this->add([\n            'type' => Element\\Textarea::class,\n            'name' => 'message',\n            'options' => [\n                'label' => 'Message',\n            ],\n        ]);\n        $this->add([\n            'type' => Element\\Captcha::class,\n            'name' => 'captcha',\n            'options' => [\n                'label' => 'Please verify you are human.',\n                'captcha' => $this->captcha,\n            ],\n        ]);\n        $this->add(new Element\\Csrf('security'));\n        $this->add([\n            'name' => 'send',\n            'type'  => 'Submit',\n            'attributes' => [\n                'value' => 'Submit',\n            ],\n        ]);\n\n        // We could also define the input filter here, or\n        // lazy-create it in the getInputFilter() method.\n    }\n}\n\n\n\nIn the above example, elements are added in the constructor. This is done to\nallow altering and/or configuring either the form or input filter factory\ninstances, which could then have bearing on how elements, inputs, etc. are\ncreated. In this case, it also allows injection of the CAPTCHA adapter, allowing\nus to configure it elsewhere in our application and inject it into the form.\n\n\nValidating Forms\n\n\nValidating forms requires three steps. First, the form must have an input filter\nattached. Second, you must inject the data to validate into the form. Third, you\nvalidate the form. If invalid, you can retrieve the error messages, if any.\n\n\n// assuming $captcha is an instance of some Zend\\Captcha\\AdapterInterface:\n$form = new Contact\\ContactForm($captcha);\n\n// If the form doesn't define an input filter by default, inject one.\n$form->setInputFilter(new Contact\\ContactFilter());\n\n// Get the data. In an MVC application, you might try:\n$data = $request->getPost();  // for POST data\n$data = $request->getQuery(); // for GET (or query string) data\n\n$form->setData($data);\n\n// Validate the form\nif ($form->isValid()) {\n    $validatedData = $form->getData();\n} else {\n    $messages = $form->getMessages();\n}\n\n\n\n\n\nAlways populate select elements with options\n\n\nAlways ensure that options for a select element are populated \nprior\n to\nvalidation; otherwise, the element will fail validation, and you will receive\na \nNotInArray\n error message.\n\n\nIf you are populating the options from a database or other data source, make\nsure this is done prior to validation. Alternately, you may disable the\n\nInArray\n validator programmatically prior to validation:\n\n\n$element->setDisableInArrayValidator(true);\n\n\n\n\n\nYou can get the raw data if you want, by accessing the composed input filter.\n\n\n$filter = $form->getInputFilter();\n\n$rawValues    = $filter->getRawValues();\n$nameRawValue = $filter->getRawValue('name');\n\n\n\nHinting to the Input Filter\n\n\nOften, you'll create elements that you expect to behave in the same way on each\nusage, and for which you'll want specific filters or validation as well. Since\nthe input filter is a separate object, how can you achieve these latter points?\n\n\nBecause the default form implementation composes a factory, and the default\nfactory composes an input filter factory, you can have your elements and/or\nfieldsets hint to the input filter. If no input or input filter is provided in\nthe input filter for that element, these hints will be retrieved and used to\ncreate them.\n\n\nTo do so, one of the following must occur. For elements, they must implement\n\nZend\\InputFilter\\InputProviderInterface\n, which defines a\n\ngetInputSpecification()\n method; for fieldsets (and, by extension, forms), they\nmust implement \nZend\\InputFilter\\InputFilterProviderInterface\n, which defines a\n\ngetInputFilterSpecification()\n method.\n\n\nIn the case of an element, the \ngetInputSpecification()\n method should return\ndata to be used by the input filter factory to create an input. Every HTML5\n(\nemail\n, \nurl\n, \ncolor\n, etc.) element has a built-in element that uses this\nlogic. For instance, here is how the \nZend\\Form\\Element\\Color\n element is\ndefined:\n\n\nnamespace Zend\\Form\\Element;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputProviderInterface;\nuse Zend\\Validator\\Regex as RegexValidator;\nuse Zend\\Validator\\ValidatorInterface;\n\nclass Color extends Element implements InputProviderInterface\n{\n    /**\n     * Seed attributes\n     *\n     * @var array\n     */\n    protected $attributes = [\n        'type' => 'color',\n    ];\n\n    /**\n     * @var ValidatorInterface\n     */\n    protected $validator;\n\n    /**\n     * Get validator\n     *\n     * @return ValidatorInterface\n     */\n    protected function getValidator()\n    {\n        if (null === $this->validator) {\n            $this->validator = new RegexValidator('/^#[0-9a-fA-F]{6}$/');\n        }\n        return $this->validator;\n    }\n\n    /**\n     * Provide default input rules for this element\n     *\n     * Attaches an email validator.\n     *\n     * @return array\n     */\n    public function getInputSpecification()\n    {\n        return [\n            'name' => $this->getName(),\n            'required' => true,\n            'filters' => [\n                ['name' => Filter\\StringTrim::class],\n                ['name' => Filter\\StringToLower::class],\n            ],\n            'validators' => [\n                $this->getValidator(),\n            ],\n        ];\n    }\n}\n\n\n\nThe above hints to the input filter to create and attach an input named after\nthe element, marking it as required, giving it \nStringTrim\n and \nStringToLower\n\nfilters, and defining a \nRegex\n validator. Note that you can either rely on the\ninput filter to create filters and validators, or directly instantiate them.\n\n\nFor fieldsets, you do very similarly; the difference is that\n\ngetInputFilterSpecification()\n must return configuration for an input filter.\n\n\nnamespace Contact\\Form;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Validator;\n\nclass SenderFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n                'filters'  => [\n                    ['name' => Filter\\StringTrim::class],\n                ],\n                'validators' => [\n                    [\n                        'name' => Validator\\StringLength::class,\n                        'options' => [\n                            'min' => 3,\n                            'max' => 256\n                        ],\n                    ],\n                ],\n            ],\n            'email' => [\n                'required' => true,\n                'filters'  => [\n                    ['name' => Filter\\StringTrim::class],\n                ],\n                'validators' => [\n                    new Validator\\EmailAddress(),\n                ],\n            ],\n        ];\n    }\n}\n\n\n\nSpecifications are a great way to make forms, fieldsets, and elements re-usable\ntrivially in your applications. In fact, the \nCaptcha\n and \nCsrf\n elements\ndefine specifications in order to ensure they can work without additional user\nconfiguration!\n\n\n\n\nUse the most specific input type\n\n\nIf you set custom input filter specification either in\n\ngetInputSpecification()\n or in \ngetInputFilterSpecification()\n, the\n\nZend\\InputFilter\\InputInterface\n set for that specific field is reset to the\ndefault \nZend\\InputFilter\\Input\n.\n\n\nSome form elements may need a particular input filter, like\n\nZend\\Form\\Element\\File\n: in this case it's mandatory to specify the \ntype\n\nkey in your custom specification to match the original one (e.g., for the\nfile element, use \nZend\\InputFilter\\FileInput\n).\n\n\n\n\nBinding an object\n\n\nAs noted in the introduction, forms bridge the domain model and the view layer.\nLet's see that in action.\n\n\nWhen you \nbind()\n an object to the form, the following happens:\n\n\n\n\nThe composed \nHydrator\n calls \nextract()\n on the object, and uses the values\n  returned, if any, to populate the \nvalue\n attributes of all elements. If a\n  form contains a fieldset that itself contains another fieldset, the form will\n  recursively extract the values.\n\n\nWhen \nisValid()\n is called, if \nsetData()\n has not been previously set, the\n  form uses the composed \nHydrator\n to extract values from the object, and uses\n  those during validation.\n\n\nIf \nisValid()\n is successful (and the \nbindOnValidate\n flag is enabled, which\n  is true by default), then the \nHydrator\n will be passed the validated values\n  to use to hydrate the bound object. (If you do not want this behavior, call\n  \nsetBindOnValidate(FormInterface::BIND_MANUAL)\n).\n\n\nIf the object implements \nZend\\InputFilter\\InputFilterAwareInterface\n, the\n  input filter it composes will be used instead of the one composed on the form.\n\n\n\n\nThis is easier to understand with an example.\n\n\n$contact = new ArrayObject;\n$contact['subject'] = '[Contact Form] ';\n$contact['message'] = 'Type your message here';\n\n$form = new Contact\\ContactForm;\n\n$form->bind($contact); // form now has default values for\n                       // 'subject' and 'message'\n\n$data = [\n    'name'    => 'John Doe',\n    'email'   => 'j.doe@example.tld',\n    'subject' => '[Contact Form] \\'sup?',\n];\n$form->setData($data);\n\nif ($form->isValid()) {\n    // $contact now has the following structure:\n    // [\n    //     'name'    => 'John Doe',\n    //     'email'   => 'j.doe@example.tld',\n    //     'subject' => '[Contact Form] \\'sup?',\n    //     'message' => 'Type your message here',\n    // ]\n    // But is an ArrayObject instance!\n}\n\n\n\nWhen an object is bound to the form, calling \ngetData()\n will return that object\nby default. If you want to return an associative array instead, you can pass the\n\nFormInterface::VALUES_AS_ARRAY\n flag to the method.\n\n\nuse Zend\\Form\\FormInterface;\n$data = $form->getData(FormInterface::VALUES_AS_ARRAY);\n\n\n\nZend Framework ships several standard \nhydrators\n;\nyou can create custom hydrators by implementing \nZend\\Hydrator\\HydratorInterface\n,\nwhich looks like this:\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydratorInterface\n{\n    /** @return array */\n    public function extract($object);\n    public function hydrate(array $data, $object);\n}\n\n\n\nRendering\n\n\nAs noted previously, forms are meant to bridge the domain model and view layer.\nWe've discussed the domain model binding, but what about the view?\n\n\nThe form component ships a set of form-specific view helpers. These accept the\nvarious form objects, and introspect them in order to generate markup.\nTypically, they will inspect the attributes, but in special cases, they may look\nat other properties and composed objects.\n\n\nWhen preparing to render, you will generally want to call \nprepare()\n. This\nmethod ensures that certain injections are done, and ensures that elements\nnested in fieldsets and collections generate names in array notation (e.g.,\n\nscoped[array][notation]\n).\n\n\nThe base view helpers used everywhere are \nForm\n, \nFormElement\n, \nFormLabel\n,\nand \nFormElementErrors\n. Let's use them to display the contact form.\n\n\n<?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Get the form label plugin\n$formLabel = $this->plugin('formLabel');\n\n// Render the opening tag\necho $this->form()->openTag($form);\n?>\n<div class=\"form_element\">\n<?php\n    $name = $form->get('name');\n    echo $formLabel->openTag() . $name->getOption('label');\n    echo $this->formInput($name);\n    echo $this->formElementErrors($name);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $subject = $form->get('subject');\n    echo $formLabel->openTag() . $subject->getOption('label');\n    echo $this->formInput($subject);\n    echo $this->formElementErrors($subject);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $message = $form->get('message');\n    echo $formLabel->openTag() . $message->getOption('label');\n    echo $this->formTextarea($message);\n    echo $this->formElementErrors($message);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $captcha = $form->get('captcha');\n    echo $formLabel->openTag() . $captcha->getOption('label');\n    echo $this->formCaptcha($captcha);\n    echo $this->formElementErrors($captcha);\n    echo $formLabel->closeTag();\n?></div>\n\n<?= $this->formElement($form->get('security')) ?>\n<?= $this->formElement($form->get('send')) ?>\n\n<?= $this->form()->closeTag() ?>\n\n\n\nThere are a few things to note about this. First, to prevent confusion in IDEs\nand editors when syntax highlighting, we use helpers to both open and close the\nform and label tags. Second, there's a lot of repetition happening here; we\ncould easily create a partial view script or a composite helper to reduce\nboilerplate. Third, note that not all elements are created equal \u2014 the\nCSRF and submit elements don't need labels or error messages. Finally, note that\nthe \nFormElement\n helper tries to do the right thing \u2014 it delegates actual\nmarkup generation to other view helpers. However, it can only guess what\nspecific form helper to delegate to based on the list it has. If you introduce\nnew form view helpers, you'll need to extend the \nFormElement\n helper, or create\nyour own.\n\n\nFollowing the example above, your view files can quickly become long and\nrepetitive to write. While we do not currently provide a single-line form view\nhelper (as this reduces the form customization), we do provide convenience\nwrappers around emitting individual elements via the \nFormRow\n view helper, and\ncollections of elements (\nZend\\Form\\Element\\Collection\n, \nZend\\Form\\Fieldset\n, or\n\nZend\\Form\\Form\n) via the \nFormCollection\n view helper (which, internally,\niterates the collection and calls \nFormRow\n for each element, recursively\nfollowing collections).\n\n\nThe \nFormRow\n view helper automatically renders a label (if present), the\nelement itself using the \nFormElement\n helper, as well as any errors that could\narise. Here is the previous form, rewritten to take advantage of this helper:\n\n\n<?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Render the opening tag\necho $this->form()->openTag($form);\n?>\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('name')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('subject')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('message')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('captcha')) ?>\n</div>\n\n<?= $this->formElement($form->get('security')) ?>\n<?= $this->formElement($form->get('send')) ?>\n\n<?= $this->form()->closeTag() ?>\n\n\n\nNote that \nFormRow\n helper automatically prepends the label. If you want it to\nbe rendered after the element itself, you can pass an optional parameter to the\n\nFormRow\n view helper :\n\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('name'), 'append') ?>\n</div>\n\n\n\nAs noted previously, the \nFormCollection\n view helper will iterate any\ncollection \u2014 including \nZend\\Form\\Element\\Collection\n, fieldsets, and\nforms \u2014 emitting each element discovered using \nFormRow\n. \nFormCollection\n\n\ndoes not render fieldset or form tags\n; you will be responsible for emitting\nthose yourself.\n\n\nThe above examples can now be rewritten again:\n\n\n<?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Render the opening tag\necho $this->form()->openTag($form);\necho $this->formCollection($form);\necho $this->form()->closeTag();\n\n\n\nFinally, the \nForm\n view helper can optionally accept a \nZend\\Form\\Form\n\ninstance; if provided, it will prepare the form, iterate it, and render all\nelements using either \nFormRow\n (for non-collection elements) or\n\nFormCollection\n (for collections and fieldsets):\n\n\n<?php\n// within a view script\n$form = $this->form;\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\necho $this->form($form);\n\n\n\nOne important point to note about the last two examples: while they greatly\nsimplifies emitting the form, you also lose most customization opportunities.\nThe above, for example, will not include the \n<div class=\"form_element\"></div>\n\nwrappers from the previous examples! As such, you will generally want to use\nthis facility only when prototyping.\n\n\nTaking advantage of HTML5 input attributes\n\n\nHTML5 brings a lot of exciting features, one of them being simplified client\nform validations. zend-form provides elements corresponding to the various HTML5\nelements, specifying the client-side attributes required by them. Additionally,\neach implements \nInputProviderInterface\n, ensuring that your input filter will\nhave reasonable default validation and filtering rules that mimic the\nclient-side validations.\n\n\n\n\nAlways validate server-side\n\n\nAlthough client validation is nice from a user experience point of view, it\nmust be used in addition to server-side validation, as client validation can\nbe easily bypassed.\n\n\n\n\nValidation Groups\n\n\nSometimes you want to validate only a subset of form elements. As an example,\nlet's say we're re-using our contact form over a web service; in this case, the\n\nCsrf\n, \nCaptcha\n, and submit button elements are not of interest, and shouldn't\nbe validated.\n\n\nzend-form provides a proxy method to the underlying \nInputFilter\n's\n\nsetValidationGroup()\n method, allowing us to perform this operation.\n\n\n$form->setValidationGroup('name', 'email', 'subject', 'message');\n$form->setData($data);\nif ($form->isValid()) {\n    // Contains only the \"name\", \"email\", \"subject\", and \"message\" values\n    $data = $form->getData();\n}\n\n\n\nIf you later want to reset the form to validate all elements, pass the\n\nFormInterface::VALIDATE_ALL\n flag to the \nsetValidationGroup()\n method:\n\n\nuse Zend\\Form\\FormInterface;\n$form->setValidationGroup(FormInterface::VALIDATE_ALL);\n\n\n\nWhen your form contains nested fieldsets, you can use an array notation to\nvalidate only a subset of the fieldsets :\n\n\n$form->setValidationGroup(['profile' => [\n    'firstname',\n    'lastname',\n] ]);\n\n$form->setData($data);\nif ($form->isValid()) {\n    // Contains only the \"firstname\" and \"lastname\" values from the\n    // \"profile\" fieldset\n    $data = $form->getData();\n}\n\n\n\nUsing Annotations\n\n\nCreating a complete form solution can often be tedious: you'll create a domain\nmodel object, an input filter for validating it, a form object for providing a\nrepresentation for it, and potentially a hydrator for mapping the form elements\nand fieldsets to the domain model. Wouldn't it be nice to have a central place\nto define all of these?\n\n\nAnnotations allow us to solve this problem. You can define the following\nbehaviors with the shipped annotations in zend-form:\n\n\n\n\nAllowEmpty\n: mark an input as allowing an empty value. This annotation does\n  not require a value.\n\n\nAttributes\n: specify the form, fieldset, or element attributes. This\n  annotation requires an associative array of values, in a JSON object format:\n  \n@Attributes({\"class\":\"zend_form\",\"type\":\"text\"})\n.\n\n\nComposedObject\n: specify another object with annotations to parse. Typically,\n  this is used if a property references another object, which will then be added\n  to your form as an additional fieldset.  Expects a string value indicating the\n  class for the object being composed: \n@ComposedObject(\"Namespace\\Model\\ComposedObject\")\n;\n  or an array to compose a collection:\n  \n@ComposedObject({ \"target_object\":\"Namespace\\Model\\ComposedCollection\", \"is_collection\":\"true\", \"options\":{\"count\":2}})\n;\n  \ntarget_object\n is the element to compose, \nis_collection\n flags this as a\n  collection, and \noptions\n can take an array of options to pass into the\n  collection.\n\n\nErrorMessage\n: specify the error message to return for an element in the case\n  of a failed validation. Expects a string value.\n\n\nExclude\n: mark a property to exclude from the form or fieldset. This\n  annotation does not require a value.\n\n\nFilter\n: provide a specification for a filter to use on a given element.\n  Expects an associative array of values, with a \"name\" key pointing to a string\n  filter name, and an \"options\" key pointing to an associative array of filter\n  options for the constructor: \n@Filter({\"name\": \"Boolean\", \"options\": {\"casting\":true}})\n.\n  This annotation may be specified multiple times.\n\n\nFlags\n: flags to pass to the fieldset or form composing an element or\n  fieldset; these are usually used to specify the name or priority. The\n  annotation expects an associative array: \n@Flags({\"priority\": 100})\n.\n\n\nHydrator\n: specify the hydrator class to use for this given form or fieldset.\n  A string value is expected.\n\n\nInputFilter\n: specify the input filter class to use for this given form or\n  fieldset. A string value is expected.\n\n\nInput\n: specify the input class to use for this given element. A string value\n  is expected.\n\n\nInstance\n: specify an object class instance to bind to the form or fieldset.\n\n\nName\n: specify the name of the current element, fieldset, or form. A string\n  value is expected.\n\n\nObject\n: specify an object class instance to bind to the form or fieldset.\n  (Note: this is deprecated in 2.4.0; use \nInstance\n instead.)\n\n\nOptions\n: options to pass to the fieldset or form that are used to inform\n  behavior \u2014 things that are not attributes; e.g. labels, CAPTCHA adapters,\n  etc. The annotation expects an associative array: \n@Options({\"label\": \"Username:\"})\n.\n\n\nRequired\n: indicate whether an element is required. A boolean value is\n  expected. By default, all elements are required, so this annotation is mainly\n  present to allow disabling a requirement.\n\n\nType\n: indicate the class to use for the current element, fieldset, or form.\n  A string value is expected.\n\n\nValidator\n: provide a specification for a validator to use on a given\n  element. Expects an associative array of values, with a \"name\" key pointing to\n  a string validator name, and an \"options\" key pointing to an associative array\n  of validator options for the constructor:\n  \n@Validator({\"name\": \"StringLength\", \"options\": {\"min\":3, \"max\": 25}})\n.\n  This annotation may be specified multiple times.\n\n\n\n\nTo use annotations, include them in your class and/or property docblocks.\nAnnotation names will be resolved according to the import statements in your\nclass; as such, you can make them as long or as short as you want depending on\nwhat you import.\n\n\n\n\ndoctrine/common dependency\n\n\nForm annotations require \ndoctrine\\common\n, which contains an annotation\nparsing engine. Install it using composer:\n\n\n$ composer require doctrine/common\n\n\n\n\n\nHere's an example:\n\n\nuse Zend\\Form\\Annotation;\n\n/**\n * @Annotation\\Name(\"user\")\n * @Annotation\\Hydrator(\"Zend\\Hydrator\\ObjectProperty\")\n */\nclass User\n{\n    /**\n     * @Annotation\\Exclude()\n     */\n    public $id;\n\n    /**\n     * @Annotation\\Filter({\"name\":\"StringTrim\"})\n     * @Annotation\\Validator({\"name\":\"StringLength\", \"options\":{\"min\":1, \"max\":25}})\n     * @Annotation\\Validator({\"name\":\"Regex\",\n\"options\":{\"pattern\":\"/^[a-zA-Z][a-zA-Z0-9_-]{0,24}$/\"}})\n     * @Annotation\\Attributes({\"type\":\"text\"})\n     * @Annotation\\Options({\"label\":\"Username:\"})\n     */\n    public $username;\n\n    /**\n     * @Annotation\\Type(\"Zend\\Form\\Element\\Email\")\n     * @Annotation\\Options({\"label\":\"Your email address:\"})\n     */\n    public $email;\n}\n\n\n\nThe above will hint to the annotation builder to create a form with name \"user\",\nwhich uses the hydrator \nZend\\Hydrator\\ObjectProperty\n. That form will\nhave two elements, \"username\" and \"email\". The \"username\" element will have an\nassociated input that has a \nStringTrim\n filter, and two validators: a\n\nStringLength\n validator indicating the username is between 1 and 25 characters,\nand a \nRegex\n validator asserting it follows a specific accepted pattern. The\nform element itself will have an attribute \"type\" with value \"text\" (a text\nelement), and a label \"Username:\". The \"email\" element will be of type\n\nZend\\Form\\Element\\Email\n, and have the label \"Your email address:\".\n\n\nTo use the above, we need \nZend\\Form\\Annotation\\AnnotationBuilder\n:\n\n\nuse Zend\\Form\\Annotation\\AnnotationBuilder;\n\n$builder = new AnnotationBuilder();\n$form    = $builder->createForm(User::class);\n\n\n\nAt this point, you have a form with the appropriate hydrator attached, an input\nfilter with the appropriate inputs, and all elements.\n\n\n\n\nYou're not done\n\n\nIn all likelihood, you'll need to add some more elements to the form you\nconstruct. For example, you'll want a submit button, and likely a\nCSRF-protection element. We recommend creating a fieldset with common elements\nsuch as these that you can then attach to the form you build via annotations.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "Forms are composed of elements and fieldsets. At the bare minimum, each element\nor fieldset requires a name; in most situations, you'll also provide some\nattributes to hint to the view layer how it might render the item. The form\nitself generally composes an  InputFilter  \u2014 which you can also create\ndirectly in the form via a factory. Individual elements can hint as to what\ndefaults to use when generating a related input for the input filter.  Perform form validation by providing an array of data to the  setData()  method,\nand calling the  isValid()  method. If you want to simplify your work even more,\nyou can bind an object to the form; on successful validation, it will be\npopulated from the validated values.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#programmatic-form-creation",
            "text": "The following example demonstrates element, fieldset, and form creation, and how\nthey are wired together.  use Zend\\Captcha;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n// Create a text element to capture the user name:\n$name = new Element('name');\n$name->setLabel('Your name');\n$name->setAttributes([\n    'type' => 'text',\n]);\n\n// Create a text element to capture the user email address:\n$email = new Element\\Email('email');\n$email->setLabel('Your email address');\n\n// Create a text element to capture the message subject:\n$subject = new Element('subject');\n$subject->setLabel('Subject');\n$subject->setAttributes([\n    'type' => 'text',\n]);\n\n// Create a textarea element to capture a message:\n$message = new Element\\Textarea('message');\n$message->setLabel('Message');\n\n// Create a CAPTCHA:\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n// Create a CSRF token:\n$csrf = new Element\\Csrf('security');\n\n// Create a submit button:\n$send = new Element('send');\n$send->setValue('Submit');\n$send->setAttributes([\n    'type' => 'submit',\n]);\n\n// Create the form and add all elements:\n$form = new Form('contact');\n$form->add($name);\n$form->add($email);\n$form->add($subject);\n$form->add($message);\n$form->add($captcha);\n$form->add($csrf);\n$form->add($send);\n\n// Create an input for the \"name\" element:\n$nameInput = new Input('name');\n\n/* ... configure the input, and create and configure all others ... */\n\n// Create the input filter:\n$inputFilter = new InputFilter();\n\n// Attach inputs:\n$inputFilter->add($nameInput);\n/* ... */\n\n// Attach the input filter to the form:\n$form->setInputFilter($inputFilter);  As a demonstration of fieldsets, let's alter the above slightly. We'll create\ntwo fieldsets, one for the sender information, and another for the message\ndetails.  // Create the fieldset for sender details:\n$sender = new Fieldset('sender');\n$sender->add($name);\n$sender->add($email);\n\n// Create the fieldset for message details:\n$details = new Fieldset('details');\n$details->add($subject);\n$details->add($message);\n\n$form = new Form('contact');\n$form->add($sender);\n$form->add($details);\n$form->add($captcha);\n$form->add($csrf);\n$form->add($send);  This manual approach gives maximum flexibility over form creation; however, it\ncomes at the expense of verbosity. In the next section, we'll look at another\napproach.",
            "title": "Programmatic Form Creation"
        },
        {
            "location": "/quick-start/#creation-via-factory",
            "text": "You can create the entire form and input filter at once using the  Factory .\nThis is particularly nice if you want to store your forms as pure configuration;\nyou can then pass the configuration to the factory and be done.  use Zend\\Form\\Element;\nuse Zend\\Form\\Factory;\nuse Zend\\Hydrator\\ArraySerializable;\n\n$factory = new Factory();\n$form    = $factory->createForm([\n    'hydrator' => ArraySerializable::class,\n    'elements' => [\n        [\n            'spec' => [\n                'name' => 'name',\n                'options' => [\n                    'label' => 'Your name',\n                ],\n                'type'  => 'Text',\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Email::class,\n                'name' => 'email',\n                'options' => [\n                    'label' => 'Your email address',\n                ]\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'subject',\n                'options' => [\n                    'label' => 'Subject',\n                ],\n                'type'  => 'Text',\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Textarea::class,\n                'name' => 'message',\n                'options' => [\n                    'label' => 'Message',\n                ]\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Captcha::class,\n                'name' => 'captcha',\n                'options' => [\n                    'label' => 'Please verify you are human.',\n                    'captcha' => [\n                        'class' => 'Dumb',\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n                'type' => Element\\Csrf::class,\n                'name' => 'security',\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'send',\n                'type'  => 'Submit',\n                'attributes' => [\n                    'value' => 'Submit',\n                ],\n            ],\n        ],\n    ],\n\n    /* If we had fieldsets, they'd go here; fieldsets contain\n     * \"elements\" and \"fieldsets\" keys, and potentially a \"type\"\n     * key indicating the specific FieldsetInterface\n     * implementation to use.\n    'fieldsets' => [\n    ],\n     */\n\n    // Configuration to pass on to\n    // Zend\\InputFilter\\Factory::createInputFilter()\n    'input_filter' => [\n        /* ... */\n    ],\n]);  If we wanted to use fieldsets, as we demonstrated in the previous example, we\ncould do the following:  use Zend\\Form\\Element;\nuse Zend\\Form\\Factory;\nuse Zend\\Hydrator\\ArraySerializable;\n\n$factory = new Factory();\n$form    = $factory->createForm([\n    'hydrator'  => ArraySerializable::class,\n\n    // Top-level fieldsets to define:\n    'fieldsets' => [\n        [\n            'spec' => [\n                'name' => 'sender',\n                'elements' => [\n                    [\n                        'spec' => [\n                            'name' => 'name',\n                            'options' => [\n                                'label' => 'Your name',\n                            ],\n                            'type' => 'Text'\n                        ],\n                    ],\n                    [\n                        'spec' => [\n                            'type' => Element\\Email::class,\n                            'name' => 'email',\n                            'options' => [\n                                'label' => 'Your email address',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n                'name' => 'details',\n                'elements' => [\n                    [\n                        'spec' => [\n                            'name' => 'subject',\n                            'options' => [\n                                'label' => 'Subject',\n                            ],\n                            'type' => 'Text',\n                        ],\n                    ],\n                    [\n                        'spec' => [\n                            'name' => 'message',\n                            'type' => Element\\Textarea::class,\n                            'options' => [\n                                'label' => 'Message',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    // You can specify an \"elements\" key explicitly:\n    'elements' => [\n        [\n            'spec' => [\n                'type' => Element\\Captcha::class,\n                'name' => 'captcha',\n                'options' => [\n                    'label' => 'Please verify you are human.',\n                    'captcha' => [\n                        'class' => 'Dumb',\n                    ],\n                ],\n            ],\n        ],\n        [\n            'spec' => [\n            'type' => Element\\Csrf::class,\n            'name' => 'security',\n        ],\n    ],\n\n    // But entries without string keys are also considered elements:\n    [\n        'spec' => [\n            'name' => 'send',\n            'type'  => 'Submit',\n            'attributes' => [\n                'value' => 'Submit',\n            ],\n        ],\n    ],\n\n    // Configuration to pass on to\n    // Zend\\InputFilter\\Factory::createInputFilter()\n    'input_filter' => [\n        /* ... */\n    ],\n]);  Note that the chief difference is nesting; otherwise, the information is\nbasically the same.  The chief benefits to using the  Factory  are allowing you to store definitions\nin configuration, and usage of significant whitespace.",
            "title": "Creation via Factory"
        },
        {
            "location": "/quick-start/#factory-backed-form-extension",
            "text": "The default  Form  implementation is backed by the  Factory . This allows you to\nextend it, and define your form internally. This has the benefit of allowing a\nmixture of programmatic and factory-backed creation, as well as defining a form\nfor re-use in your application.  namespace Contact;\n\nuse Zend\\Captcha\\AdapterInterface as CaptchaAdapter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass ContactForm extends Form\n{\n    protected $captcha;\n\n    public function __construct(CaptchaAdapter $captcha)\n    {\n        parent::__construct();\n\n        $this->captcha = $captcha;\n\n        // add() can take an Element/Fieldset instance, or a specification, from\n        // which the appropriate object will be built.\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Your name',\n            ],\n            'type'  => 'Text',\n        ]);\n        $this->add([\n            'type' => Element\\Email::class,\n            'name' => 'email',\n            'options' => [\n                'label' => 'Your email address',\n            ],\n        ]);\n        $this->add([\n            'name' => 'subject',\n            'options' => [\n                'label' => 'Subject',\n            ],\n            'type'  => 'Text',\n        ]);\n        $this->add([\n            'type' => Element\\Textarea::class,\n            'name' => 'message',\n            'options' => [\n                'label' => 'Message',\n            ],\n        ]);\n        $this->add([\n            'type' => Element\\Captcha::class,\n            'name' => 'captcha',\n            'options' => [\n                'label' => 'Please verify you are human.',\n                'captcha' => $this->captcha,\n            ],\n        ]);\n        $this->add(new Element\\Csrf('security'));\n        $this->add([\n            'name' => 'send',\n            'type'  => 'Submit',\n            'attributes' => [\n                'value' => 'Submit',\n            ],\n        ]);\n\n        // We could also define the input filter here, or\n        // lazy-create it in the getInputFilter() method.\n    }\n}  In the above example, elements are added in the constructor. This is done to\nallow altering and/or configuring either the form or input filter factory\ninstances, which could then have bearing on how elements, inputs, etc. are\ncreated. In this case, it also allows injection of the CAPTCHA adapter, allowing\nus to configure it elsewhere in our application and inject it into the form.",
            "title": "Factory-backed Form Extension"
        },
        {
            "location": "/quick-start/#validating-forms",
            "text": "Validating forms requires three steps. First, the form must have an input filter\nattached. Second, you must inject the data to validate into the form. Third, you\nvalidate the form. If invalid, you can retrieve the error messages, if any.  // assuming $captcha is an instance of some Zend\\Captcha\\AdapterInterface:\n$form = new Contact\\ContactForm($captcha);\n\n// If the form doesn't define an input filter by default, inject one.\n$form->setInputFilter(new Contact\\ContactFilter());\n\n// Get the data. In an MVC application, you might try:\n$data = $request->getPost();  // for POST data\n$data = $request->getQuery(); // for GET (or query string) data\n\n$form->setData($data);\n\n// Validate the form\nif ($form->isValid()) {\n    $validatedData = $form->getData();\n} else {\n    $messages = $form->getMessages();\n}",
            "title": "Validating Forms"
        },
        {
            "location": "/quick-start/#always-populate-select-elements-with-options",
            "text": "Always ensure that options for a select element are populated  prior  to\nvalidation; otherwise, the element will fail validation, and you will receive\na  NotInArray  error message.  If you are populating the options from a database or other data source, make\nsure this is done prior to validation. Alternately, you may disable the InArray  validator programmatically prior to validation:  $element->setDisableInArrayValidator(true);   You can get the raw data if you want, by accessing the composed input filter.  $filter = $form->getInputFilter();\n\n$rawValues    = $filter->getRawValues();\n$nameRawValue = $filter->getRawValue('name');",
            "title": "Always populate select elements with options"
        },
        {
            "location": "/quick-start/#hinting-to-the-input-filter",
            "text": "Often, you'll create elements that you expect to behave in the same way on each\nusage, and for which you'll want specific filters or validation as well. Since\nthe input filter is a separate object, how can you achieve these latter points?  Because the default form implementation composes a factory, and the default\nfactory composes an input filter factory, you can have your elements and/or\nfieldsets hint to the input filter. If no input or input filter is provided in\nthe input filter for that element, these hints will be retrieved and used to\ncreate them.  To do so, one of the following must occur. For elements, they must implement Zend\\InputFilter\\InputProviderInterface , which defines a getInputSpecification()  method; for fieldsets (and, by extension, forms), they\nmust implement  Zend\\InputFilter\\InputFilterProviderInterface , which defines a getInputFilterSpecification()  method.  In the case of an element, the  getInputSpecification()  method should return\ndata to be used by the input filter factory to create an input. Every HTML5\n( email ,  url ,  color , etc.) element has a built-in element that uses this\nlogic. For instance, here is how the  Zend\\Form\\Element\\Color  element is\ndefined:  namespace Zend\\Form\\Element;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputProviderInterface;\nuse Zend\\Validator\\Regex as RegexValidator;\nuse Zend\\Validator\\ValidatorInterface;\n\nclass Color extends Element implements InputProviderInterface\n{\n    /**\n     * Seed attributes\n     *\n     * @var array\n     */\n    protected $attributes = [\n        'type' => 'color',\n    ];\n\n    /**\n     * @var ValidatorInterface\n     */\n    protected $validator;\n\n    /**\n     * Get validator\n     *\n     * @return ValidatorInterface\n     */\n    protected function getValidator()\n    {\n        if (null === $this->validator) {\n            $this->validator = new RegexValidator('/^#[0-9a-fA-F]{6}$/');\n        }\n        return $this->validator;\n    }\n\n    /**\n     * Provide default input rules for this element\n     *\n     * Attaches an email validator.\n     *\n     * @return array\n     */\n    public function getInputSpecification()\n    {\n        return [\n            'name' => $this->getName(),\n            'required' => true,\n            'filters' => [\n                ['name' => Filter\\StringTrim::class],\n                ['name' => Filter\\StringToLower::class],\n            ],\n            'validators' => [\n                $this->getValidator(),\n            ],\n        ];\n    }\n}  The above hints to the input filter to create and attach an input named after\nthe element, marking it as required, giving it  StringTrim  and  StringToLower \nfilters, and defining a  Regex  validator. Note that you can either rely on the\ninput filter to create filters and validators, or directly instantiate them.  For fieldsets, you do very similarly; the difference is that getInputFilterSpecification()  must return configuration for an input filter.  namespace Contact\\Form;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Validator;\n\nclass SenderFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n                'filters'  => [\n                    ['name' => Filter\\StringTrim::class],\n                ],\n                'validators' => [\n                    [\n                        'name' => Validator\\StringLength::class,\n                        'options' => [\n                            'min' => 3,\n                            'max' => 256\n                        ],\n                    ],\n                ],\n            ],\n            'email' => [\n                'required' => true,\n                'filters'  => [\n                    ['name' => Filter\\StringTrim::class],\n                ],\n                'validators' => [\n                    new Validator\\EmailAddress(),\n                ],\n            ],\n        ];\n    }\n}  Specifications are a great way to make forms, fieldsets, and elements re-usable\ntrivially in your applications. In fact, the  Captcha  and  Csrf  elements\ndefine specifications in order to ensure they can work without additional user\nconfiguration!",
            "title": "Hinting to the Input Filter"
        },
        {
            "location": "/quick-start/#use-the-most-specific-input-type",
            "text": "If you set custom input filter specification either in getInputSpecification()  or in  getInputFilterSpecification() , the Zend\\InputFilter\\InputInterface  set for that specific field is reset to the\ndefault  Zend\\InputFilter\\Input .  Some form elements may need a particular input filter, like Zend\\Form\\Element\\File : in this case it's mandatory to specify the  type \nkey in your custom specification to match the original one (e.g., for the\nfile element, use  Zend\\InputFilter\\FileInput ).",
            "title": "Use the most specific input type"
        },
        {
            "location": "/quick-start/#binding-an-object",
            "text": "As noted in the introduction, forms bridge the domain model and the view layer.\nLet's see that in action.  When you  bind()  an object to the form, the following happens:   The composed  Hydrator  calls  extract()  on the object, and uses the values\n  returned, if any, to populate the  value  attributes of all elements. If a\n  form contains a fieldset that itself contains another fieldset, the form will\n  recursively extract the values.  When  isValid()  is called, if  setData()  has not been previously set, the\n  form uses the composed  Hydrator  to extract values from the object, and uses\n  those during validation.  If  isValid()  is successful (and the  bindOnValidate  flag is enabled, which\n  is true by default), then the  Hydrator  will be passed the validated values\n  to use to hydrate the bound object. (If you do not want this behavior, call\n   setBindOnValidate(FormInterface::BIND_MANUAL) ).  If the object implements  Zend\\InputFilter\\InputFilterAwareInterface , the\n  input filter it composes will be used instead of the one composed on the form.   This is easier to understand with an example.  $contact = new ArrayObject;\n$contact['subject'] = '[Contact Form] ';\n$contact['message'] = 'Type your message here';\n\n$form = new Contact\\ContactForm;\n\n$form->bind($contact); // form now has default values for\n                       // 'subject' and 'message'\n\n$data = [\n    'name'    => 'John Doe',\n    'email'   => 'j.doe@example.tld',\n    'subject' => '[Contact Form] \\'sup?',\n];\n$form->setData($data);\n\nif ($form->isValid()) {\n    // $contact now has the following structure:\n    // [\n    //     'name'    => 'John Doe',\n    //     'email'   => 'j.doe@example.tld',\n    //     'subject' => '[Contact Form] \\'sup?',\n    //     'message' => 'Type your message here',\n    // ]\n    // But is an ArrayObject instance!\n}  When an object is bound to the form, calling  getData()  will return that object\nby default. If you want to return an associative array instead, you can pass the FormInterface::VALUES_AS_ARRAY  flag to the method.  use Zend\\Form\\FormInterface;\n$data = $form->getData(FormInterface::VALUES_AS_ARRAY);  Zend Framework ships several standard  hydrators ;\nyou can create custom hydrators by implementing  Zend\\Hydrator\\HydratorInterface ,\nwhich looks like this:  namespace Zend\\Hydrator;\n\ninterface HydratorInterface\n{\n    /** @return array */\n    public function extract($object);\n    public function hydrate(array $data, $object);\n}",
            "title": "Binding an object"
        },
        {
            "location": "/quick-start/#rendering",
            "text": "As noted previously, forms are meant to bridge the domain model and view layer.\nWe've discussed the domain model binding, but what about the view?  The form component ships a set of form-specific view helpers. These accept the\nvarious form objects, and introspect them in order to generate markup.\nTypically, they will inspect the attributes, but in special cases, they may look\nat other properties and composed objects.  When preparing to render, you will generally want to call  prepare() . This\nmethod ensures that certain injections are done, and ensures that elements\nnested in fieldsets and collections generate names in array notation (e.g., scoped[array][notation] ).  The base view helpers used everywhere are  Form ,  FormElement ,  FormLabel ,\nand  FormElementErrors . Let's use them to display the contact form.  <?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Get the form label plugin\n$formLabel = $this->plugin('formLabel');\n\n// Render the opening tag\necho $this->form()->openTag($form);\n?>\n<div class=\"form_element\">\n<?php\n    $name = $form->get('name');\n    echo $formLabel->openTag() . $name->getOption('label');\n    echo $this->formInput($name);\n    echo $this->formElementErrors($name);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $subject = $form->get('subject');\n    echo $formLabel->openTag() . $subject->getOption('label');\n    echo $this->formInput($subject);\n    echo $this->formElementErrors($subject);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $message = $form->get('message');\n    echo $formLabel->openTag() . $message->getOption('label');\n    echo $this->formTextarea($message);\n    echo $this->formElementErrors($message);\n    echo $formLabel->closeTag();\n?></div>\n\n<div class=\"form_element\">\n<?php\n    $captcha = $form->get('captcha');\n    echo $formLabel->openTag() . $captcha->getOption('label');\n    echo $this->formCaptcha($captcha);\n    echo $this->formElementErrors($captcha);\n    echo $formLabel->closeTag();\n?></div>\n\n<?= $this->formElement($form->get('security')) ?>\n<?= $this->formElement($form->get('send')) ?>\n\n<?= $this->form()->closeTag() ?>  There are a few things to note about this. First, to prevent confusion in IDEs\nand editors when syntax highlighting, we use helpers to both open and close the\nform and label tags. Second, there's a lot of repetition happening here; we\ncould easily create a partial view script or a composite helper to reduce\nboilerplate. Third, note that not all elements are created equal \u2014 the\nCSRF and submit elements don't need labels or error messages. Finally, note that\nthe  FormElement  helper tries to do the right thing \u2014 it delegates actual\nmarkup generation to other view helpers. However, it can only guess what\nspecific form helper to delegate to based on the list it has. If you introduce\nnew form view helpers, you'll need to extend the  FormElement  helper, or create\nyour own.  Following the example above, your view files can quickly become long and\nrepetitive to write. While we do not currently provide a single-line form view\nhelper (as this reduces the form customization), we do provide convenience\nwrappers around emitting individual elements via the  FormRow  view helper, and\ncollections of elements ( Zend\\Form\\Element\\Collection ,  Zend\\Form\\Fieldset , or Zend\\Form\\Form ) via the  FormCollection  view helper (which, internally,\niterates the collection and calls  FormRow  for each element, recursively\nfollowing collections).  The  FormRow  view helper automatically renders a label (if present), the\nelement itself using the  FormElement  helper, as well as any errors that could\narise. Here is the previous form, rewritten to take advantage of this helper:  <?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Render the opening tag\necho $this->form()->openTag($form);\n?>\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('name')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('subject')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('message')) ?>\n</div>\n\n<div class=\"form_element\">\n    <?= $this->formRow($form->get('captcha')) ?>\n</div>\n\n<?= $this->formElement($form->get('security')) ?>\n<?= $this->formElement($form->get('send')) ?>\n\n<?= $this->form()->closeTag() ?>  Note that  FormRow  helper automatically prepends the label. If you want it to\nbe rendered after the element itself, you can pass an optional parameter to the FormRow  view helper :  <div class=\"form_element\">\n    <?= $this->formRow($form->get('name'), 'append') ?>\n</div>  As noted previously, the  FormCollection  view helper will iterate any\ncollection \u2014 including  Zend\\Form\\Element\\Collection , fieldsets, and\nforms \u2014 emitting each element discovered using  FormRow .  FormCollection  does not render fieldset or form tags ; you will be responsible for emitting\nthose yourself.  The above examples can now be rewritten again:  <?php\n// within a view script\n$form = $this->form;\n$form->prepare();\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\n// Render the opening tag\necho $this->form()->openTag($form);\necho $this->formCollection($form);\necho $this->form()->closeTag();  Finally, the  Form  view helper can optionally accept a  Zend\\Form\\Form \ninstance; if provided, it will prepare the form, iterate it, and render all\nelements using either  FormRow  (for non-collection elements) or FormCollection  (for collections and fieldsets):  <?php\n// within a view script\n$form = $this->form;\n\n// Assuming the \"contact/process\" route exists...\n$form->setAttribute('action', $this->url('contact/process'));\n\n// Set the method attribute for the form\n$form->setAttribute('method', 'post');\n\necho $this->form($form);  One important point to note about the last two examples: while they greatly\nsimplifies emitting the form, you also lose most customization opportunities.\nThe above, for example, will not include the  <div class=\"form_element\"></div> \nwrappers from the previous examples! As such, you will generally want to use\nthis facility only when prototyping.",
            "title": "Rendering"
        },
        {
            "location": "/quick-start/#taking-advantage-of-html5-input-attributes",
            "text": "HTML5 brings a lot of exciting features, one of them being simplified client\nform validations. zend-form provides elements corresponding to the various HTML5\nelements, specifying the client-side attributes required by them. Additionally,\neach implements  InputProviderInterface , ensuring that your input filter will\nhave reasonable default validation and filtering rules that mimic the\nclient-side validations.",
            "title": "Taking advantage of HTML5 input attributes"
        },
        {
            "location": "/quick-start/#always-validate-server-side",
            "text": "Although client validation is nice from a user experience point of view, it\nmust be used in addition to server-side validation, as client validation can\nbe easily bypassed.",
            "title": "Always validate server-side"
        },
        {
            "location": "/quick-start/#validation-groups",
            "text": "Sometimes you want to validate only a subset of form elements. As an example,\nlet's say we're re-using our contact form over a web service; in this case, the Csrf ,  Captcha , and submit button elements are not of interest, and shouldn't\nbe validated.  zend-form provides a proxy method to the underlying  InputFilter 's setValidationGroup()  method, allowing us to perform this operation.  $form->setValidationGroup('name', 'email', 'subject', 'message');\n$form->setData($data);\nif ($form->isValid()) {\n    // Contains only the \"name\", \"email\", \"subject\", and \"message\" values\n    $data = $form->getData();\n}  If you later want to reset the form to validate all elements, pass the FormInterface::VALIDATE_ALL  flag to the  setValidationGroup()  method:  use Zend\\Form\\FormInterface;\n$form->setValidationGroup(FormInterface::VALIDATE_ALL);  When your form contains nested fieldsets, you can use an array notation to\nvalidate only a subset of the fieldsets :  $form->setValidationGroup(['profile' => [\n    'firstname',\n    'lastname',\n] ]);\n\n$form->setData($data);\nif ($form->isValid()) {\n    // Contains only the \"firstname\" and \"lastname\" values from the\n    // \"profile\" fieldset\n    $data = $form->getData();\n}",
            "title": "Validation Groups"
        },
        {
            "location": "/quick-start/#using-annotations",
            "text": "Creating a complete form solution can often be tedious: you'll create a domain\nmodel object, an input filter for validating it, a form object for providing a\nrepresentation for it, and potentially a hydrator for mapping the form elements\nand fieldsets to the domain model. Wouldn't it be nice to have a central place\nto define all of these?  Annotations allow us to solve this problem. You can define the following\nbehaviors with the shipped annotations in zend-form:   AllowEmpty : mark an input as allowing an empty value. This annotation does\n  not require a value.  Attributes : specify the form, fieldset, or element attributes. This\n  annotation requires an associative array of values, in a JSON object format:\n   @Attributes({\"class\":\"zend_form\",\"type\":\"text\"}) .  ComposedObject : specify another object with annotations to parse. Typically,\n  this is used if a property references another object, which will then be added\n  to your form as an additional fieldset.  Expects a string value indicating the\n  class for the object being composed:  @ComposedObject(\"Namespace\\Model\\ComposedObject\") ;\n  or an array to compose a collection:\n   @ComposedObject({ \"target_object\":\"Namespace\\Model\\ComposedCollection\", \"is_collection\":\"true\", \"options\":{\"count\":2}}) ;\n   target_object  is the element to compose,  is_collection  flags this as a\n  collection, and  options  can take an array of options to pass into the\n  collection.  ErrorMessage : specify the error message to return for an element in the case\n  of a failed validation. Expects a string value.  Exclude : mark a property to exclude from the form or fieldset. This\n  annotation does not require a value.  Filter : provide a specification for a filter to use on a given element.\n  Expects an associative array of values, with a \"name\" key pointing to a string\n  filter name, and an \"options\" key pointing to an associative array of filter\n  options for the constructor:  @Filter({\"name\": \"Boolean\", \"options\": {\"casting\":true}}) .\n  This annotation may be specified multiple times.  Flags : flags to pass to the fieldset or form composing an element or\n  fieldset; these are usually used to specify the name or priority. The\n  annotation expects an associative array:  @Flags({\"priority\": 100}) .  Hydrator : specify the hydrator class to use for this given form or fieldset.\n  A string value is expected.  InputFilter : specify the input filter class to use for this given form or\n  fieldset. A string value is expected.  Input : specify the input class to use for this given element. A string value\n  is expected.  Instance : specify an object class instance to bind to the form or fieldset.  Name : specify the name of the current element, fieldset, or form. A string\n  value is expected.  Object : specify an object class instance to bind to the form or fieldset.\n  (Note: this is deprecated in 2.4.0; use  Instance  instead.)  Options : options to pass to the fieldset or form that are used to inform\n  behavior \u2014 things that are not attributes; e.g. labels, CAPTCHA adapters,\n  etc. The annotation expects an associative array:  @Options({\"label\": \"Username:\"}) .  Required : indicate whether an element is required. A boolean value is\n  expected. By default, all elements are required, so this annotation is mainly\n  present to allow disabling a requirement.  Type : indicate the class to use for the current element, fieldset, or form.\n  A string value is expected.  Validator : provide a specification for a validator to use on a given\n  element. Expects an associative array of values, with a \"name\" key pointing to\n  a string validator name, and an \"options\" key pointing to an associative array\n  of validator options for the constructor:\n   @Validator({\"name\": \"StringLength\", \"options\": {\"min\":3, \"max\": 25}}) .\n  This annotation may be specified multiple times.   To use annotations, include them in your class and/or property docblocks.\nAnnotation names will be resolved according to the import statements in your\nclass; as such, you can make them as long or as short as you want depending on\nwhat you import.",
            "title": "Using Annotations"
        },
        {
            "location": "/quick-start/#doctrinecommon-dependency",
            "text": "Form annotations require  doctrine\\common , which contains an annotation\nparsing engine. Install it using composer:  $ composer require doctrine/common   Here's an example:  use Zend\\Form\\Annotation;\n\n/**\n * @Annotation\\Name(\"user\")\n * @Annotation\\Hydrator(\"Zend\\Hydrator\\ObjectProperty\")\n */\nclass User\n{\n    /**\n     * @Annotation\\Exclude()\n     */\n    public $id;\n\n    /**\n     * @Annotation\\Filter({\"name\":\"StringTrim\"})\n     * @Annotation\\Validator({\"name\":\"StringLength\", \"options\":{\"min\":1, \"max\":25}})\n     * @Annotation\\Validator({\"name\":\"Regex\",\n\"options\":{\"pattern\":\"/^[a-zA-Z][a-zA-Z0-9_-]{0,24}$/\"}})\n     * @Annotation\\Attributes({\"type\":\"text\"})\n     * @Annotation\\Options({\"label\":\"Username:\"})\n     */\n    public $username;\n\n    /**\n     * @Annotation\\Type(\"Zend\\Form\\Element\\Email\")\n     * @Annotation\\Options({\"label\":\"Your email address:\"})\n     */\n    public $email;\n}  The above will hint to the annotation builder to create a form with name \"user\",\nwhich uses the hydrator  Zend\\Hydrator\\ObjectProperty . That form will\nhave two elements, \"username\" and \"email\". The \"username\" element will have an\nassociated input that has a  StringTrim  filter, and two validators: a StringLength  validator indicating the username is between 1 and 25 characters,\nand a  Regex  validator asserting it follows a specific accepted pattern. The\nform element itself will have an attribute \"type\" with value \"text\" (a text\nelement), and a label \"Username:\". The \"email\" element will be of type Zend\\Form\\Element\\Email , and have the label \"Your email address:\".  To use the above, we need  Zend\\Form\\Annotation\\AnnotationBuilder :  use Zend\\Form\\Annotation\\AnnotationBuilder;\n\n$builder = new AnnotationBuilder();\n$form    = $builder->createForm(User::class);  At this point, you have a form with the appropriate hydrator attached, an input\nfilter with the appropriate inputs, and all elements.",
            "title": "doctrine/common dependency"
        },
        {
            "location": "/quick-start/#youre-not-done",
            "text": "In all likelihood, you'll need to add some more elements to the form you\nconstruct. For example, you'll want a submit button, and likely a\nCSRF-protection element. We recommend creating a fieldset with common elements\nsuch as these that you can then attach to the form you build via annotations.",
            "title": "You're not done"
        },
        {
            "location": "/element/intro/",
            "text": "Form Elements\n\n\nA set of specialized elements are provided for accomplishing application-centric\ntasks. These include several HTML5 input elements with matching server-side\nvalidators, the \nCsrf\n element (to prevent Cross Site Request Forgery attacks),\nand the \nCaptcha\n element (to display and validate\n\nCAPTCHAs\n).\n\n\nA \nFactory\n is provided to facilitate creation of elements, fieldsets, forms,\nand the related input filter. See the \nquick start\n\nfor more information.",
            "title": "Intro"
        },
        {
            "location": "/element/intro/#form-elements",
            "text": "A set of specialized elements are provided for accomplishing application-centric\ntasks. These include several HTML5 input elements with matching server-side\nvalidators, the  Csrf  element (to prevent Cross Site Request Forgery attacks),\nand the  Captcha  element (to display and validate CAPTCHAs ).  A  Factory  is provided to facilitate creation of elements, fieldsets, forms,\nand the related input filter. See the  quick start \nfor more information.",
            "title": "Form Elements"
        },
        {
            "location": "/element/element/",
            "text": "Element Base Class\n\n\nZend\\Form\\Element\n is a base class for all specialized elements and\n\nZend\\Form\\Fieldset\n.\n\n\nBasic Usage\n\n\nAt the bare minimum, each element or fieldset requires a name. You will also\ntypically provide some attributes to hint to the view layer how it might render\nthe item.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$username = new Element\\Text('username');\n$username->setLabel('Username');\n$username->setAttributes([\n    'class' => 'username',\n    'size'  => '30',\n]);\n\n$password = new Element\\Password('password');\n$password->setLabel('Password')\n$password->setAttributes([\n    'size'  => '30',\n]);\n\n$form = new Form('my-form');\n$form->add($username);\n$form->add($password);\n\n\n\nPublic Methods\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetName(string $name) : void\n\n\nSet the name for this element.\n\n\n\n\n\n\ngetName() : string\n\n\nReturn the name for this element.\n\n\n\n\n\n\nsetValue(string $value) : void\n\n\nSet the value for this element.\n\n\n\n\n\n\ngetValue() : string\n\n\nReturn the value for this element.\n\n\n\n\n\n\nsetLabel(string $label) : void\n\n\nSet the label content for this element.\n\n\n\n\n\n\ngetLabel() : string\n\n\nReturn the label content for this element.\n\n\n\n\n\n\nsetLabelAttributes(array $labelAttributes) : void\n\n\nSet the attributes to use with the label.\n\n\n\n\n\n\ngetLabelAttributes() : array\n\n\nReturn the attributes to use with the label.\n\n\n\n\n\n\nsetLabelOptions(array $labelOptions) : void\n\n\nSet label specific options.\n\n\n\n\n\n\ngetLabelOptions() : array\n\n\nReturn the label specific options.\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element. Accepted options are: \nlabel\n, \nlabel_attributes\"\n, \nlabel_options\n, which call \nsetLabel\n, \nsetLabelAttributes\n and \nsetLabelOptions\n, respectively.\n\n\n\n\n\n\ngetOptions() : array\n\n\nGet defined options for an element\n\n\n\n\n\n\ngetOption(string $option) : null|mixed\n\n\nReturn the specified option, if defined. If it's not defined, returns null.\n\n\n\n\n\n\nsetAttribute(string $key, mixed $value) : void\n\n\nSet a single element attribute.\n\n\n\n\n\n\ngetAttribute(string $key) : mixed\n\n\nRetrieve a single element attribute.\n\n\n\n\n\n\nremoveAttribute(string $key) : void\n\n\nRemove a single attribute\n\n\n\n\n\n\nhasAttribute(string $key) : boolean\n\n\nCheck if a specific attribute exists for this element.\n\n\n\n\n\n\nsetAttributes(array|Traversable $arrayOrTraversable) : void\n\n\nSet many attributes at once. Implementation will decide if this will overwrite or merge.\n\n\n\n\n\n\ngetAttributes() : array|Traversable\n\n\nRetrieve all attributes at once.\n\n\n\n\n\n\nremoveAttributes(array $keys) : void\n\n\nRemove many attributes at once\n\n\n\n\n\n\nclearAttributes() : void\n\n\nClear all attributes for this element.\n\n\n\n\n\n\nsetMessages(array|Traversable $messages) : void\n\n\nSet a list of messages to report when validation fails.\n\n\n\n\n\n\ngetMessages() : array|Traversable\n\n\nReturns a list of validation failure messages, if any.",
            "title": "Element"
        },
        {
            "location": "/element/element/#element-base-class",
            "text": "Zend\\Form\\Element  is a base class for all specialized elements and Zend\\Form\\Fieldset .",
            "title": "Element Base Class"
        },
        {
            "location": "/element/element/#basic-usage",
            "text": "At the bare minimum, each element or fieldset requires a name. You will also\ntypically provide some attributes to hint to the view layer how it might render\nthe item.  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$username = new Element\\Text('username');\n$username->setLabel('Username');\n$username->setAttributes([\n    'class' => 'username',\n    'size'  => '30',\n]);\n\n$password = new Element\\Password('password');\n$password->setLabel('Password')\n$password->setAttributes([\n    'size'  => '30',\n]);\n\n$form = new Form('my-form');\n$form->add($username);\n$form->add($password);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/element/#public-methods",
            "text": "Method signature  Description      setName(string $name) : void  Set the name for this element.    getName() : string  Return the name for this element.    setValue(string $value) : void  Set the value for this element.    getValue() : string  Return the value for this element.    setLabel(string $label) : void  Set the label content for this element.    getLabel() : string  Return the label content for this element.    setLabelAttributes(array $labelAttributes) : void  Set the attributes to use with the label.    getLabelAttributes() : array  Return the attributes to use with the label.    setLabelOptions(array $labelOptions) : void  Set label specific options.    getLabelOptions() : array  Return the label specific options.    setOptions(array $options) : void  Set options for an element. Accepted options are:  label ,  label_attributes\" ,  label_options , which call  setLabel ,  setLabelAttributes  and  setLabelOptions , respectively.    getOptions() : array  Get defined options for an element    getOption(string $option) : null|mixed  Return the specified option, if defined. If it's not defined, returns null.    setAttribute(string $key, mixed $value) : void  Set a single element attribute.    getAttribute(string $key) : mixed  Retrieve a single element attribute.    removeAttribute(string $key) : void  Remove a single attribute    hasAttribute(string $key) : boolean  Check if a specific attribute exists for this element.    setAttributes(array|Traversable $arrayOrTraversable) : void  Set many attributes at once. Implementation will decide if this will overwrite or merge.    getAttributes() : array|Traversable  Retrieve all attributes at once.    removeAttributes(array $keys) : void  Remove many attributes at once    clearAttributes() : void  Clear all attributes for this element.    setMessages(array|Traversable $messages) : void  Set a list of messages to report when validation fails.    getMessages() : array|Traversable  Returns a list of validation failure messages, if any.",
            "title": "Public Methods"
        },
        {
            "location": "/element/button/",
            "text": "Button\n\n\nZend\\Form\\Element\\Button\n represents a button form input.\nIt can be used with the \nZend\\Form\\View\\Helper\\FormButton\n view helper.\n\n\nZend\\Form\\Element\\Button\n extends from \nZend\\Form\\Element\n.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nbutton\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$button = new Element\\Button('my-button');\n$button->setLabel('My Button');\n$button->setValue('foo');\n\n$form = new Form('my-form');\n$form->add($button);",
            "title": "button"
        },
        {
            "location": "/element/button/#button",
            "text": "Zend\\Form\\Element\\Button  represents a button form input.\nIt can be used with the  Zend\\Form\\View\\Helper\\FormButton  view helper.  Zend\\Form\\Element\\Button  extends from  Zend\\Form\\Element .",
            "title": "Button"
        },
        {
            "location": "/element/button/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  button .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$button = new Element\\Button('my-button');\n$button->setLabel('My Button');\n$button->setValue('foo');\n\n$form = new Form('my-form');\n$form->add($button);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/captcha/",
            "text": "Captcha\n\n\nZend\\Form\\Element\\Captcha\n can be used with forms where authenticated users are\nnot necessary, but you want to prevent spam submissions. It is paired with one\nof the \nZend\\Form\\View\\Helper\\Captcha\\*\n view helpers that matches the type of\nCAPTCHA adapter in use.\n\n\nBasic Usage\n\n\nA CAPTCHA adapter must be attached in order for validation to be included in the\nelement's input filter specification. See the \nzend-captcha documentation\n\nfor more information on what adapters are available.\n\n\nuse Zend\\Captcha;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n$form = new Form('my-form');\n$form->add($captcha);\n\n\n\nHere is an example using array notation:\n\n\nuse Zend\\Captcha;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => 'Zend\\Form\\Element\\Captcha',\n    'name' => 'captcha',\n    'options' => [\n        'label' => 'Please verify you are human',\n        'captcha' => new Captcha\\Dumb(),\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nCaptcha\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetCaptcha(array|Zend\\Captcha\\AdapterInterface $captcha) : void\n\n\nSet the CAPTCHA adapter for this element. If \n$captcha\n is an array, \nZend\\Captcha\\Factory::factory()\n will be run to create the adapter from the array configuration.\n\n\n\n\n\n\ngetCaptcha() : Zend\\Captcha\\AdapterInterface\n\n\nReturn the CAPTCHA adapter for this element.\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes a \nZend\\Filter\\StringTrim\n filter, and a CAPTCHA validator.",
            "title": "CAPTCHA"
        },
        {
            "location": "/element/captcha/#captcha",
            "text": "Zend\\Form\\Element\\Captcha  can be used with forms where authenticated users are\nnot necessary, but you want to prevent spam submissions. It is paired with one\nof the  Zend\\Form\\View\\Helper\\Captcha\\*  view helpers that matches the type of\nCAPTCHA adapter in use.",
            "title": "Captcha"
        },
        {
            "location": "/element/captcha/#basic-usage",
            "text": "A CAPTCHA adapter must be attached in order for validation to be included in the\nelement's input filter specification. See the  zend-captcha documentation \nfor more information on what adapters are available.  use Zend\\Captcha;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n$form = new Form('my-form');\n$form->add($captcha);  Here is an example using array notation:  use Zend\\Captcha;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => 'Zend\\Form\\Element\\Captcha',\n    'name' => 'captcha',\n    'options' => [\n        'label' => 'Please verify you are human',\n        'captcha' => new Captcha\\Dumb(),\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/captcha/#public-methods",
            "text": "The following methods are specific to the  Captcha  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      setCaptcha(array|Zend\\Captcha\\AdapterInterface $captcha) : void  Set the CAPTCHA adapter for this element. If  $captcha  is an array,  Zend\\Captcha\\Factory::factory()  will be run to create the adapter from the array configuration.    getCaptcha() : Zend\\Captcha\\AdapterInterface  Return the CAPTCHA adapter for this element.    getInputSpecification() : array  Returns a input filter specification, which includes a  Zend\\Filter\\StringTrim  filter, and a CAPTCHA validator.",
            "title": "Public Methods"
        },
        {
            "location": "/element/checkbox/",
            "text": "Checkbox\n\n\nZend\\Form\\Element\\Checkbox\n is meant to be paired with the\n\nZend\\Form\\View\\Helper\\FormCheckbox\n for HTML inputs with type checkbox. This\nelement adds an \nInArray\n validator to its input filter specification in order\nto validate on the server if the checkbox contains either the checked value or\nthe unchecked value.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ncheckbox\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$checkbox = new Element\\Checkbox('checkbox');\n$checkbox->setLabel('A checkbox');\n$checkbox->setUseHiddenElement(true);\n$checkbox->setCheckedValue('good');\n$checkbox->setUncheckedValue('bad');\n\n$form = new Form('my-form');\n$form->add($checkbox);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Checkbox::class,\n    'name' => 'checkbox',\n    'options' => [\n        'label' => 'A checkbox',\n        'use_hidden_element' => true,\n        'checked_value' => 'good',\n        'unchecked_value' => 'bad',\n    ],\n]);\n\n\n\nWhen creating a checkbox element, setting an attribute of \nchecked\n will result\nin the checkbox always being checked, regardless of any data object which might\nsubsequently be bound to the form. The correct way to set the default value of a\ncheckbox is to set the \nvalue\n attribute as for any other element. To have a\ncheckbox checked by default, make the \nvalue\n equal to the \nchecked_value\n eg:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Checkbox::class,\n    'name' => 'checkbox',\n    'options' => [\n        'label' => 'A checkbox',\n        'use_hidden_element' => true,\n        'checked_value' => 'yes',\n        'unchecked_value' => 'no',\n    ],\n    'attributes' => [\n         'value' => 'yes',\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nCheckbox\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element of type Checkbox. Accepted options, in addition to the options inherited from \nElement\n , are: \nuse_hidden_element\n, \nchecked_value\n and \nunchecked_value\n , which call \nsetUseHiddenElement()\n, \nsetCheckedValue()\n and \nsetUncheckedValue()\n , respectively.\n\n\n\n\n\n\nsetUseHiddenElement(boolean $useHiddenElement) : void\n\n\nIf set to true (which is default), the view helper will generate a hidden element that contains the unchecked value. Therefore, when using custom unchecked value, this option have to be set to true.\n\n\n\n\n\n\nuseHiddenElement() : boolean\n\n\nReturn if a hidden element is generated.\n\n\n\n\n\n\nsetCheckedValue(string $checkedValue) : void\n\n\nSet the value to use when the checkbox is checked.\n\n\n\n\n\n\ngetCheckedValue() : string\n\n\nReturn the value used when the checkbox is checked.\n\n\n\n\n\n\nsetUncheckedValue(string $uncheckedValue) : void\n\n\nSet the value to use when the checkbox is unchecked. For this to work, you must make sure that \nuse_hidden_element\n is set to true.\n\n\n\n\n\n\ngetUncheckedValue() : string\n\n\nReturn the value used when the checkbox is unchecked.\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Validator\\InArray\n to validate if the value is one of the \nchecked\n or \nunchecked\n values.\n\n\n\n\n\n\nisChecked() : boolean\n\n\nChecks if the checkbox is checked.\n\n\n\n\n\n\nsetChecked(bool $value) : void\n\n\nChecks or unchecks the checkbox.",
            "title": "checkbox"
        },
        {
            "location": "/element/checkbox/#checkbox",
            "text": "Zend\\Form\\Element\\Checkbox  is meant to be paired with the Zend\\Form\\View\\Helper\\FormCheckbox  for HTML inputs with type checkbox. This\nelement adds an  InArray  validator to its input filter specification in order\nto validate on the server if the checkbox contains either the checked value or\nthe unchecked value.",
            "title": "Checkbox"
        },
        {
            "location": "/element/checkbox/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  checkbox .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$checkbox = new Element\\Checkbox('checkbox');\n$checkbox->setLabel('A checkbox');\n$checkbox->setUseHiddenElement(true);\n$checkbox->setCheckedValue('good');\n$checkbox->setUncheckedValue('bad');\n\n$form = new Form('my-form');\n$form->add($checkbox);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Checkbox::class,\n    'name' => 'checkbox',\n    'options' => [\n        'label' => 'A checkbox',\n        'use_hidden_element' => true,\n        'checked_value' => 'good',\n        'unchecked_value' => 'bad',\n    ],\n]);  When creating a checkbox element, setting an attribute of  checked  will result\nin the checkbox always being checked, regardless of any data object which might\nsubsequently be bound to the form. The correct way to set the default value of a\ncheckbox is to set the  value  attribute as for any other element. To have a\ncheckbox checked by default, make the  value  equal to the  checked_value  eg:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Checkbox::class,\n    'name' => 'checkbox',\n    'options' => [\n        'label' => 'A checkbox',\n        'use_hidden_element' => true,\n        'checked_value' => 'yes',\n        'unchecked_value' => 'no',\n    ],\n    'attributes' => [\n         'value' => 'yes',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/checkbox/#public-methods",
            "text": "The following methods are specific to the  Checkbox  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      setOptions(array $options) : void  Set options for an element of type Checkbox. Accepted options, in addition to the options inherited from  Element  , are:  use_hidden_element ,  checked_value  and  unchecked_value  , which call  setUseHiddenElement() ,  setCheckedValue()  and  setUncheckedValue()  , respectively.    setUseHiddenElement(boolean $useHiddenElement) : void  If set to true (which is default), the view helper will generate a hidden element that contains the unchecked value. Therefore, when using custom unchecked value, this option have to be set to true.    useHiddenElement() : boolean  Return if a hidden element is generated.    setCheckedValue(string $checkedValue) : void  Set the value to use when the checkbox is checked.    getCheckedValue() : string  Return the value used when the checkbox is checked.    setUncheckedValue(string $uncheckedValue) : void  Set the value to use when the checkbox is unchecked. For this to work, you must make sure that  use_hidden_element  is set to true.    getUncheckedValue() : string  Return the value used when the checkbox is unchecked.    getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Validator\\InArray  to validate if the value is one of the  checked  or  unchecked  values.    isChecked() : boolean  Checks if the checkbox is checked.    setChecked(bool $value) : void  Checks or unchecks the checkbox.",
            "title": "Public Methods"
        },
        {
            "location": "/element/collection/",
            "text": "Collection\n\n\nSometimes, you may want to add an input (or a set of inputs) multiple times,\neither because you don't want to duplicate code, or because you do not know in\nadvance how many elements you will need (in the case of elements dynamically\nadded to a form using Javascript, for instance). For more information about\ncollections, please refer to the \nform Collections tutorial\n.\n\n\nZend\\Form\\Element\\Collection\n is meant to be paired with the\n\nZend\\Form\\View\\Helper\\FormCollection\n.\n\n\nBasic Usage\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$colors = new Element\\Collection('collection');\n$colors->setLabel('Colors');\n$colors->setCount(2);\n$colors->setTargetElement(new Element\\Color());\n$colors->setShouldCreateTemplate(true);\n\n$form = new Form('my-form');\n$form->add($colors);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Collection::class,\n    'options' => [\n        'label' => 'Colors',\n        'count' => 2,\n        'should_create_template' => true,\n        'target_element' => new Element\\Color()\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nCollection\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element of type Collection. Accepted options, in addition to the options inherited from \nElement\n, are: \ntarget_element\n, \ncount\n, \nallow_add\n, \nallow_remove\n, \nshould_create_template\n and \ntemplate_placeholder\n. Those option keys respectively call \nsetTargetElement()\n, \nsetCount()\n, \nsetAllowAdd()\n, \nsetAllowRemove()\n, \nsetShouldCreateTemplate()\n and \nsetTemplatePlaceholder()\n.\n\n\n\n\n\n\nallowObjectBinding(object $object) : bool\n\n\nChecks if the object can be set in this fieldset.\n\n\n\n\n\n\nsetObject(array|Traversable $object) : void\n\n\nSet the object used by the hydrator. In this case the \"object\" is a collection of objects.\n\n\n\n\n\n\npopulateValues(array|Traversable $data) : void\n\n\nPopulate values\n\n\n\n\n\n\nallowValueBinding() : bool\n\n\nChecks if this fieldset can bind data\n\n\n\n\n\n\nsetCount($count) : void\n\n\nDefines how many times the target element will be initially rendered by the \nZend\\Form\\View\\Helper\\FormCollection\n view helper.\n\n\n\n\n\n\ngetCount() : integer\n\n\nReturn the number of times the target element will be initially rendered by the \nZend\\Form\\View\\Helper\\FormCollection\n view helper.\n\n\n\n\n\n\nsetTargetElement($elementOrFieldset) : void\n\n\nThis function either takes an \nZend\\Form\\ElementInterface\n, \nZend\\Form\\FieldsetInterface\n instance or an array to pass to the form factory. When the Collection element will be validated, the input filter will be retrieved from this target element and be used to validate each element in the collection.\n\n\n\n\n\n\ngetTargetElement() : ElementInterface|null\n\n\nReturn the target element used by the collection.\n\n\n\n\n\n\nsetAllowAdd($allowAdd) : void\n\n\nIf allowAdd is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will also be validated and retrieved.\n\n\n\n\n\n\nallowAdd() : boolean\n\n\nReturn if new elements can be dynamically added in the collection.\n\n\n\n\n\n\nsetAllowRemove($allowRemove) : void\n\n\nIf allowRemove is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will be allowed to be removed.\n\n\n\n\n\n\nallowRemove() : boolean\n\n\nReturn if new elements can be dynamically removed from the collection.\n\n\n\n\n\n\nsetShouldCreateTemplate($shouldCreateTemplate) : void\n\n\nIf shouldCreateTemplate is set to \ntrue\n (defaults to \nfalse\n), a \n<span>\n element will be generated by the \nZend\\Form\\View\\Helper\\FormCollection\n view helper. This non-semantic \nspan\n element contains a single data-template HTML5 attribute whose value is the whole HTML to copy to create a new element in the form. The template is indexed using the \ntemplatePlaceholder\n value.\n\n\n\n\n\n\nshouldCreateTemplate() : boolean\n\n\nReturn if a template should be created.\n\n\n\n\n\n\nsetTemplatePlaceholder($templatePlaceholder) : void\n\n\nSet the template placeholder (defaults to \n__index__\n) used to index element in the template.\n\n\n\n\n\n\ngetTemplatePlaceholder() : string\n\n\nReturns the template placeholder used to index element in the template.\n\n\n\n\n\n\ngetTemplateElement() : null|ElementInterface|FieldsetInterface\n\n\nGet a template element used for rendering purposes only\n\n\n\n\n\n\nprepareElement : void\n\n\nPrepare the collection by adding a dummy template element if the user want one\n\n\n\n\n\n\nprepareFieldset() : void\n\n\nIf both count and targetElement are set, add them to the fieldset",
            "title": "Collection"
        },
        {
            "location": "/element/collection/#collection",
            "text": "Sometimes, you may want to add an input (or a set of inputs) multiple times,\neither because you don't want to duplicate code, or because you do not know in\nadvance how many elements you will need (in the case of elements dynamically\nadded to a form using Javascript, for instance). For more information about\ncollections, please refer to the  form Collections tutorial .  Zend\\Form\\Element\\Collection  is meant to be paired with the Zend\\Form\\View\\Helper\\FormCollection .",
            "title": "Collection"
        },
        {
            "location": "/element/collection/#basic-usage",
            "text": "use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$colors = new Element\\Collection('collection');\n$colors->setLabel('Colors');\n$colors->setCount(2);\n$colors->setTargetElement(new Element\\Color());\n$colors->setShouldCreateTemplate(true);\n\n$form = new Form('my-form');\n$form->add($colors);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Collection::class,\n    'options' => [\n        'label' => 'Colors',\n        'count' => 2,\n        'should_create_template' => true,\n        'target_element' => new Element\\Color()\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/collection/#public-methods",
            "text": "The following methods are specific to the  Collection  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      setOptions(array $options) : void  Set options for an element of type Collection. Accepted options, in addition to the options inherited from  Element , are:  target_element ,  count ,  allow_add ,  allow_remove ,  should_create_template  and  template_placeholder . Those option keys respectively call  setTargetElement() ,  setCount() ,  setAllowAdd() ,  setAllowRemove() ,  setShouldCreateTemplate()  and  setTemplatePlaceholder() .    allowObjectBinding(object $object) : bool  Checks if the object can be set in this fieldset.    setObject(array|Traversable $object) : void  Set the object used by the hydrator. In this case the \"object\" is a collection of objects.    populateValues(array|Traversable $data) : void  Populate values    allowValueBinding() : bool  Checks if this fieldset can bind data    setCount($count) : void  Defines how many times the target element will be initially rendered by the  Zend\\Form\\View\\Helper\\FormCollection  view helper.    getCount() : integer  Return the number of times the target element will be initially rendered by the  Zend\\Form\\View\\Helper\\FormCollection  view helper.    setTargetElement($elementOrFieldset) : void  This function either takes an  Zend\\Form\\ElementInterface ,  Zend\\Form\\FieldsetInterface  instance or an array to pass to the form factory. When the Collection element will be validated, the input filter will be retrieved from this target element and be used to validate each element in the collection.    getTargetElement() : ElementInterface|null  Return the target element used by the collection.    setAllowAdd($allowAdd) : void  If allowAdd is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will also be validated and retrieved.    allowAdd() : boolean  Return if new elements can be dynamically added in the collection.    setAllowRemove($allowRemove) : void  If allowRemove is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will be allowed to be removed.    allowRemove() : boolean  Return if new elements can be dynamically removed from the collection.    setShouldCreateTemplate($shouldCreateTemplate) : void  If shouldCreateTemplate is set to  true  (defaults to  false ), a  <span>  element will be generated by the  Zend\\Form\\View\\Helper\\FormCollection  view helper. This non-semantic  span  element contains a single data-template HTML5 attribute whose value is the whole HTML to copy to create a new element in the form. The template is indexed using the  templatePlaceholder  value.    shouldCreateTemplate() : boolean  Return if a template should be created.    setTemplatePlaceholder($templatePlaceholder) : void  Set the template placeholder (defaults to  __index__ ) used to index element in the template.    getTemplatePlaceholder() : string  Returns the template placeholder used to index element in the template.    getTemplateElement() : null|ElementInterface|FieldsetInterface  Get a template element used for rendering purposes only    prepareElement : void  Prepare the collection by adding a dummy template element if the user want one    prepareFieldset() : void  If both count and targetElement are set, add them to the fieldset",
            "title": "Public Methods"
        },
        {
            "location": "/element/color/",
            "text": "Color\n\n\nZend\\Form\\Element\\Color\n is meant to be paired with\n\nZend\\Form\\View\\Helper\\FormColor\n for \nHTML5 inputs with type \"color\"\n.\nThis element adds filters and a \nRegex\n validator to its input filter\nspecification in order to validate an \nHTML5 valid simple color\n\nvalue on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ncolor\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$color = new Element\\Color('color');\n$color->setLabel('Background color');\n\n$form = new Form('my-form');\n$form->add($color);\n\n\n\nThe following uses array notation instead:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Color::class,\n    'name' => 'color',\n    'options' => [\n        'label' => 'Background color',\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nColor\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Filter\\StringTrim\n and \nZend\\Filter\\StringToLower\n filters, and a \nZend\\Validator\\Regex\n to validate the RGB hex format.",
            "title": "color"
        },
        {
            "location": "/element/color/#color",
            "text": "Zend\\Form\\Element\\Color  is meant to be paired with Zend\\Form\\View\\Helper\\FormColor  for  HTML5 inputs with type \"color\" .\nThis element adds filters and a  Regex  validator to its input filter\nspecification in order to validate an  HTML5 valid simple color \nvalue on the server.",
            "title": "Color"
        },
        {
            "location": "/element/color/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  color .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$color = new Element\\Color('color');\n$color->setLabel('Background color');\n\n$form = new Form('my-form');\n$form->add($color);  The following uses array notation instead:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Color::class,\n    'name' => 'color',\n    'options' => [\n        'label' => 'Background color',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/color/#public-methods",
            "text": "The following methods are specific to the  Color  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Filter\\StringTrim  and  Zend\\Filter\\StringToLower  filters, and a  Zend\\Validator\\Regex  to validate the RGB hex format.",
            "title": "Public Methods"
        },
        {
            "location": "/element/csrf/",
            "text": "Csrf\n\n\nZend\\Form\\Element\\Csrf\n pairs with the \nFormHidden\n\nhelper to provide protection from CSRF attacks on forms, ensuring the data is\nsubmitted by the user session that generated the form and not by a rogue script.\nProtection is achieved by adding a hash element to a form and verifying it when\nthe form is submitted.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nhidden\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$csrf = new Element\\Csrf('csrf');\n\n$form = new Form('my-form');\n$form->add($csrf);\n\n\n\nYou can change the options of the CSRF validator using the\n\nsetCsrfValidatorOptions()\n function, or by using the \ncsrf_options\n key. Here\nis an example using array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Csrf::class,\n    'name' => 'csrf',\n    'options' => [\n        'csrf_options' => [\n            'timeout' => 600,\n        ],\n    ],\n]);\n\n\n\n\n\nMultiple CSRF elements must be uniquely named\n\n\nIf you are using more than one form on a page, and each contains its own CSRF\nelement, you will need to make sure that each form uniquely names its element;\nif you do not, it's possible for the value of one to override the other within\nthe server-side session storage, leading to the inability to validate one or\nmore of the forms on your page. We suggest prefixing the element name with the\nform's name or function: \nlogin_csrf\n, \nregistration_csrf\n, etc.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nCsrf\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes a \nZend\\Filter\\StringTrim\n filter and \nZend\\Validator\\Csrf\n to validate the CSRF value.\n\n\n\n\n\n\nsetCsrfValidatorOptions(array $options) : void\n\n\nSet the options that are used by the CSRF validator.\n\n\n\n\n\n\ngetCsrfValidatorOptions() : array\n\n\nGet the options that are used by the CSRF validator.\n\n\n\n\n\n\nsetCsrfValidator(Zend\\Validator\\Csrf $validator) : void\n\n\nOverride the default CSRF validator by setting another one.\n\n\n\n\n\n\ngetCsrfValidator() : Zend\\Validator\\Csrf\n\n\nGet the CSRF validator.",
            "title": "CSRF"
        },
        {
            "location": "/element/csrf/#csrf",
            "text": "Zend\\Form\\Element\\Csrf  pairs with the  FormHidden \nhelper to provide protection from CSRF attacks on forms, ensuring the data is\nsubmitted by the user session that generated the form and not by a rogue script.\nProtection is achieved by adding a hash element to a form and verifying it when\nthe form is submitted.",
            "title": "Csrf"
        },
        {
            "location": "/element/csrf/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  hidden .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$csrf = new Element\\Csrf('csrf');\n\n$form = new Form('my-form');\n$form->add($csrf);  You can change the options of the CSRF validator using the setCsrfValidatorOptions()  function, or by using the  csrf_options  key. Here\nis an example using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Csrf::class,\n    'name' => 'csrf',\n    'options' => [\n        'csrf_options' => [\n            'timeout' => 600,\n        ],\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/csrf/#multiple-csrf-elements-must-be-uniquely-named",
            "text": "If you are using more than one form on a page, and each contains its own CSRF\nelement, you will need to make sure that each form uniquely names its element;\nif you do not, it's possible for the value of one to override the other within\nthe server-side session storage, leading to the inability to validate one or\nmore of the forms on your page. We suggest prefixing the element name with the\nform's name or function:  login_csrf ,  registration_csrf , etc.",
            "title": "Multiple CSRF elements must be uniquely named"
        },
        {
            "location": "/element/csrf/#public-methods",
            "text": "The following methods are specific to the  Csrf  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes a  Zend\\Filter\\StringTrim  filter and  Zend\\Validator\\Csrf  to validate the CSRF value.    setCsrfValidatorOptions(array $options) : void  Set the options that are used by the CSRF validator.    getCsrfValidatorOptions() : array  Get the options that are used by the CSRF validator.    setCsrfValidator(Zend\\Validator\\Csrf $validator) : void  Override the default CSRF validator by setting another one.    getCsrfValidator() : Zend\\Validator\\Csrf  Get the CSRF validator.",
            "title": "Public Methods"
        },
        {
            "location": "/element/date/",
            "text": "Date\n\n\nZend\\Form\\Element\\Date\n is meant to be paired with the\n\nFormDate\n helper for\n\nHTML5 inputs with type \"date\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 date input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ndate\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$date = new Element\\Date('appointment-date');\n$date->setLabel('Appointment Date');\n$date->setAttributes([\n    'min'  => '2012-01-01',\n    'max'  => '2020-01-01',\n    'step' => '1', // days; default step interval is 1 day\n]);\n$date->setOptions([\n    'format' => 'Y-m-d',\n]);\n\n$form = new Form('my-form');\n$form->add($date);\n\n\n\nThe following uses array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Date::class,\n    'name' => 'appointment-date',\n    'options' => [\n        'label' => 'Appointment Date',\n        'format' => 'Y-m-d',\n    ],\n    'attributes' => [\n        'min' => '2012-01-01',\n        'max' => '2020-01-01',\n        'step' => '1', // days; default step interval is 1 day\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nDate\n element; all other methods\ninherited from the \nparent \nDateTime\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes and \nformat\n option. See the \nDateTime::getInputSpecification()\n definition for more information. One difference from \nZend\\Form\\Element\\DateTime\n is that the \nZend\\Validator\\DateStep\n validator will expect the \nstep\n attribute to use an interval of days (default is 1 day).",
            "title": "date"
        },
        {
            "location": "/element/date/#date",
            "text": "Zend\\Form\\Element\\Date  is meant to be paired with the FormDate  helper for HTML5 inputs with type \"date\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 date input values on the server.",
            "title": "Date"
        },
        {
            "location": "/element/date/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  date .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$date = new Element\\Date('appointment-date');\n$date->setLabel('Appointment Date');\n$date->setAttributes([\n    'min'  => '2012-01-01',\n    'max'  => '2020-01-01',\n    'step' => '1', // days; default step interval is 1 day\n]);\n$date->setOptions([\n    'format' => 'Y-m-d',\n]);\n\n$form = new Form('my-form');\n$form->add($date);  The following uses array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Date::class,\n    'name' => 'appointment-date',\n    'options' => [\n        'label' => 'Appointment Date',\n        'format' => 'Y-m-d',\n    ],\n    'attributes' => [\n        'min' => '2012-01-01',\n        'max' => '2020-01-01',\n        'step' => '1', // days; default step interval is 1 day\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/date/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/date/#public-methods",
            "text": "The following methods are specific to the  Date  element; all other methods\ninherited from the  parent  DateTime  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes and  format  option. See the  DateTime::getInputSpecification()  definition for more information. One difference from  Zend\\Form\\Element\\DateTime  is that the  Zend\\Validator\\DateStep  validator will expect the  step  attribute to use an interval of days (default is 1 day).",
            "title": "Public Methods"
        },
        {
            "location": "/element/date-time/",
            "text": "DateTime\n\n\nZend\\Form\\Element\\DateTime\n is meant to be paired with the\n\nFormDateTime\n helper for\n\nHTML5 inputs with type \"datetime\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 datetime input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ndatetime\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$dateTime = new Element\\DateTime('appointment-date-time');\n$dateTime->setLabel('Appointment Date/Time');\n$dateTime->setAttributes([\n    'min'  => '2010-01-01T00:00:00Z',\n    'max'  => '2020-01-01T00:00:00Z',\n    'step' => '1', // minutes; default step interval is 1 min\n]);\n$dateTime->setOptions([\n    'format' => 'Y-m-d\\TH:iP'\n]);\n\n$form = new Form('my-form');\n$form->add($dateTime);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\DateTime::class,\n    'name' => 'appointment-date-time',\n    'options' => [\n        'label' => 'Appointment Date/Time',\n        'format' => 'Y-m-d\\TH:iP',\n    ],\n    'attributes' => [\n        'min' => '2010-01-01T00:00:00Z',\n        'max' => '2020-01-01T00:00:00Z',\n        'step' => '1', // minutes; default step interval is 1 min\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nDateTime\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nSee write-up below.\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element of type \nDateTime\n. The accepted option, in addition to the inherited options of \nZend\\Form\\Element\n is \nformat\n, which calls \nsetFormat()\n.\n\n\n\n\n\n\nsetFormat(string $format) : void\n\n\nSets the format used to validate the value. Accepts a PHP \nDateTime\n compatible string.\n\n\n\n\n\n\ngetFormat() : string\n\n\nReturn the PHP \nDateTime\n format used to validate the value.\n\n\n\n\n\n\n\n\ngetInputSpecification()\n returns an input filter specification, which includes\nthe \nStringTrim\n filter, and appropriate validators based on the values from the\n\nmin\n, \nmax\n, and \nstep\n attributes, as well as the \nformat\n option, per the\nfollowing:\n\n\n\n\nIf the \nmin\n attribute is set, a \nZend\\Validator\\GreaterThan\n validator will\n  be added to ensure the date value is greater than the minimum value.\n\n\nIf the \nmax\n attribute is set, a \nZend\\Validator\\LessThanValidator\n validator\n  will be added to ensure the date value is less than the maximum value.\n\n\nIf the \nstep\n attribute is set to \"any\", step validations will be skipped.\n  Otherwise, a \nZend\\Validator\\DateStep\n validator will be added to ensure the\n  date value is within a certain interval of minutes (default is 1 minute).\n\n\nThe input filter specification also includes a \nZend\\Validator\\Date\n validator\n  to ensure the format of the value. If the \nformat\n option is set, that format\n  will be used. Otherwise the default format will be used.",
            "title": "datetime"
        },
        {
            "location": "/element/date-time/#datetime",
            "text": "Zend\\Form\\Element\\DateTime  is meant to be paired with the FormDateTime  helper for HTML5 inputs with type \"datetime\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 datetime input values on the server.",
            "title": "DateTime"
        },
        {
            "location": "/element/date-time/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  datetime .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$dateTime = new Element\\DateTime('appointment-date-time');\n$dateTime->setLabel('Appointment Date/Time');\n$dateTime->setAttributes([\n    'min'  => '2010-01-01T00:00:00Z',\n    'max'  => '2020-01-01T00:00:00Z',\n    'step' => '1', // minutes; default step interval is 1 min\n]);\n$dateTime->setOptions([\n    'format' => 'Y-m-d\\TH:iP'\n]);\n\n$form = new Form('my-form');\n$form->add($dateTime);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\DateTime::class,\n    'name' => 'appointment-date-time',\n    'options' => [\n        'label' => 'Appointment Date/Time',\n        'format' => 'Y-m-d\\TH:iP',\n    ],\n    'attributes' => [\n        'min' => '2010-01-01T00:00:00Z',\n        'max' => '2020-01-01T00:00:00Z',\n        'step' => '1', // minutes; default step interval is 1 min\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/date-time/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/date-time/#public-methods",
            "text": "The following methods are specific to the  DateTime  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  See write-up below.    setOptions(array $options) : void  Set options for an element of type  DateTime . The accepted option, in addition to the inherited options of  Zend\\Form\\Element  is  format , which calls  setFormat() .    setFormat(string $format) : void  Sets the format used to validate the value. Accepts a PHP  DateTime  compatible string.    getFormat() : string  Return the PHP  DateTime  format used to validate the value.     getInputSpecification()  returns an input filter specification, which includes\nthe  StringTrim  filter, and appropriate validators based on the values from the min ,  max , and  step  attributes, as well as the  format  option, per the\nfollowing:   If the  min  attribute is set, a  Zend\\Validator\\GreaterThan  validator will\n  be added to ensure the date value is greater than the minimum value.  If the  max  attribute is set, a  Zend\\Validator\\LessThanValidator  validator\n  will be added to ensure the date value is less than the maximum value.  If the  step  attribute is set to \"any\", step validations will be skipped.\n  Otherwise, a  Zend\\Validator\\DateStep  validator will be added to ensure the\n  date value is within a certain interval of minutes (default is 1 minute).  The input filter specification also includes a  Zend\\Validator\\Date  validator\n  to ensure the format of the value. If the  format  option is set, that format\n  will be used. Otherwise the default format will be used.",
            "title": "Public Methods"
        },
        {
            "location": "/element/date-time-local/",
            "text": "DateTimeLocal\n\n\nZend\\Form\\Element\\DateTimeLocal\n is meant to be paired with the\n\nFormDateTimeLocal\n helper for\n\nHTML5 inputs with type \"datetime-local\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate a local datetime input value on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ndatetime-local\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$dateTimeLocal = new Element\\DateTimeLocal('appointment-date-time');\n$dateTimeLocal->setLabel('Appointment Date');\n$dateTimeLocal->setAttributes([\n    'min'  => '2010-01-01T00:00:00',\n    'max'  => '2020-01-01T00:00:00',\n    'step' => '1', // minutes; default step interval is 1 min\n]);\n$dateTimeLocal->setOptions([\n    'format' => 'Y-m-d\\TH:i',\n]);\n\n$form = new Form('my-form');\n$form->add($dateTimeLocal);\n\n\n\nHere is with the array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\DateTimeLocal::class,\n    'name' => 'appointment-date-time',\n    'options' => [\n        'label'  => 'Appointment Date',\n        'format' => 'Y-m-d\\TH:i'\n    ],\n    'attributes' => [\n        'min' => '2010-01-01T00:00:00',\n        'max' => '2020-01-01T00:00:00',\n        'step' => '1', // minutes; default step interval is 1 min\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nDateTimeLocal\n element; all other methods\ninherited from the \nparent \nDateTime\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes and \nformat\n option. See the \nDateTime::getInputSpecification()\n definition for more information.",
            "title": "datetime-local"
        },
        {
            "location": "/element/date-time-local/#datetimelocal",
            "text": "Zend\\Form\\Element\\DateTimeLocal  is meant to be paired with the FormDateTimeLocal  helper for HTML5 inputs with type \"datetime-local\" .\nThis element adds filters and validators to its input filter specification in\norder to validate a local datetime input value on the server.",
            "title": "DateTimeLocal"
        },
        {
            "location": "/element/date-time-local/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  datetime-local .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$dateTimeLocal = new Element\\DateTimeLocal('appointment-date-time');\n$dateTimeLocal->setLabel('Appointment Date');\n$dateTimeLocal->setAttributes([\n    'min'  => '2010-01-01T00:00:00',\n    'max'  => '2020-01-01T00:00:00',\n    'step' => '1', // minutes; default step interval is 1 min\n]);\n$dateTimeLocal->setOptions([\n    'format' => 'Y-m-d\\TH:i',\n]);\n\n$form = new Form('my-form');\n$form->add($dateTimeLocal);  Here is with the array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\DateTimeLocal::class,\n    'name' => 'appointment-date-time',\n    'options' => [\n        'label'  => 'Appointment Date',\n        'format' => 'Y-m-d\\TH:i'\n    ],\n    'attributes' => [\n        'min' => '2010-01-01T00:00:00',\n        'max' => '2020-01-01T00:00:00',\n        'step' => '1', // minutes; default step interval is 1 min\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/date-time-local/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/date-time-local/#public-methods",
            "text": "The following methods are specific to the  DateTimeLocal  element; all other methods\ninherited from the  parent  DateTime  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes and  format  option. See the  DateTime::getInputSpecification()  definition for more information.",
            "title": "Public Methods"
        },
        {
            "location": "/element/email/",
            "text": "Email\n\n\nZend\\Form\\Element\\Email\n is meant to be paired with the\n\nFormEmail\n helper for\n\nHTML5 inputs with type \"email\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate \nHTML5 valid email address\n\non the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nemail\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n\n// Single email address:\n$email = new Element\\Email('email');\n$email->setLabel('Email Address')\n$form->add($email);\n\n// Comma separated list of emails:\n$emails = new Element\\Email('emails');\n$emails->setLabel('Email Addresses');\n$emails->setAttribute('multiple', true);\n$form->add($emails);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n\n// Single email address:\n$form->add([\n    'type' => Element\\Email::class,\n    'name' => 'email',\n    'options' => [\n        'label' => 'Email Address',\n    ],\n]);\n\n// Comma separated list of emails:\n$form->add([\n    'type' => Element\\Email::class,\n    'name' => 'emails',\n    'options' => [\n        'label' => 'Email Addresses',\n    ],\n    'attributes' => [\n        'multiple' => true,\n    ],\n]);\n\n\n\n\n\nSet multiple attribute before calling prepare\n\n\nNote: the \nmultiple\n attribute should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nEmail\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nSee description below.\n\n\n\n\n\n\nsetValidator(ValidatorInterface $validator) : void\n\n\nSets the primary validator to use for this element.\n\n\n\n\n\n\ngetValidator() : ValidatorInterface\n\n\nGet the primary validator.\n\n\n\n\n\n\nsetEmailValidator(ValidatorInterface $validator) : void\n\n\nSets the email validator to use for multiple or single email addresses.\n\n\n\n\n\n\ngetEmailValidator() : void\n\n\nGet the email validator to use for multiple or single email addresses. The default \nRegex\n validator in use is to match that of the browser validation, but you are free to set a different (more strict) email validator such as \nZend\\Validator\\Email\n if you wish.\n\n\n\n\n\n\n\n\ngetInputSpecification()\n returns an input filter specification, which includes\na \nZend\\Filter\\StringTrim\n filter, and a validator based on the \nmultiple\n\nattribute:\n\n\n\n\nIf the \nmultiple\n attribute is unset or \nfalse\n, a \nZend\\Validator\\Regex\n\n  validator will be added to validate a single email address.\n\n\nIf the \nmultiple\n attribute is \ntrue\n, a \nZend\\Validator\\Explode\n validator\n  will be added to ensure the input string value is split by commas before\n  validating each email address with \nZend\\Validator\\Regex\n.",
            "title": "email"
        },
        {
            "location": "/element/email/#email",
            "text": "Zend\\Form\\Element\\Email  is meant to be paired with the FormEmail  helper for HTML5 inputs with type \"email\" .\nThis element adds filters and validators to its input filter specification in\norder to validate  HTML5 valid email address \non the server.",
            "title": "Email"
        },
        {
            "location": "/element/email/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  email .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n\n// Single email address:\n$email = new Element\\Email('email');\n$email->setLabel('Email Address')\n$form->add($email);\n\n// Comma separated list of emails:\n$emails = new Element\\Email('emails');\n$emails->setLabel('Email Addresses');\n$emails->setAttribute('multiple', true);\n$form->add($emails);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n\n// Single email address:\n$form->add([\n    'type' => Element\\Email::class,\n    'name' => 'email',\n    'options' => [\n        'label' => 'Email Address',\n    ],\n]);\n\n// Comma separated list of emails:\n$form->add([\n    'type' => Element\\Email::class,\n    'name' => 'emails',\n    'options' => [\n        'label' => 'Email Addresses',\n    ],\n    'attributes' => [\n        'multiple' => true,\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/email/#set-multiple-attribute-before-calling-prepare",
            "text": "Note: the  multiple  attribute should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set multiple attribute before calling prepare"
        },
        {
            "location": "/element/email/#public-methods",
            "text": "The following methods are specific to the  Email  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  See description below.    setValidator(ValidatorInterface $validator) : void  Sets the primary validator to use for this element.    getValidator() : ValidatorInterface  Get the primary validator.    setEmailValidator(ValidatorInterface $validator) : void  Sets the email validator to use for multiple or single email addresses.    getEmailValidator() : void  Get the email validator to use for multiple or single email addresses. The default  Regex  validator in use is to match that of the browser validation, but you are free to set a different (more strict) email validator such as  Zend\\Validator\\Email  if you wish.     getInputSpecification()  returns an input filter specification, which includes\na  Zend\\Filter\\StringTrim  filter, and a validator based on the  multiple \nattribute:   If the  multiple  attribute is unset or  false , a  Zend\\Validator\\Regex \n  validator will be added to validate a single email address.  If the  multiple  attribute is  true , a  Zend\\Validator\\Explode  validator\n  will be added to ensure the input string value is split by commas before\n  validating each email address with  Zend\\Validator\\Regex .",
            "title": "Public Methods"
        },
        {
            "location": "/element/file/",
            "text": "File\n\n\nZend\\Form\\Element\\File\n represents a form file input and\nprovides a default input specification with a type of\n\nFileInput\n\n(important for handling validators and filters correctly).\nIt is intended for use with the \nFormFile\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nfile\n.  It will\nalso set the form's \nenctype\n to \nmultipart/form-data\n during\n\n$form->prepare()\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n// Single file upload:\n$file = new Element\\File('file');\n$file->setLabel('Single file input');\n\n// HTML5 multiple file upload:\n$multiFile = new Element\\File('multi-file');\n$multiFile->setLabel('Multi file input');\n$multiFile->setAttribute('multiple', true);\n\n$form = new Form('my-file');\n$form->add($file);\n$form->add($multiFile);",
            "title": "file"
        },
        {
            "location": "/element/file/#file",
            "text": "Zend\\Form\\Element\\File  represents a form file input and\nprovides a default input specification with a type of FileInput \n(important for handling validators and filters correctly).\nIt is intended for use with the  FormFile  view helper.",
            "title": "File"
        },
        {
            "location": "/element/file/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  file .  It will\nalso set the form's  enctype  to  multipart/form-data  during $form->prepare() .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n// Single file upload:\n$file = new Element\\File('file');\n$file->setLabel('Single file input');\n\n// HTML5 multiple file upload:\n$multiFile = new Element\\File('multi-file');\n$multiFile->setLabel('Multi file input');\n$multiFile->setAttribute('multiple', true);\n\n$form = new Form('my-file');\n$form->add($file);\n$form->add($multiFile);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/hidden/",
            "text": "Hidden\n\n\nZend\\Form\\Element\\Hidden\n represents a hidden form input.\nIt can be used with the \nFormHidden\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nhidden\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$hidden = new Element\\Hidden('my-hidden');\n$hidden->setValue('foo');\n\n$form = new Form('my-form');\n$form->add($hidden);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Hidden::class,\n    'name' => 'my-hidden',\n    'attributes' => [\n        'value' => 'foo',\n    ],\n]);",
            "title": "hidden"
        },
        {
            "location": "/element/hidden/#hidden",
            "text": "Zend\\Form\\Element\\Hidden  represents a hidden form input.\nIt can be used with the  FormHidden  view helper.",
            "title": "Hidden"
        },
        {
            "location": "/element/hidden/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  hidden .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$hidden = new Element\\Hidden('my-hidden');\n$hidden->setValue('foo');\n\n$form = new Form('my-form');\n$form->add($hidden);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Hidden::class,\n    'name' => 'my-hidden',\n    'attributes' => [\n        'value' => 'foo',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/image/",
            "text": "Image\n\n\nZend\\Form\\Element\\Image\n represents a image button form input.\nIt can be used with the \nFormImage\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nimage\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$image = new Element\\Image('my-image');\n$image->setAttribute('src', 'http://my.image.url'); // Src attribute is required\n\n$form = new Form('my-form');\n$form->add($image);",
            "title": "image"
        },
        {
            "location": "/element/image/#image",
            "text": "Zend\\Form\\Element\\Image  represents a image button form input.\nIt can be used with the  FormImage  view helper.",
            "title": "Image"
        },
        {
            "location": "/element/image/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  image .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$image = new Element\\Image('my-image');\n$image->setAttribute('src', 'http://my.image.url'); // Src attribute is required\n\n$form = new Form('my-form');\n$form->add($image);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/month/",
            "text": "Month\n\n\nZend\\Form\\Element\\Month\n is meant to be paired with the\n\nFormMonth\n helper for\n\nHTML5 inputs with type \"month\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 month input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nmonth\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$month = new Element\\Month('month');\n$month->setLabel('Month');\n$month->setAttributes([\n    'min'  => '2012-01',\n    'max'  => '2020-01',\n    'step' => '1', // months; default step interval is 1 month\n]);\n\n$form = new Form('my-form');\n$form->add($month);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Month::class,\n    'name' => 'month',\n    'options' => [\n        'label' => 'Month',\n    ],\n    'attributes' => [\n        'min' => '2012-12',\n        'max' => '2020-01',\n        'step' => '1', // months; default step interval is 1 month\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nMonth\n element; all other methods\ninherited from the \nparent \nDateTime\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Filter\\StringTrim\n, and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes. See the \nDateTime element documentation\n for more information.  One difference from \nZend\\Form\\Element\\DateTime\n is that the \nZend\\Validator\\DateStep\n validator will expect the \nstep\n attribute to use an interval of months (default is 1 month).",
            "title": "month"
        },
        {
            "location": "/element/month/#month",
            "text": "Zend\\Form\\Element\\Month  is meant to be paired with the FormMonth  helper for HTML5 inputs with type \"month\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 month input values on the server.",
            "title": "Month"
        },
        {
            "location": "/element/month/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  month .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$month = new Element\\Month('month');\n$month->setLabel('Month');\n$month->setAttributes([\n    'min'  => '2012-01',\n    'max'  => '2020-01',\n    'step' => '1', // months; default step interval is 1 month\n]);\n\n$form = new Form('my-form');\n$form->add($month);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Month::class,\n    'name' => 'month',\n    'options' => [\n        'label' => 'Month',\n    ],\n    'attributes' => [\n        'min' => '2012-12',\n        'max' => '2020-01',\n        'step' => '1', // months; default step interval is 1 month\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/month/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/month/#public-methods",
            "text": "The following methods are specific to the  Month  element; all other methods\ninherited from the  parent  DateTime  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Filter\\StringTrim , and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes. See the  DateTime element documentation  for more information.  One difference from  Zend\\Form\\Element\\DateTime  is that the  Zend\\Validator\\DateStep  validator will expect the  step  attribute to use an interval of months (default is 1 month).",
            "title": "Public Methods"
        },
        {
            "location": "/element/month-select/",
            "text": "Month Select\n\n\nZend\\Form\\Element\\MonthSelect\n is meant to be paired with\n\nFormMonthSelect\n view helper.  This element\ncreates two select elements, where the first one is populated with months and\nthe second is populated with years. By default, it sets 100 years in the past\nfor the year element, starting with the current year.\n\n\nBasic Usage\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$monthYear = new Element\\MonthSelect('monthyear');\n$monthYear->setLabel('Select a month and a year');\n$monthYear->setMinYear(1986);\n\n$form = new Form('dateselect');\n$form->add($monthYear);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('dateselect');\n$form->add([\n    'type' => Element\\MonthSelect::class,\n    'name' => 'monthyear',\n    'options' => [\n        'label' => 'Select a month and a year',\n        'min_year' => 1986,\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nMonthSelect\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetMonthElement() : Zend\\Form\\Element\\Select\n\n\nReturns the \nSelect\n element that is used for the months part.\n\n\n\n\n\n\ngetYearElement() : Zend\\Form\\Element\\Select\n\n\nReturns the \nSelect\n element that is used for the years part.\n\n\n\n\n\n\nsetMonthAttributes(array $monthAttributes) : void\n\n\nSet attributes on the \nSelect\n element that is used for the months part.\n\n\n\n\n\n\ngetMonthAttributes() : array\n\n\nGet attributes on the \nSelect\n element that is used for the months part.\n\n\n\n\n\n\nsetYearAttributes(array $yearAttributes) : void\n\n\nSet attributes on the \nSelect\n element that is used for the years part.\n\n\n\n\n\n\ngetYearAttributes() : array\n\n\nGet attributes on the \nSelect\n element that is used for the years part.\n\n\n\n\n\n\nsetMinYear(int $minYear) : void\n\n\nSet the minimum year.\n\n\n\n\n\n\ngetMinYear() : int\n\n\nGet the minimum year.\n\n\n\n\n\n\nsetMaxYear(int $maxYear) : void\n\n\nSet the maximum year.\n\n\n\n\n\n\ngetMaxYear() : int\n\n\nGet the maximum year.\n\n\n\n\n\n\nsetValue(mixed $value) : void\n\n\nSet the value for the \nMonthSelect\n element. If the value is an instance of PHP's \nDateTime\n, it will use the month and year values from that date. Otherwise, the value should be an associative array with the \nmonth\n key for the month value, and with the \nyear\n key for the year value.",
            "title": "MonthSelect"
        },
        {
            "location": "/element/month-select/#month-select",
            "text": "Zend\\Form\\Element\\MonthSelect  is meant to be paired with FormMonthSelect  view helper.  This element\ncreates two select elements, where the first one is populated with months and\nthe second is populated with years. By default, it sets 100 years in the past\nfor the year element, starting with the current year.",
            "title": "Month Select"
        },
        {
            "location": "/element/month-select/#basic-usage",
            "text": "use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$monthYear = new Element\\MonthSelect('monthyear');\n$monthYear->setLabel('Select a month and a year');\n$monthYear->setMinYear(1986);\n\n$form = new Form('dateselect');\n$form->add($monthYear);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('dateselect');\n$form->add([\n    'type' => Element\\MonthSelect::class,\n    'name' => 'monthyear',\n    'options' => [\n        'label' => 'Select a month and a year',\n        'min_year' => 1986,\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/month-select/#public-methods",
            "text": "The following methods are specific to the  MonthSelect  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getMonthElement() : Zend\\Form\\Element\\Select  Returns the  Select  element that is used for the months part.    getYearElement() : Zend\\Form\\Element\\Select  Returns the  Select  element that is used for the years part.    setMonthAttributes(array $monthAttributes) : void  Set attributes on the  Select  element that is used for the months part.    getMonthAttributes() : array  Get attributes on the  Select  element that is used for the months part.    setYearAttributes(array $yearAttributes) : void  Set attributes on the  Select  element that is used for the years part.    getYearAttributes() : array  Get attributes on the  Select  element that is used for the years part.    setMinYear(int $minYear) : void  Set the minimum year.    getMinYear() : int  Get the minimum year.    setMaxYear(int $maxYear) : void  Set the maximum year.    getMaxYear() : int  Get the maximum year.    setValue(mixed $value) : void  Set the value for the  MonthSelect  element. If the value is an instance of PHP's  DateTime , it will use the month and year values from that date. Otherwise, the value should be an associative array with the  month  key for the month value, and with the  year  key for the year value.",
            "title": "Public Methods"
        },
        {
            "location": "/element/multi-checkbox/",
            "text": "MultiCheckbox\n\n\nZend\\Form\\Element\\MultiCheckbox\n is meant to be paired with the\n\nFormMultiCheckbox\n for HTML inputs with type\n\"checkbox\".  This element adds an \nInArray\n validator to its input filter\nspecification in order to validate on the server if the checkbox contains values\nfrom the multiple checkboxes.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ncheckbox\n for every\ncheckboxes.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$multiCheckbox = new Element\\MultiCheckbox('multi-checkbox');\n$multiCheckbox->setLabel('What do you like ?');\n$multiCheckbox->setValueOptions([\n        '0' => 'Apple',\n        '1' => 'Orange',\n        '2' => 'Lemon'\n]);\n\n$form = new Form('my-form');\n$form->add($multiCheckbox);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\MultiCheckbox::class,\n    'name' => 'multi-checkbox',\n    'options' => [\n        'label' => 'What do you like ?',\n        'value_options' => [\n            '0' => 'Apple',\n            '1' => 'Orange',\n            '2' => 'Lemon',\n        ],\n    ],\n]);\n\n\n\nAdvanced Usage\n\n\nIn order to set attributes or customize the option elements, an array can be\nused instead of a string. The following keys are supported:\n\n\n\n\nlabel\n: The string displayed for the option.\n\n\nvalue\n: The form value associated with the option.\n\n\nselected\n: Boolean that sets whether the option is marked as selected.\n\n\ndisabled\n: Boolean that sets whether the option will be disabled\n\n\nattributes\n: Array of HTML attributes that will be set on this option. Merged\n  with the attributes set on the element.\n\n\nlabel_attributes\n: Array of HTML attributes that will be set on the label.\n  Merged with the attributes set on the element's label.\n\n\n\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\MultiCheckbox::class,\n    'name' => 'multi-checkbox',\n    'options' => [\n        'label' => 'What do you like ?',\n        'value_options' => [\n            [\n                'value' => '0',\n                'label' => 'Apple',\n                'selected' => false,\n                'disabled' => false,\n                'attributes' => [\n                    'id' => 'apple_option',\n                    'data-fruit' => 'apple',\n                ],\n                'label_attributes' => [\n                    'id' => 'apple_label',\n                ],\n            ],\n            [\n                'value' => '1',\n                'label' => 'Orange',\n                'selected' => true,\n            ],\n            [\n                'value' => '2',\n                'label' => 'Lemon',\n            ],\n        ],\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nMultiCheckbox\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element of type Checkbox. In addition to the options inherited from \nCheckbox\n allows \nvalue_options\n, which calls \nsetValueOptions()\n.\n\n\n\n\n\n\nsetValueOptions(array $options) : void\n\n\nSet the value options for every checkbox of the multi-checkbox. The array must contain a key/value pair for every checkbox.\n\n\n\n\n\n\ngetValueOptions() : array\n\n\nReturn the value options.\n\n\n\n\n\n\nunsetValueOption($key) : void\n\n\nUnset the value option from the multi-checkbox.",
            "title": "MultiCheckbox"
        },
        {
            "location": "/element/multi-checkbox/#multicheckbox",
            "text": "Zend\\Form\\Element\\MultiCheckbox  is meant to be paired with the FormMultiCheckbox  for HTML inputs with type\n\"checkbox\".  This element adds an  InArray  validator to its input filter\nspecification in order to validate on the server if the checkbox contains values\nfrom the multiple checkboxes.",
            "title": "MultiCheckbox"
        },
        {
            "location": "/element/multi-checkbox/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  checkbox  for every\ncheckboxes.  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$multiCheckbox = new Element\\MultiCheckbox('multi-checkbox');\n$multiCheckbox->setLabel('What do you like ?');\n$multiCheckbox->setValueOptions([\n        '0' => 'Apple',\n        '1' => 'Orange',\n        '2' => 'Lemon'\n]);\n\n$form = new Form('my-form');\n$form->add($multiCheckbox);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\MultiCheckbox::class,\n    'name' => 'multi-checkbox',\n    'options' => [\n        'label' => 'What do you like ?',\n        'value_options' => [\n            '0' => 'Apple',\n            '1' => 'Orange',\n            '2' => 'Lemon',\n        ],\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/multi-checkbox/#advanced-usage",
            "text": "In order to set attributes or customize the option elements, an array can be\nused instead of a string. The following keys are supported:   label : The string displayed for the option.  value : The form value associated with the option.  selected : Boolean that sets whether the option is marked as selected.  disabled : Boolean that sets whether the option will be disabled  attributes : Array of HTML attributes that will be set on this option. Merged\n  with the attributes set on the element.  label_attributes : Array of HTML attributes that will be set on the label.\n  Merged with the attributes set on the element's label.   $form = new Form('my-form');\n$form->add([\n    'type' => Element\\MultiCheckbox::class,\n    'name' => 'multi-checkbox',\n    'options' => [\n        'label' => 'What do you like ?',\n        'value_options' => [\n            [\n                'value' => '0',\n                'label' => 'Apple',\n                'selected' => false,\n                'disabled' => false,\n                'attributes' => [\n                    'id' => 'apple_option',\n                    'data-fruit' => 'apple',\n                ],\n                'label_attributes' => [\n                    'id' => 'apple_label',\n                ],\n            ],\n            [\n                'value' => '1',\n                'label' => 'Orange',\n                'selected' => true,\n            ],\n            [\n                'value' => '2',\n                'label' => 'Lemon',\n            ],\n        ],\n    ],\n]);",
            "title": "Advanced Usage"
        },
        {
            "location": "/element/multi-checkbox/#public-methods",
            "text": "The following methods are specific to the  MultiCheckbox  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      setOptions(array $options) : void  Set options for an element of type Checkbox. In addition to the options inherited from  Checkbox  allows  value_options , which calls  setValueOptions() .    setValueOptions(array $options) : void  Set the value options for every checkbox of the multi-checkbox. The array must contain a key/value pair for every checkbox.    getValueOptions() : array  Return the value options.    unsetValueOption($key) : void  Unset the value option from the multi-checkbox.",
            "title": "Public Methods"
        },
        {
            "location": "/element/number/",
            "text": "Number\n\n\nZend\\Form\\Element\\Number\n is meant to be paired with the\n\nFormNumber\n helper for\n\nHTML5 inputs with type \"number\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 number input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nnumber\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$number = new Element\\Number('quantity');\n$number->setLabel('Quantity');\n$number->setAttributes([\n    'min'  => '0',\n    'max'  => '10',\n    'step' => '1', // default step interval is 1\n]);\n\n$form = new Form('my-form');\n$form->add($number);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Number::class,\n    'name' => 'quantity',\n    'options' => [\n        'label' => 'Quantity',\n    ],\n    'attributes' => [\n        'min' => '0',\n        'max' => '10',\n        'step' => '1', // default step interval is 1\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nNumber\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes. See below for specifics.\n\n\n\n\n\n\n\n\ngetInputSpecification()\n will behave as follows based on the attributes\nprovided:\n\n\n\n\nIf the \nmin\n attribute is set, a \nZend\\Validator\\GreaterThan\n validator will\n  be added to ensure the number value is greater than the minimum value. The\n  \nmin\n value should be a \nvalid floating point number\n.\n\n\nIf the \nmax\n attribute is set, a \nZend\\Validator\\LessThan\n validator will be\n  added to ensure the number value is less than the maximum value. The \nmax\n\n  value should be a \nvalid floating point number\n.\n\n\nIf the \nstep\n attribute is set to \"any\", step validations will be skipped.\n  Otherwise, a \nZend\\Validator\\Step\n validator will be added to ensure the\n  number value is within a certain interval (default is 1). The \nstep\n value\n  should be either \"any\" or a \nvalid floating point number\n.",
            "title": "number"
        },
        {
            "location": "/element/number/#number",
            "text": "Zend\\Form\\Element\\Number  is meant to be paired with the FormNumber  helper for HTML5 inputs with type \"number\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 number input values on the server.",
            "title": "Number"
        },
        {
            "location": "/element/number/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  number .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$number = new Element\\Number('quantity');\n$number->setLabel('Quantity');\n$number->setAttributes([\n    'min'  => '0',\n    'max'  => '10',\n    'step' => '1', // default step interval is 1\n]);\n\n$form = new Form('my-form');\n$form->add($number);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Number::class,\n    'name' => 'quantity',\n    'options' => [\n        'label' => 'Quantity',\n    ],\n    'attributes' => [\n        'min' => '0',\n        'max' => '10',\n        'step' => '1', // default step interval is 1\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/number/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/number/#public-methods",
            "text": "The following methods are specific to the  Number  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns a input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes. See below for specifics.     getInputSpecification()  will behave as follows based on the attributes\nprovided:   If the  min  attribute is set, a  Zend\\Validator\\GreaterThan  validator will\n  be added to ensure the number value is greater than the minimum value. The\n   min  value should be a  valid floating point number .  If the  max  attribute is set, a  Zend\\Validator\\LessThan  validator will be\n  added to ensure the number value is less than the maximum value. The  max \n  value should be a  valid floating point number .  If the  step  attribute is set to \"any\", step validations will be skipped.\n  Otherwise, a  Zend\\Validator\\Step  validator will be added to ensure the\n  number value is within a certain interval (default is 1). The  step  value\n  should be either \"any\" or a  valid floating point number .",
            "title": "Public Methods"
        },
        {
            "location": "/element/password/",
            "text": "Password\n\n\nZend\\Form\\Element\\Password\n represents a password form input.\nIt can be used with the \nFormPassword\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \npassword\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$password = new Element\\Password('my-password');\n$password->setLabel('Enter your password');\n\n$form = new Form('my-form');\n$form->add($password);",
            "title": "password"
        },
        {
            "location": "/element/password/#password",
            "text": "Zend\\Form\\Element\\Password  represents a password form input.\nIt can be used with the  FormPassword  view helper.",
            "title": "Password"
        },
        {
            "location": "/element/password/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  password .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$password = new Element\\Password('my-password');\n$password->setLabel('Enter your password');\n\n$form = new Form('my-form');\n$form->add($password);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/radio/",
            "text": "Radio\n\n\nZend\\Form\\Element\\Radio\n is meant to be paired with the\n\nFormRadio\n helper for HTML inputs with type \"radio\".\nThis element adds an \nInArray\n validator to its input filter specification in\norder to validate on the server if the value is contains within the radio value\nelements.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nradio\n for every\nradio.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$radio = new Element\\Radio('likes_chocolate');\n$radio->setLabel('Do you like chocolate?');\n$radio->setValueOptions([\n    '0' => 'No',\n    '1' => 'Yes',\n]);\n\n$form = new Form('my-form');\n$form->add($radio);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Radio::class,\n    'name' => 'likes_chocolate',\n    'options' => [\n        'label' => 'Do you like chocolate?',\n        'value_options' => [\n            '0' => 'No',\n            '1' => 'Yes',\n        ],\n    ],\n]);\n\n\n\nAdvanced Usage\n\n\nSee \nMultiCheckbox for examples\n of how to apply attributes\nand options to each radio button.\n\n\nPublic Methods\n\n\nThe \nRadio\n element extends the \nMultiCheckbox\n element, and inherits\n\nits methods\n.",
            "title": "radio"
        },
        {
            "location": "/element/radio/#radio",
            "text": "Zend\\Form\\Element\\Radio  is meant to be paired with the FormRadio  helper for HTML inputs with type \"radio\".\nThis element adds an  InArray  validator to its input filter specification in\norder to validate on the server if the value is contains within the radio value\nelements.",
            "title": "Radio"
        },
        {
            "location": "/element/radio/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  radio  for every\nradio.  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$radio = new Element\\Radio('likes_chocolate');\n$radio->setLabel('Do you like chocolate?');\n$radio->setValueOptions([\n    '0' => 'No',\n    '1' => 'Yes',\n]);\n\n$form = new Form('my-form');\n$form->add($radio);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Radio::class,\n    'name' => 'likes_chocolate',\n    'options' => [\n        'label' => 'Do you like chocolate?',\n        'value_options' => [\n            '0' => 'No',\n            '1' => 'Yes',\n        ],\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/radio/#advanced-usage",
            "text": "See  MultiCheckbox for examples  of how to apply attributes\nand options to each radio button.",
            "title": "Advanced Usage"
        },
        {
            "location": "/element/radio/#public-methods",
            "text": "The  Radio  element extends the  MultiCheckbox  element, and inherits its methods .",
            "title": "Public Methods"
        },
        {
            "location": "/element/range/",
            "text": "Range\n\n\nZend\\Form\\Element\\Range\n is meant to be paired with the\n\nFormRange\n helper for\n\nHTML5 inputs with type \"range\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 range values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nrange\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$range = new Element\\Range('range');\n$range->setLabel('Minimum and Maximum Amount');\n$range->setAttributes([\n    'min'  => '0',   // default minimum is 0\n    'max'  => '100', // default maximum is 100\n    'step' => '1',   // default interval is 1\n]);\n\n$form = new Form('my-form');\n$form->add($range);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Range::class,\n    'name' => 'range',\n    'options' => [\n        'label' => 'Minimum and Maximum Amount',\n    ],\n    'attributes' => [\n        'min' => 0, // default minimum is 0\n        'max' => 100, // default maximum is 100\n        'step' => 1, // default interval is 1\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe \nRange\n element extends the \nNumber\n element, and inherits\n\nits methods\n, with the following changes:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes. See \nthe Number element\n for more information.  The \nRange\n element differs from \nZend\\Form\\Element\\Number\n in that the \nZend\\Validator\\GreaterThan\n and \nZend\\Validator\\LessThan\n validators will always be present. The default minimum is 1, and the default maximum is 100.",
            "title": "range"
        },
        {
            "location": "/element/range/#range",
            "text": "Zend\\Form\\Element\\Range  is meant to be paired with the FormRange  helper for HTML5 inputs with type \"range\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 range values on the server.",
            "title": "Range"
        },
        {
            "location": "/element/range/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  range .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$range = new Element\\Range('range');\n$range->setLabel('Minimum and Maximum Amount');\n$range->setAttributes([\n    'min'  => '0',   // default minimum is 0\n    'max'  => '100', // default maximum is 100\n    'step' => '1',   // default interval is 1\n]);\n\n$form = new Form('my-form');\n$form->add($range);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Range::class,\n    'name' => 'range',\n    'options' => [\n        'label' => 'Minimum and Maximum Amount',\n    ],\n    'attributes' => [\n        'min' => 0, // default minimum is 0\n        'max' => 100, // default maximum is 100\n        'step' => 1, // default interval is 1\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/range/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/range/#public-methods",
            "text": "The  Range  element extends the  Number  element, and inherits its methods , with the following changes:     Method signature  Description      getInputSpecification() : array  Returns a input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes. See  the Number element  for more information.  The  Range  element differs from  Zend\\Form\\Element\\Number  in that the  Zend\\Validator\\GreaterThan  and  Zend\\Validator\\LessThan  validators will always be present. The default minimum is 1, and the default maximum is 100.",
            "title": "Public Methods"
        },
        {
            "location": "/element/search/",
            "text": "Search\n\n\nZend\\Form\\Element\\Search\n is meant to be paired with the\n\nFormSearch\n helper for\n\nHTML5 inputs with type \"search\"\n\n\nAvailable since 2.9.0.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nsearch\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$search = new Element\\Search('search');\n$search->setLabel('Search');\n\n$form = new Form('my-form');\n$form->add($search);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Search::class,\n    'name' => 'search',\n    'options' => [\n        'label' => 'Search',\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThis element defines no methods beyond those of the parent \nElement\n class.",
            "title": "search"
        },
        {
            "location": "/element/search/#search",
            "text": "Zend\\Form\\Element\\Search  is meant to be paired with the FormSearch  helper for HTML5 inputs with type \"search\"  Available since 2.9.0.",
            "title": "Search"
        },
        {
            "location": "/element/search/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  search .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$search = new Element\\Search('search');\n$search->setLabel('Search');\n\n$form = new Form('my-form');\n$form->add($search);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Search::class,\n    'name' => 'search',\n    'options' => [\n        'label' => 'Search',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/search/#public-methods",
            "text": "This element defines no methods beyond those of the parent  Element  class.",
            "title": "Public Methods"
        },
        {
            "location": "/element/select/",
            "text": "Select\n\n\nZend\\Form\\Element\\Select\n is meant to be paired with\n\nFormSelect\n for HTML inputs with type \"select\". This\nelement adds an \nInArray\n validator to its input filter specification in order\nto validate on the server if the selected value belongs to the values. This\nelement can be used as a multi-select element by adding the \nmultiple\n HTML\nattribute to the element.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nselect\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$select = new Element\\Select('language');\n$select->setLabel('Which is your mother tongue?');\n$select->setValueOptions([\n    '0' => 'French',\n    '1' => 'English',\n    '2' => 'Japanese',\n    '3' => 'Chinese',\n]);\n\n$form = new Form('language');\n$form->add($select);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Select::class,\n    'name' => 'language',\n    'options' => [\n        'label' => 'Which is your mother tongue?',\n        'value_options' => [\n            '0' => 'French',\n            '1' => 'English',\n            '2' => 'Japanese',\n            '3' => 'Chinese',\n        ],\n    ],\n]);\n\n\n\nYou can add an empty option (option with no value) using the \nempty_option\n\noption:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Select::class,\n    'name' => 'language',\n    'options' => [\n        'label' => 'Which is your mother tongue?',\n        'empty_option' => 'Please choose your language',\n        'value_options' => [\n            '0' => 'French',\n            '1' => 'English',\n            '2' => 'Japanese',\n            '3' => 'Chinese',\n        ],\n    ],\n]);\n\n\n\nOption groups are also supported by adding an \noptions\n key to the value options:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$select = new Element\\Select('language');\n$select->setLabel('Which is your mother tongue?');\n$select->setValueOptions([\n     'european' => [\n        'label' => 'European languages',\n        'options' => [\n           '0' => 'French',\n           '1' => 'Italian',\n        ],\n     ],\n     'asian' => [\n        'label' => 'Asian languages',\n        'options' => [\n           '2' => 'Japanese',\n           '3' => 'Chinese',\n        ],\n     ],\n]);\n\n$form = new Form('language');\n$form->add($select);\n\n\n\nAttributes on the options are supported by providing the options as a\nspecification array instead of key-value pairs:\n\n\n$select->setValueOptions([\n    [\n        'value' => '0',\n        'label' => 'French',\n        'attributes' => [\n            'data-locale' = 'fr'\n        ],\n    ],\n    [\n        'value' => '1',\n        'label' => 'Italian',\n        'disabled' => true,\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nSelect\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetOptions(array $options) : void\n\n\nSet options for an element. Accepted options, in addition to the inherited options, include \nvalue_options\n, \nempty_option\n, and \ndisable_inarray_validator\n, which call \nsetValueOptions()\n, \nsetEmptyOption()\n and \nsetDisableInArrayValidator()\n, respectively.\n\n\n\n\n\n\nsetValueOptions(array $options) : void\n\n\nSet the value options for the select element. The array must contain key/value pairs.\n\n\n\n\n\n\ngetValueOptions() : array\n\n\nReturn the value options.\n\n\n\n\n\n\nunsetValueOption($key) : void\n\n\nUnset the value option from the select element.\n\n\n\n\n\n\nsetEmptyOption($emptyOption) : void\n\n\nOptionally set a label for an empty option (option with no value). It is set to \nnull\n by default, which means that no empty option will be rendered.\n\n\n\n\n\n\ngetEmptyOption() : string|null\n\n\nGet the label for the empty option (\nnull\n if none).",
            "title": "select"
        },
        {
            "location": "/element/select/#select",
            "text": "Zend\\Form\\Element\\Select  is meant to be paired with FormSelect  for HTML inputs with type \"select\". This\nelement adds an  InArray  validator to its input filter specification in order\nto validate on the server if the selected value belongs to the values. This\nelement can be used as a multi-select element by adding the  multiple  HTML\nattribute to the element.",
            "title": "Select"
        },
        {
            "location": "/element/select/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  select .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$select = new Element\\Select('language');\n$select->setLabel('Which is your mother tongue?');\n$select->setValueOptions([\n    '0' => 'French',\n    '1' => 'English',\n    '2' => 'Japanese',\n    '3' => 'Chinese',\n]);\n\n$form = new Form('language');\n$form->add($select);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Select::class,\n    'name' => 'language',\n    'options' => [\n        'label' => 'Which is your mother tongue?',\n        'value_options' => [\n            '0' => 'French',\n            '1' => 'English',\n            '2' => 'Japanese',\n            '3' => 'Chinese',\n        ],\n    ],\n]);  You can add an empty option (option with no value) using the  empty_option \noption:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Select::class,\n    'name' => 'language',\n    'options' => [\n        'label' => 'Which is your mother tongue?',\n        'empty_option' => 'Please choose your language',\n        'value_options' => [\n            '0' => 'French',\n            '1' => 'English',\n            '2' => 'Japanese',\n            '3' => 'Chinese',\n        ],\n    ],\n]);  Option groups are also supported by adding an  options  key to the value options:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$select = new Element\\Select('language');\n$select->setLabel('Which is your mother tongue?');\n$select->setValueOptions([\n     'european' => [\n        'label' => 'European languages',\n        'options' => [\n           '0' => 'French',\n           '1' => 'Italian',\n        ],\n     ],\n     'asian' => [\n        'label' => 'Asian languages',\n        'options' => [\n           '2' => 'Japanese',\n           '3' => 'Chinese',\n        ],\n     ],\n]);\n\n$form = new Form('language');\n$form->add($select);  Attributes on the options are supported by providing the options as a\nspecification array instead of key-value pairs:  $select->setValueOptions([\n    [\n        'value' => '0',\n        'label' => 'French',\n        'attributes' => [\n            'data-locale' = 'fr'\n        ],\n    ],\n    [\n        'value' => '1',\n        'label' => 'Italian',\n        'disabled' => true,\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/select/#public-methods",
            "text": "The following methods are specific to the  Select  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      setOptions(array $options) : void  Set options for an element. Accepted options, in addition to the inherited options, include  value_options ,  empty_option , and  disable_inarray_validator , which call  setValueOptions() ,  setEmptyOption()  and  setDisableInArrayValidator() , respectively.    setValueOptions(array $options) : void  Set the value options for the select element. The array must contain key/value pairs.    getValueOptions() : array  Return the value options.    unsetValueOption($key) : void  Unset the value option from the select element.    setEmptyOption($emptyOption) : void  Optionally set a label for an empty option (option with no value). It is set to  null  by default, which means that no empty option will be rendered.    getEmptyOption() : string|null  Get the label for the empty option ( null  if none).",
            "title": "Public Methods"
        },
        {
            "location": "/element/submit/",
            "text": "Submit\n\n\nZend\\Form\\Element\\Submit\n represents a submit button form input.\nIt should be used with the \nFormSubmit\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nsubmit\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$submit = new Element\\Submit('my-submit');\n$submit->setValue('Submit Form');\n\n$form = new Form('my-form');\n$form->add($submit);",
            "title": "submit"
        },
        {
            "location": "/element/submit/#submit",
            "text": "Zend\\Form\\Element\\Submit  represents a submit button form input.\nIt should be used with the  FormSubmit  view helper.",
            "title": "Submit"
        },
        {
            "location": "/element/submit/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  submit .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$submit = new Element\\Submit('my-submit');\n$submit->setValue('Submit Form');\n\n$form = new Form('my-form');\n$form->add($submit);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/tel/",
            "text": "Tel\n\n\nZend\\Form\\Element\\Tel\n is meant to be paired with the\n\nFormTel\n helper for\n\nHTML5 inputs with type \"tel\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 tel input values on the server.\n\n\nAvailable since 2.9.0.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ntel\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$phone = new Element\\Tel('phone');\n$phone->setLabel('Phone');\n\n$form = new Form('my-form');\n$form->add($phone);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Tel::class,\n    'name' => 'phone',\n    'options' => [\n        'label' => 'Phone',\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nTel\n element:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns an input filter specification, which includes \nZend\\Filter\\StringTrim\n and \nZend\\Filter\\StripNewlines\n, as well as a regex validator to ensure the value does not contain any carriage returns or newlines within it.",
            "title": "tel"
        },
        {
            "location": "/element/tel/#tel",
            "text": "Zend\\Form\\Element\\Tel  is meant to be paired with the FormTel  helper for HTML5 inputs with type \"tel\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 tel input values on the server.  Available since 2.9.0.",
            "title": "Tel"
        },
        {
            "location": "/element/tel/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  tel .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$phone = new Element\\Tel('phone');\n$phone->setLabel('Phone');\n\n$form = new Form('my-form');\n$form->add($phone);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Tel::class,\n    'name' => 'phone',\n    'options' => [\n        'label' => 'Phone',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/tel/#public-methods",
            "text": "The following methods are specific to the  Tel  element:     Method signature  Description      getInputSpecification() : array  Returns an input filter specification, which includes  Zend\\Filter\\StringTrim  and  Zend\\Filter\\StripNewlines , as well as a regex validator to ensure the value does not contain any carriage returns or newlines within it.",
            "title": "Public Methods"
        },
        {
            "location": "/element/text/",
            "text": "Text\n\n\nZend\\Form\\Element\\Text\n represents a text form input.\nIt should be used with the \nFormText\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ntext\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$text = new Element\\Text('my-text');\n$text->setLabel('Enter your name');\n\n$form = new Form('my-form');\n$form->add($text);",
            "title": "text"
        },
        {
            "location": "/element/text/#text",
            "text": "Zend\\Form\\Element\\Text  represents a text form input.\nIt should be used with the  FormText  view helper.",
            "title": "Text"
        },
        {
            "location": "/element/text/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  text .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$text = new Element\\Text('my-text');\n$text->setLabel('Enter your name');\n\n$form = new Form('my-form');\n$form->add($text);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/textarea/",
            "text": "Textarea\n\n\nZend\\Form\\Element\\Textarea\n represents a textarea form input.\nIt should be used with the \nFormTextarea\n view helper.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ntextarea\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$textarea = new Element\\Textarea('my-textarea');\n$textarea->setLabel('Enter a description');\n\n$form = new Form('my-form');\n$form->add($textarea);",
            "title": "textarea"
        },
        {
            "location": "/element/textarea/#textarea",
            "text": "Zend\\Form\\Element\\Textarea  represents a textarea form input.\nIt should be used with the  FormTextarea  view helper.",
            "title": "Textarea"
        },
        {
            "location": "/element/textarea/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  textarea .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$textarea = new Element\\Textarea('my-textarea');\n$textarea->setLabel('Enter a description');\n\n$form = new Form('my-form');\n$form->add($textarea);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/time/",
            "text": "Time\n\n\nZend\\Form\\Element\\Time\n is meant to be paired with the\n\nFormTime\n helper for\n\nHTML5 inputs with type \"time\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 time input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \ntime\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$time = new Element\\Time('time');\n$time->setLabel('Time');\n$time->setAttributes([\n    'min'  => '00:00:00',\n    'max'  => '23:59:59',\n    'step' => '60', // seconds; default step interval is 60 seconds\n]);\n$time->setOptions([\n    'format' => 'H:i:s',\n]);\n\n$form = new Form('my-form');\n$form->add($time);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Time::class,\n    'name' => 'time',\n    'options'=> [\n        'label'  => 'Time',\n        'format' => 'H:i:s',\n    ],\n    'attributes' => [\n        'min' => '00:00:00',\n        'max' => '23:59:59',\n        'step' => '60', // seconds; default step interval is 60 seconds\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\nDefault date format\n\n\nThe default date format for the validator is \nH:i:s\n. However, a valid time\nstring is not required to have a \"seconds\" representation. In fact, some user\nagent UIs such as Google Chrome and Opera submit time elements using the \nH:i\n\nformat (i.e.  without a seconds representation). Set the date format\naccordingly.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nTime\n element; all other methods\ninherited from the \nparent \nDateTime\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes and \nformat\n option. See the \nDateTime element\n for more information.  One difference from \nZend\\Form\\Element\\DateTime\n is that the \nZend\\Validator\\DateStep\n validator will expect the \nstep\n attribute to use an interval of seconds (default is 60 seconds).",
            "title": "time"
        },
        {
            "location": "/element/time/#time",
            "text": "Zend\\Form\\Element\\Time  is meant to be paired with the FormTime  helper for HTML5 inputs with type \"time\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 time input values on the server.",
            "title": "Time"
        },
        {
            "location": "/element/time/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  time .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$time = new Element\\Time('time');\n$time->setLabel('Time');\n$time->setAttributes([\n    'min'  => '00:00:00',\n    'max'  => '23:59:59',\n    'step' => '60', // seconds; default step interval is 60 seconds\n]);\n$time->setOptions([\n    'format' => 'H:i:s',\n]);\n\n$form = new Form('my-form');\n$form->add($time);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Time::class,\n    'name' => 'time',\n    'options'=> [\n        'label'  => 'Time',\n        'format' => 'H:i:s',\n    ],\n    'attributes' => [\n        'min' => '00:00:00',\n        'max' => '23:59:59',\n        'step' => '60', // seconds; default step interval is 60 seconds\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/time/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/time/#default-date-format",
            "text": "The default date format for the validator is  H:i:s . However, a valid time\nstring is not required to have a \"seconds\" representation. In fact, some user\nagent UIs such as Google Chrome and Opera submit time elements using the  H:i \nformat (i.e.  without a seconds representation). Set the date format\naccordingly.",
            "title": "Default date format"
        },
        {
            "location": "/element/time/#public-methods",
            "text": "The following methods are specific to the  Time  element; all other methods\ninherited from the  parent  DateTime  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns a input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes and  format  option. See the  DateTime element  for more information.  One difference from  Zend\\Form\\Element\\DateTime  is that the  Zend\\Validator\\DateStep  validator will expect the  step  attribute to use an interval of seconds (default is 60 seconds).",
            "title": "Public Methods"
        },
        {
            "location": "/element/url/",
            "text": "Url\n\n\nZend\\Form\\Element\\Url\n is meant to be paired with the\n\nFormUrl\n helper for\n\nHTML5 inputs with type \"url\"\n.\nThis element adds filters and a \nZend\\Validator\\Uri\n validator to its input\nfilter specification for validating HTML5 URL input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nurl\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$url = new Element\\Url('webpage-url');\n$url->setLabel('Webpage URL');\n\n$form = new Form('my-form');\n$form->add($url);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Url::class,\n    'name' => 'webpage-url',\n    'options' => [\n        'label' => 'Webpage URL',\n    ],\n]);\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nUrl\n element; all other methods\ndefined by the \nparent \nElement\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes a \nZend\\Filter\\StringTrim\n filter, and a \nZend\\Validator\\Uri\n to validate the URI string.",
            "title": "url"
        },
        {
            "location": "/element/url/#url",
            "text": "Zend\\Form\\Element\\Url  is meant to be paired with the FormUrl  helper for HTML5 inputs with type \"url\" .\nThis element adds filters and a  Zend\\Validator\\Uri  validator to its input\nfilter specification for validating HTML5 URL input values on the server.",
            "title": "Url"
        },
        {
            "location": "/element/url/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  url .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$url = new Element\\Url('webpage-url');\n$url->setLabel('Webpage URL');\n\n$form = new Form('my-form');\n$form->add($url);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Url::class,\n    'name' => 'webpage-url',\n    'options' => [\n        'label' => 'Webpage URL',\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/url/#public-methods",
            "text": "The following methods are specific to the  Url  element; all other methods\ndefined by the  parent  Element  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns a input filter specification, which includes a  Zend\\Filter\\StringTrim  filter, and a  Zend\\Validator\\Uri  to validate the URI string.",
            "title": "Public Methods"
        },
        {
            "location": "/element/week/",
            "text": "Week\n\n\nZend\\Form\\Element\\Week\n is meant to be paired with the\n\nFormWeek\n helper for\n\nHTML5 inputs with type \"week\"\n.\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 week input values on the server.\n\n\nBasic Usage\n\n\nThis element automatically adds a \ntype\n attribute of value \nweek\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$week = new Element\\Week('week');\n$week->setLabel('Week');\n$week->setAttributes([\n    'min'  => '2012-W01',\n    'max'  => '2020-W01',\n    'step' => '1', // weeks; default step interval is 1 week\n]);\n\n$form = new Form('my-form');\n$form->add($week);\n\n\n\nUsing array notation:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Week::class,\n    'name' => 'week',\n    'options' => [\n        'label' => 'Week',\n    ],\n    'attributes' => [\n        'min' => '2012-W01',\n        'max' => '2020-W01',\n        'step' => '1', // weeks; default step interval is 1 week\n    ],\n]);\n\n\n\n\n\nSet all attributes before calling prepare\n\n\nThe \nmin\n, \nmax\n, and \nstep\n attributes should be set prior to calling\n\nZend\\Form::prepare()\n. Otherwise, the default input specification for the\nelement may not contain the correct validation rules.\n\n\n\n\nPublic Methods\n\n\nThe following methods are specific to the \nWeek\n element; all other methods\ninherited from the \nparent \nDateTime\n class\n are also\navailable.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetInputSpecification() : array\n\n\nReturns a input filter specification, which includes \nZend\\Filter\\StringTrim\n and will add the appropriate validators based on the values from the \nmin\n, \nmax\n, and \nstep\n attributes and \nformat\n option.  See the \nDateTime element\n for more information.  One difference from \nZend\\Form\\Element\\DateTime\n is that the \nZend\\Validator\\DateStep\n validator will expect the \nstep\n attribute to use an interval of weeks (default is 1 week).",
            "title": "week"
        },
        {
            "location": "/element/week/#week",
            "text": "Zend\\Form\\Element\\Week  is meant to be paired with the FormWeek  helper for HTML5 inputs with type \"week\" .\nThis element adds filters and validators to its input filter specification in\norder to validate HTML5 week input values on the server.",
            "title": "Week"
        },
        {
            "location": "/element/week/#basic-usage",
            "text": "This element automatically adds a  type  attribute of value  week .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$week = new Element\\Week('week');\n$week->setLabel('Week');\n$week->setAttributes([\n    'min'  => '2012-W01',\n    'max'  => '2020-W01',\n    'step' => '1', // weeks; default step interval is 1 week\n]);\n\n$form = new Form('my-form');\n$form->add($week);  Using array notation:  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\n$form = new Form('my-form');\n$form->add([\n    'type' => Element\\Week::class,\n    'name' => 'week',\n    'options' => [\n        'label' => 'Week',\n    ],\n    'attributes' => [\n        'min' => '2012-W01',\n        'max' => '2020-W01',\n        'step' => '1', // weeks; default step interval is 1 week\n    ],\n]);",
            "title": "Basic Usage"
        },
        {
            "location": "/element/week/#set-all-attributes-before-calling-prepare",
            "text": "The  min ,  max , and  step  attributes should be set prior to calling Zend\\Form::prepare() . Otherwise, the default input specification for the\nelement may not contain the correct validation rules.",
            "title": "Set all attributes before calling prepare"
        },
        {
            "location": "/element/week/#public-methods",
            "text": "The following methods are specific to the  Week  element; all other methods\ninherited from the  parent  DateTime  class  are also\navailable.     Method signature  Description      getInputSpecification() : array  Returns a input filter specification, which includes  Zend\\Filter\\StringTrim  and will add the appropriate validators based on the values from the  min ,  max , and  step  attributes and  format  option.  See the  DateTime element  for more information.  One difference from  Zend\\Form\\Element\\DateTime  is that the  Zend\\Validator\\DateStep  validator will expect the  step  attribute to use an interval of weeks (default is 1 week).",
            "title": "Public Methods"
        },
        {
            "location": "/collections/",
            "text": "Form Collections\n\n\nOften, fieldsets or elements in your forms will correspond to other domain\nobjects. In some cases, they may correspond to \ncollections\n of domain objects.\nIn this latter case, in terms of user interfaces, you may want to add items\ndynamically in the user interface \u2014 a great example is adding tasks to a\ntask list.\n\n\nThis document is intended to demonstrate these features. To do so, we first need\nto define some domain objects that we'll be using.\n\n\nnamespace Application\\Entity;\n\nclass Product\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var int\n     */\n    protected $price;\n\n    /**\n     * @var Brand\n     */\n    protected $brand;\n\n    /**\n     * @var array\n     */\n    protected $categories;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param int $price\n     * @return self\n     */\n    public function setPrice($price)\n    {\n        $this->price = $price;\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getPrice()\n    {\n        return $this->price;\n    }\n\n    /**\n     * @param Brand $brand\n     * @return self\n     */\n    public function setBrand(Brand $brand)\n    {\n        $this->brand = $brand;\n        return $this;\n    }\n\n    /**\n     * @return Brand\n     */\n    public function getBrand()\n    {\n        return $this->brand;\n    }\n\n    /**\n     * @param Category[] $categories\n     * @return self\n     */\n    public function setCategories(array $categories)\n    {\n        $this->categories = $categories;\n        return $this;\n    }\n\n    /**\n     * @return Category[]\n     */\n    public function getCategories()\n    {\n        return $this->categories;\n    }\n}\n\nclass Brand\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var string\n     */\n    protected $url;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param string $url\n     * @return self\n     */\n    public function setUrl($url)\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getUrl()\n    {\n        return $this->url;\n    }\n}\n\nclass Category\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n}\n\n\n\nA \nProduct\n has two scalar properties, name and price, a\n1:1 relationship (one \nProduct\n has one \nBrand\n), and a 1:N relationship (one\n\nProduct\n has many \nCategory\n instances).\n\n\nCreating Fieldsets\n\n\nThe first step is to create three fieldsets. Each fieldset will contain all the\nfields and relationships for a specific entity.\n\n\nHere is the \nBrand\n fieldset:\n\n\nnamespace Application\\Form;\n\nuse Application\\Entity\\Brand;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass BrandFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('brand');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Brand());\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the brand',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'name' => 'url',\n            'type' => Element\\Url::class,\n            'options' => [\n                'label' => 'Website of the brand',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n    }\n\n    /**\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n        ];\n    }\n}\n\n\n\nThe fieldset calls the method \nsetHydrator()\n, giving it a \nClassMethods\n\nhydrator, and the \nsetObject()\n method, giving it an empty \nBrand\n instance.\n\n\nWhen we validate incoming data, the form will automatically iterate through all\nthe fieldsets it contains populate all sub-objects, in order to return a\ncomplete entity.\n\n\nNotice that the \nUrl\n element has a type of \nZend\\Form\\Element\\Url\n. This\ninformation will be used to validate the input field. You don't need to manually\nadd filters or validators for this input as that element provides a reasonable\ninput specification.\n\n\nFinally, \ngetInputFilterSpecification()\n gives the specification for the\nremaining input (\"name\"), indicating that this input is required. Note that\n\nrequired\n in the array \"attributes\" (when elements are added) is only meant to\nadd the \"required\" attribute to the form markup (and therefore has semantic\nmeaning only).\n\n\nHere is the \nCategory\n fieldset:\n\n\nnamespace Application\\Form;\n\nuse Application\\Entity\\Category;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CategoryFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('category');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Category());\n\n        $this->setLabel('Category');\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the category',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n    }\n\n    /**\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n        ];\n    }\n}\n\n\n\nNothing new here.\n\n\nFinally, the \nProduct\n fieldset:\n\n\nnamespace Application\\Form;\n\nuse Application\\Entity\\Product;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass ProductFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('product');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Product());\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the product',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'name' => 'price',\n            'options' => [\n                'label' => 'Price of the product',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'type' => BrandFieldset::class,\n            'name' => 'brand',\n            'options' => [\n                'label' => 'Brand of the product',\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Collection::class,\n            'name' => 'categories',\n            'options' => [\n                'label' => 'Please choose categories for this product',\n                'count' => 2,\n                'should_create_template' => true,\n                'allow_add' => true,\n                'target_element' => [\n                    'type' => CategoryFieldset::class,\n                ],\n            ],\n        ]);\n    }\n\n    /**\n     * Should return an array specification compatible with\n     * {@link Zend\\InputFilter\\Factory::createInputFilter()}.\n     *\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n            'price' => [\n                'required' => true,\n                'validators' => [\n                    [\n                        'name' => 'Float',\n                    ],\n                ],\n            ],\n        ];\n    }\n}\n\n\n\nWe have a lot of new things here!\n\n\nFirst, notice how the brand element is added: we specify it to be of type\n\nApplication\\Form\\BrandFieldset\n. This is how you handle a 1:1\nrelationship. When the form is validated, the \nBrandFieldset\n will first be\npopulated, and will return a \nBrand\n entity (as we have specified a\n\nClassMethods\n hydrator, and bound the fieldset to a \nBrand\n entity using the\n\nsetObject()\n method). This \nBrand\n entity will then be used to populate the\n\nProduct\n entity by calling the \nsetBrand()\n method.\n\n\nThe next element shows you how to handle 1:N relationships. The type is\n\nZend\\Form\\Element\\Collection\n, which is a specialized element to handle such\ncases. As you can see, the name of the element (\"categories\") perfectly matches\nthe name of the property in the \nProduct\n entity.\n\n\nThis element has a few interesting options:\n\n\n\n\ncount\n: this is how many times the element (in this case, a category) has to\n  be rendered. We've set it to \n2\n in this example.\n\n\nshould_create_template\n: if set to \ntrue\n, it will generate a template markup\n  in a \n<span>\n element, in order to simplify adding new element on the fly (we\n  will speak about this one later).\n\n\nallow_add\n: if set to \ntrue\n (which is the default), dynamically added\n  elements will be retrieved and validated; otherwise, they will be completely\n  ignored. This, of course, depends on what you want to do.\n\n\ntarget_element\n: this is either an element or, as this is the case in this\n  example, an array that describes the element or fieldset that will be used in\n  the collection. In this case, the \ntarget_element\n is a \nCategory\n fieldset.\n\n\n\n\nThe Form Element\n\n\nSo far, so good. We now have our fieldsets in place. But those are fieldsets,\nnot forms. And only \nForm\n instances can be validated. So here is the form:\n\n\nnamespace Application\\Form;\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CreateProduct extends Form\n{\n    public function __construct()\n    {\n        parent::__construct('create_product');\n\n        $this->setAttribute('method', 'post')\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setInputFilter(new InputFilter());\n\n        $this->add([\n            'type' => ProductFieldset::class,\n            'options' => [\n                'use_as_base_fieldset' => true,\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Csrf::class,\n            'name' => 'csrf',\n        ]);\n\n        $this->add([\n            'name' => 'submit',\n            'attributes' => [\n                'type' => 'submit',\n                'value' => 'Send',\n            ],\n        ]);\n    }\n}\n\n\n\nCreateProduct\n only defines a \nProduct\n fieldset, as well as some other useful\nfields (\nCSRF\n for security, and a \nSubmit\n button).\n\n\nNotice the \nuse_as_base_fieldset\n option. This option is here to say to the\nform: \"hey, the object I bind to you is, in fact, bound to the fieldset that is\nthe base fieldset.\" This will be to true in most situations.\n\n\nThis approach allows each entity to have its own \nFieldset\n, and enables re-use.\nYou describe the elements, the filters, and validators for each entity only\nonce, and the concrete \nForm\n instance will only compose those fieldsets. You no\nlonger have to add the \"username\" input to every form that deals with users!\n\n\nIntegrating with zend-mvc\n\n\nNow, let's create a zend-mvc controller action:\n\n\n/**\n  * @return array\n  */\n public function indexAction()\n {\n     $form = new CreateProduct();\n     $product = new Product();\n     $form->bind($product);\n     $request = $this->getRequest();\n\n     if ($request->isPost()) {\n         $form->setData($request->getPost());\n\n         if ($form->isValid()) {\n            var_dump($product);\n         }\n     }\n\n     return [\n         'form' => $form,\n     ];\n }\n\n\n\nAll the controller does is:\n\n\n\n\nCreate a form instance.\n\n\nBind it to an object.\n\n\nValidate it and/or return the form instance for later use by the view.\n\n\n\n\nIntegration with zend-view\n\n\nAnd finally, the view:\n\n\n<?php\n$form->setAttribute('action', $this->url('home'));\n$form->prepare();\necho $this->form()->openTag($form);\n\n$product = $form->get('product');\n\n// The name and price can be rendered as regular elements:\necho $this->formRow($product->get('name'));\necho $this->formRow($product->get('price'));\n\n// Categories are rendered as a collection:\necho $this->formCollection($product->get('categories'));\n\n$brand = $product->get('brand');\n\n// Since the brand is a 1:1 relationship, its elements are rendered normally:\necho $this->formRow($brand->get('name'));\necho $this->formRow($brand->get('url'));\n\n// And finally, we render the CSRF and submit elements:\necho $this->formHidden($form->get('csrf'));\necho $this->formElement($form->get('submit'));\n\necho $this->form()->closeTag();\n\n\n\nA few new things here :\n\n\n\n\nthe \nprepare()\n method. You \nmust\n call it prior to rendering anything in the\n  view (this function is only meant to be called in views, not in controllers).\n\n\nthe \nFormRow\n helper renders a label (if present), the input itself, and\n  errors.\n\n\nthe \nFormCollection\n helper will iterate through every element in the\n  collection, and render every element with the \nFormRow\n helper (you may\n  specify an alternate helper if desired, using the \nsetElementHelper()\n method\n  on that \nFormCollection\n helper instance). If you need more control about the\n  way you render your forms, you can iterate through the elements in the\n  collection, and render them manually one by one.\n\n\n\n\nHere is the result:\n\n\n\n\nCollections are wrapped inside a fieldset, and every item in the collection is\nitself wrapped in the fieldset. In fact, the \nCollection\n element uses \nlabel\n\nfor each item in the collection, while the label of the \nCollection\n element\nitself is used as the \nlegend\n of the \nfieldset\n. You must have a label on every\nelement in order to use this feature. If you don't want the fieldset created,\nbut just the elements within it, add a boolean \nfalse\n as the second parameter\nof the \nFormCollection\n view helper.\n\n\nIf you validate, all elements will show errors (this is normal, as we've marked\nthem as required). As soon as the form is valid, this is what we get :\n\n\n\n\nThe bound object is completely filled with the object instances we specified,\nnot with arrays!\n\n\nAdding New Elements Dynamically\n\n\nRemember that \nshould_create_template\n flag? We're going to use it now.\n\n\nOften, forms are not completely static. In our case, let's say that we don't\nwant only two categories, but we want the user to be able to add more at\nruntime. zend-form enables this capability. First, let's see what it generates\nwhen we ask it to create a template:\n\n\n\n\nThe collection generates two fieldsets (the two categories) \nplus\n a span with a\n\ndata-template\n attribute that contains the full HTML code to copy to create a\nnew element in the collection. The value \n__index__\n (this is the placeholder\ngenerated) must be changed to a valid value. Currently, we have 2 elements\n(\ncategories[0]\n and \ncategories[1]\n, so \n__index__\n must be changed to 2.\n\n\nIf you want, this placeholder (\n__index__\n is the default) can be changed using\nthe \ntemplate_placeholder\n option key:\n\n\n$this->add([\n    'type' => Element\\Collection::class,\n    'name' => 'categories',\n    'options' => [\n        'label' => 'Please choose categories for this product',\n        'count' => 2,\n        'should_create_template' => true,\n        'template_placeholder' => '__placeholder__',\n        'target_element' => [\n            'type' => CategoryFieldset::class,\n        ],\n    ],\n]);\n\n\n\nFirst, let's add a small button \"Add new category\" anywhere in the form:\n\n\n<button onclick=\"return add_category()\">Add a new category</button>\n\n\n\nThe \nadd_category\n function will need to do the following:\n\n\n\n\nFirst, count the number of elements we already have.\n\n\nGet the template from the \nspan\n's \ndata-template\n attribute.\n\n\nChange the placeholder to a valid index.\n\n\nAdd the element to the DOM.\n\n\n\n\nThe following is a potential implementation:\n\n\nfunction add_category() {\n    var currentCount = $('form > fieldset > fieldset').length;\n    var template = $('form > fieldset > span').data('template');\n    template = template.replace(/__index__/g, currentCount);\n\n    $('form > fieldset').append(template);\n\n    return false;\n}\n\n\n\n(Note: the above example assumes \n$()\n is defined, and equivalent to jQuery's\n\n$()\n function, Dojo's \ndojo.query\n, etc.)\n\n\nOne small remark about \ntemplate.replace\n: the example uses \ncurrentCount\n and\nnot \ncurrentCount + 1\n, as the indices are zero-based (so, if we have two\nelements in the + collection, the third one will have the index \n2\n).\n\n\nNow if we validate the form, it will automatically take into account this new\nelement by validating it, filtering it and retrieving it:\n\n\n\n\nIf you don't want to allow adding elements in a collection, you must set the\noption \nallow_add\n to \nfalse\n. This way, even if new elements are added, they\nwon't be validated and hence, not added to the entity. Also, if we don't want\nelements to be added, we don't need the data template, either.\n\n\nHere's how you both disable adding dynamic elements, and disable the template:\n\n\n$this->add([\n    'type' => Element\\Collection::class,\n    'name' => 'categories',\n    'options' => [\n        'label' => 'Please choose categories for this product',\n        'count' => 2,\n        // Do not allow adding:\n        'allow_add' => false,\n        // Do not display the index template:\n        'should_create_template' => false,\n        'target_element' => [\n            'type' => CategoryFieldset::class,\n        ],\n    ],\n]);\n\n\n\nThere are some limitations to this capability:\n\n\n\n\nAlthough you can add new elements and remove them, you \nCANNOT\n remove more\n  elements in a collection than the initial count (for instance, if your code\n  specifies \ncount == 2\n, you will be able to add a third one and remove it, but\n  you won't be able to remove any others. If the initial count is 2, you \nmust\n\n  have at least two elements.\n\n\nDynamically added elements have to be added at the end of the collection. They\n  can be added anywhere (these elements will still be validated and inserted\n  into the entity), but if the validation fails, this newly added element will\n  be automatically placed at the end of the collection.\n\n\n\n\nValidation groups for fieldsets and collection\n\n\nValidation groups allow you to validate a subset of fields.\n\n\nAs an example, although the \nBrand\n entity has a \nurl\n property, we don't want\nthe user to specify it in the creation form (but may wish to later in the \"Edit\nProduct\" form, for instance). Let's update the view to remove the \nurl\n input:\n\n\n<?php\n$form->setAttribute('action', $this->url('home'));\n$form->prepare();\n\necho $this->form()->openTag($form);\n\n$product = $form->get('product');\n\necho $this->formRow($product->get('name'));\necho $this->formRow($product->get('price'));\necho $this->formCollection($product->get('categories'));\n\n$brand = $product->get('brand');\n\necho $this->formRow($brand->get('name'));\n\necho $this->formHidden($form->get('csrf'));\necho $this->formElement($form->get('submit'));\n\necho $this->form()->closeTag();\n\n\n\nThis is what we get:\n\n\n\n\nThe \nurl\n input has disappeared, but even if we fill every input, the form won't\nvalidate. In fact, this is normal. We specified in the input filter that the\n\nurl\n is a \nrequired\n field, so if the form does not have it, it won't validate,\neven though we didn't add it to the view!\n\n\nOf course, you could create a \nBrandFieldsetWithoutUrl\n fieldset, but this would\nrequire a lot of duplicate code.\n\n\nThe solution: validation groups. A validation group is specified in a \nForm\n\nobject (hence, in our case, in the \nCreateProduct\n form) by giving an array of\nall the elements we want to validate. Our \nCreateProduct\n class now looks like\nthis:\n\n\nnamespace Application\\Form;\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CreateProduct extends Form\n{\n    public function __construct()\n    {\n        parent::__construct('create_product');\n\n        $this->setAttribute('method', 'post');\n        $this->setHydrator(new ClassMethodsHydrator());\n        $this->setInputFilter(new InputFilter());\n\n        $this->add([\n            'type' => ProductFieldset::class,\n            'options' => [\n                'use_as_base_fieldset' => true,\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Csrf::class,\n            'name' => 'csrf',\n        ]);\n\n        $this->add([\n            'name' => 'submit',\n            'attributes' => [\n                'type' => 'submit',\n                'value' => 'Send',\n            ],\n        ]);\n\n        $this->setValidationGroup([\n            'csrf',\n            'product' => [\n                'name',\n                'price',\n                'brand' => [\n                    'name',\n                ],\n                'categories' => [\n                    'name',\n                ],\n            ],\n        ]);\n    }\n}\n\n\n\nDon't forget to add the \nCSRF\n element, as we want it to be validated too (but\nnotice that the example omits the \nsubmit\n element, as we don't care about its\nvalue). You can also recursively select the elements if desired.\n\n\nThere is one limitation currently: validation groups for collections are set on\na per-collection basis, not per-element in a collection basis. This means you\ncannot say, \"validate the name input for the first element of the categories\ncollection, but don't validate it for the second one.\"\n\n\nNow, the form validates (and the \nurl\n is set to null as we didn't specify it).\n\n\nPreventing validation from wiping out previous collection items\n\n\nIn some cases, you may be representing collections within a model, but not\nvalidating them; as an example, if you use a validation group that excludes the\ncollections from validation so that they remain untouched after binding.\n\n\nStarting in 2.8.4, behavior around collections changed in order to fix some\nunderlying bugs. One such change is that if a collection is found in a form, but\nhas no associated data, an empty array is assigned to it, even when not in the\nvalidation group. This effectively wipes out the collection data when you bind\nvalues.\n\n\nTo prevent this behavior, starting in 2.9.1 you may pass an optional second\nargument to \nbindValues()\n on either a fieldset or collection,\n\n$validationGroup\n; when present, these instances will first check if the\ncollection is in the validation group before binding the value; if it is not,\nthe collection will not be represented. The \nForm\n class has been updated to\npass the validation group, if present, on to fieldset and collection instances\nwhen performing \nbindValues()\n operations.\n\n\nFor more details, refer to the following issues:\n\n\n\n\nzendframework/zend-form#19\n\n\nzendframework/zend-form#102\n\n\nzendframework/zend-form#103\n\n\nzendframework/zend-form#106",
            "title": "Collections"
        },
        {
            "location": "/collections/#form-collections",
            "text": "Often, fieldsets or elements in your forms will correspond to other domain\nobjects. In some cases, they may correspond to  collections  of domain objects.\nIn this latter case, in terms of user interfaces, you may want to add items\ndynamically in the user interface \u2014 a great example is adding tasks to a\ntask list.  This document is intended to demonstrate these features. To do so, we first need\nto define some domain objects that we'll be using.  namespace Application\\Entity;\n\nclass Product\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var int\n     */\n    protected $price;\n\n    /**\n     * @var Brand\n     */\n    protected $brand;\n\n    /**\n     * @var array\n     */\n    protected $categories;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param int $price\n     * @return self\n     */\n    public function setPrice($price)\n    {\n        $this->price = $price;\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getPrice()\n    {\n        return $this->price;\n    }\n\n    /**\n     * @param Brand $brand\n     * @return self\n     */\n    public function setBrand(Brand $brand)\n    {\n        $this->brand = $brand;\n        return $this;\n    }\n\n    /**\n     * @return Brand\n     */\n    public function getBrand()\n    {\n        return $this->brand;\n    }\n\n    /**\n     * @param Category[] $categories\n     * @return self\n     */\n    public function setCategories(array $categories)\n    {\n        $this->categories = $categories;\n        return $this;\n    }\n\n    /**\n     * @return Category[]\n     */\n    public function getCategories()\n    {\n        return $this->categories;\n    }\n}\n\nclass Brand\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var string\n     */\n    protected $url;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param string $url\n     * @return self\n     */\n    public function setUrl($url)\n    {\n        $this->url = $url;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getUrl()\n    {\n        return $this->url;\n    }\n}\n\nclass Category\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @param string $name\n     * @return self\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n}  A  Product  has two scalar properties, name and price, a\n1:1 relationship (one  Product  has one  Brand ), and a 1:N relationship (one Product  has many  Category  instances).",
            "title": "Form Collections"
        },
        {
            "location": "/collections/#creating-fieldsets",
            "text": "The first step is to create three fieldsets. Each fieldset will contain all the\nfields and relationships for a specific entity.  Here is the  Brand  fieldset:  namespace Application\\Form;\n\nuse Application\\Entity\\Brand;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass BrandFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('brand');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Brand());\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the brand',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'name' => 'url',\n            'type' => Element\\Url::class,\n            'options' => [\n                'label' => 'Website of the brand',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n    }\n\n    /**\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n        ];\n    }\n}  The fieldset calls the method  setHydrator() , giving it a  ClassMethods \nhydrator, and the  setObject()  method, giving it an empty  Brand  instance.  When we validate incoming data, the form will automatically iterate through all\nthe fieldsets it contains populate all sub-objects, in order to return a\ncomplete entity.  Notice that the  Url  element has a type of  Zend\\Form\\Element\\Url . This\ninformation will be used to validate the input field. You don't need to manually\nadd filters or validators for this input as that element provides a reasonable\ninput specification.  Finally,  getInputFilterSpecification()  gives the specification for the\nremaining input (\"name\"), indicating that this input is required. Note that required  in the array \"attributes\" (when elements are added) is only meant to\nadd the \"required\" attribute to the form markup (and therefore has semantic\nmeaning only).  Here is the  Category  fieldset:  namespace Application\\Form;\n\nuse Application\\Entity\\Category;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CategoryFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('category');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Category());\n\n        $this->setLabel('Category');\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the category',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n    }\n\n    /**\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n        ];\n    }\n}  Nothing new here.  Finally, the  Product  fieldset:  namespace Application\\Form;\n\nuse Application\\Entity\\Product;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\InputFilter\\InputFilterProviderInterface;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass ProductFieldset extends Fieldset implements InputFilterProviderInterface\n{\n    public function __construct()\n    {\n        parent::__construct('product');\n\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setObject(new Product());\n\n        $this->add([\n            'name' => 'name',\n            'options' => [\n                'label' => 'Name of the product',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'name' => 'price',\n            'options' => [\n                'label' => 'Price of the product',\n            ],\n            'attributes' => [\n                'required' => 'required',\n            ],\n        ]);\n\n        $this->add([\n            'type' => BrandFieldset::class,\n            'name' => 'brand',\n            'options' => [\n                'label' => 'Brand of the product',\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Collection::class,\n            'name' => 'categories',\n            'options' => [\n                'label' => 'Please choose categories for this product',\n                'count' => 2,\n                'should_create_template' => true,\n                'allow_add' => true,\n                'target_element' => [\n                    'type' => CategoryFieldset::class,\n                ],\n            ],\n        ]);\n    }\n\n    /**\n     * Should return an array specification compatible with\n     * {@link Zend\\InputFilter\\Factory::createInputFilter()}.\n     *\n     * @return array\n     */\n    public function getInputFilterSpecification()\n    {\n        return [\n            'name' => [\n                'required' => true,\n            ],\n            'price' => [\n                'required' => true,\n                'validators' => [\n                    [\n                        'name' => 'Float',\n                    ],\n                ],\n            ],\n        ];\n    }\n}  We have a lot of new things here!  First, notice how the brand element is added: we specify it to be of type Application\\Form\\BrandFieldset . This is how you handle a 1:1\nrelationship. When the form is validated, the  BrandFieldset  will first be\npopulated, and will return a  Brand  entity (as we have specified a ClassMethods  hydrator, and bound the fieldset to a  Brand  entity using the setObject()  method). This  Brand  entity will then be used to populate the Product  entity by calling the  setBrand()  method.  The next element shows you how to handle 1:N relationships. The type is Zend\\Form\\Element\\Collection , which is a specialized element to handle such\ncases. As you can see, the name of the element (\"categories\") perfectly matches\nthe name of the property in the  Product  entity.  This element has a few interesting options:   count : this is how many times the element (in this case, a category) has to\n  be rendered. We've set it to  2  in this example.  should_create_template : if set to  true , it will generate a template markup\n  in a  <span>  element, in order to simplify adding new element on the fly (we\n  will speak about this one later).  allow_add : if set to  true  (which is the default), dynamically added\n  elements will be retrieved and validated; otherwise, they will be completely\n  ignored. This, of course, depends on what you want to do.  target_element : this is either an element or, as this is the case in this\n  example, an array that describes the element or fieldset that will be used in\n  the collection. In this case, the  target_element  is a  Category  fieldset.",
            "title": "Creating Fieldsets"
        },
        {
            "location": "/collections/#the-form-element",
            "text": "So far, so good. We now have our fieldsets in place. But those are fieldsets,\nnot forms. And only  Form  instances can be validated. So here is the form:  namespace Application\\Form;\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CreateProduct extends Form\n{\n    public function __construct()\n    {\n        parent::__construct('create_product');\n\n        $this->setAttribute('method', 'post')\n        $this->setHydrator(new ClassMethodsHydrator(false));\n        $this->setInputFilter(new InputFilter());\n\n        $this->add([\n            'type' => ProductFieldset::class,\n            'options' => [\n                'use_as_base_fieldset' => true,\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Csrf::class,\n            'name' => 'csrf',\n        ]);\n\n        $this->add([\n            'name' => 'submit',\n            'attributes' => [\n                'type' => 'submit',\n                'value' => 'Send',\n            ],\n        ]);\n    }\n}  CreateProduct  only defines a  Product  fieldset, as well as some other useful\nfields ( CSRF  for security, and a  Submit  button).  Notice the  use_as_base_fieldset  option. This option is here to say to the\nform: \"hey, the object I bind to you is, in fact, bound to the fieldset that is\nthe base fieldset.\" This will be to true in most situations.  This approach allows each entity to have its own  Fieldset , and enables re-use.\nYou describe the elements, the filters, and validators for each entity only\nonce, and the concrete  Form  instance will only compose those fieldsets. You no\nlonger have to add the \"username\" input to every form that deals with users!",
            "title": "The Form Element"
        },
        {
            "location": "/collections/#integrating-with-zend-mvc",
            "text": "Now, let's create a zend-mvc controller action:  /**\n  * @return array\n  */\n public function indexAction()\n {\n     $form = new CreateProduct();\n     $product = new Product();\n     $form->bind($product);\n     $request = $this->getRequest();\n\n     if ($request->isPost()) {\n         $form->setData($request->getPost());\n\n         if ($form->isValid()) {\n            var_dump($product);\n         }\n     }\n\n     return [\n         'form' => $form,\n     ];\n }  All the controller does is:   Create a form instance.  Bind it to an object.  Validate it and/or return the form instance for later use by the view.",
            "title": "Integrating with zend-mvc"
        },
        {
            "location": "/collections/#integration-with-zend-view",
            "text": "And finally, the view:  <?php\n$form->setAttribute('action', $this->url('home'));\n$form->prepare();\necho $this->form()->openTag($form);\n\n$product = $form->get('product');\n\n// The name and price can be rendered as regular elements:\necho $this->formRow($product->get('name'));\necho $this->formRow($product->get('price'));\n\n// Categories are rendered as a collection:\necho $this->formCollection($product->get('categories'));\n\n$brand = $product->get('brand');\n\n// Since the brand is a 1:1 relationship, its elements are rendered normally:\necho $this->formRow($brand->get('name'));\necho $this->formRow($brand->get('url'));\n\n// And finally, we render the CSRF and submit elements:\necho $this->formHidden($form->get('csrf'));\necho $this->formElement($form->get('submit'));\n\necho $this->form()->closeTag();  A few new things here :   the  prepare()  method. You  must  call it prior to rendering anything in the\n  view (this function is only meant to be called in views, not in controllers).  the  FormRow  helper renders a label (if present), the input itself, and\n  errors.  the  FormCollection  helper will iterate through every element in the\n  collection, and render every element with the  FormRow  helper (you may\n  specify an alternate helper if desired, using the  setElementHelper()  method\n  on that  FormCollection  helper instance). If you need more control about the\n  way you render your forms, you can iterate through the elements in the\n  collection, and render them manually one by one.   Here is the result:   Collections are wrapped inside a fieldset, and every item in the collection is\nitself wrapped in the fieldset. In fact, the  Collection  element uses  label \nfor each item in the collection, while the label of the  Collection  element\nitself is used as the  legend  of the  fieldset . You must have a label on every\nelement in order to use this feature. If you don't want the fieldset created,\nbut just the elements within it, add a boolean  false  as the second parameter\nof the  FormCollection  view helper.  If you validate, all elements will show errors (this is normal, as we've marked\nthem as required). As soon as the form is valid, this is what we get :   The bound object is completely filled with the object instances we specified,\nnot with arrays!",
            "title": "Integration with zend-view"
        },
        {
            "location": "/collections/#adding-new-elements-dynamically",
            "text": "Remember that  should_create_template  flag? We're going to use it now.  Often, forms are not completely static. In our case, let's say that we don't\nwant only two categories, but we want the user to be able to add more at\nruntime. zend-form enables this capability. First, let's see what it generates\nwhen we ask it to create a template:   The collection generates two fieldsets (the two categories)  plus  a span with a data-template  attribute that contains the full HTML code to copy to create a\nnew element in the collection. The value  __index__  (this is the placeholder\ngenerated) must be changed to a valid value. Currently, we have 2 elements\n( categories[0]  and  categories[1] , so  __index__  must be changed to 2.  If you want, this placeholder ( __index__  is the default) can be changed using\nthe  template_placeholder  option key:  $this->add([\n    'type' => Element\\Collection::class,\n    'name' => 'categories',\n    'options' => [\n        'label' => 'Please choose categories for this product',\n        'count' => 2,\n        'should_create_template' => true,\n        'template_placeholder' => '__placeholder__',\n        'target_element' => [\n            'type' => CategoryFieldset::class,\n        ],\n    ],\n]);  First, let's add a small button \"Add new category\" anywhere in the form:  <button onclick=\"return add_category()\">Add a new category</button>  The  add_category  function will need to do the following:   First, count the number of elements we already have.  Get the template from the  span 's  data-template  attribute.  Change the placeholder to a valid index.  Add the element to the DOM.   The following is a potential implementation:  function add_category() {\n    var currentCount = $('form > fieldset > fieldset').length;\n    var template = $('form > fieldset > span').data('template');\n    template = template.replace(/__index__/g, currentCount);\n\n    $('form > fieldset').append(template);\n\n    return false;\n}  (Note: the above example assumes  $()  is defined, and equivalent to jQuery's $()  function, Dojo's  dojo.query , etc.)  One small remark about  template.replace : the example uses  currentCount  and\nnot  currentCount + 1 , as the indices are zero-based (so, if we have two\nelements in the + collection, the third one will have the index  2 ).  Now if we validate the form, it will automatically take into account this new\nelement by validating it, filtering it and retrieving it:   If you don't want to allow adding elements in a collection, you must set the\noption  allow_add  to  false . This way, even if new elements are added, they\nwon't be validated and hence, not added to the entity. Also, if we don't want\nelements to be added, we don't need the data template, either.  Here's how you both disable adding dynamic elements, and disable the template:  $this->add([\n    'type' => Element\\Collection::class,\n    'name' => 'categories',\n    'options' => [\n        'label' => 'Please choose categories for this product',\n        'count' => 2,\n        // Do not allow adding:\n        'allow_add' => false,\n        // Do not display the index template:\n        'should_create_template' => false,\n        'target_element' => [\n            'type' => CategoryFieldset::class,\n        ],\n    ],\n]);  There are some limitations to this capability:   Although you can add new elements and remove them, you  CANNOT  remove more\n  elements in a collection than the initial count (for instance, if your code\n  specifies  count == 2 , you will be able to add a third one and remove it, but\n  you won't be able to remove any others. If the initial count is 2, you  must \n  have at least two elements.  Dynamically added elements have to be added at the end of the collection. They\n  can be added anywhere (these elements will still be validated and inserted\n  into the entity), but if the validation fails, this newly added element will\n  be automatically placed at the end of the collection.",
            "title": "Adding New Elements Dynamically"
        },
        {
            "location": "/collections/#validation-groups-for-fieldsets-and-collection",
            "text": "Validation groups allow you to validate a subset of fields.  As an example, although the  Brand  entity has a  url  property, we don't want\nthe user to specify it in the creation form (but may wish to later in the \"Edit\nProduct\" form, for instance). Let's update the view to remove the  url  input:  <?php\n$form->setAttribute('action', $this->url('home'));\n$form->prepare();\n\necho $this->form()->openTag($form);\n\n$product = $form->get('product');\n\necho $this->formRow($product->get('name'));\necho $this->formRow($product->get('price'));\necho $this->formCollection($product->get('categories'));\n\n$brand = $product->get('brand');\n\necho $this->formRow($brand->get('name'));\n\necho $this->formHidden($form->get('csrf'));\necho $this->formElement($form->get('submit'));\n\necho $this->form()->closeTag();  This is what we get:   The  url  input has disappeared, but even if we fill every input, the form won't\nvalidate. In fact, this is normal. We specified in the input filter that the url  is a  required  field, so if the form does not have it, it won't validate,\neven though we didn't add it to the view!  Of course, you could create a  BrandFieldsetWithoutUrl  fieldset, but this would\nrequire a lot of duplicate code.  The solution: validation groups. A validation group is specified in a  Form \nobject (hence, in our case, in the  CreateProduct  form) by giving an array of\nall the elements we want to validate. Our  CreateProduct  class now looks like\nthis:  namespace Application\\Form;\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\Hydrator\\ClassMethods as ClassMethodsHydrator;\n\nclass CreateProduct extends Form\n{\n    public function __construct()\n    {\n        parent::__construct('create_product');\n\n        $this->setAttribute('method', 'post');\n        $this->setHydrator(new ClassMethodsHydrator());\n        $this->setInputFilter(new InputFilter());\n\n        $this->add([\n            'type' => ProductFieldset::class,\n            'options' => [\n                'use_as_base_fieldset' => true,\n            ],\n        ]);\n\n        $this->add([\n            'type' => Element\\Csrf::class,\n            'name' => 'csrf',\n        ]);\n\n        $this->add([\n            'name' => 'submit',\n            'attributes' => [\n                'type' => 'submit',\n                'value' => 'Send',\n            ],\n        ]);\n\n        $this->setValidationGroup([\n            'csrf',\n            'product' => [\n                'name',\n                'price',\n                'brand' => [\n                    'name',\n                ],\n                'categories' => [\n                    'name',\n                ],\n            ],\n        ]);\n    }\n}  Don't forget to add the  CSRF  element, as we want it to be validated too (but\nnotice that the example omits the  submit  element, as we don't care about its\nvalue). You can also recursively select the elements if desired.  There is one limitation currently: validation groups for collections are set on\na per-collection basis, not per-element in a collection basis. This means you\ncannot say, \"validate the name input for the first element of the categories\ncollection, but don't validate it for the second one.\"  Now, the form validates (and the  url  is set to null as we didn't specify it).",
            "title": "Validation groups for fieldsets and collection"
        },
        {
            "location": "/collections/#preventing-validation-from-wiping-out-previous-collection-items",
            "text": "In some cases, you may be representing collections within a model, but not\nvalidating them; as an example, if you use a validation group that excludes the\ncollections from validation so that they remain untouched after binding.  Starting in 2.8.4, behavior around collections changed in order to fix some\nunderlying bugs. One such change is that if a collection is found in a form, but\nhas no associated data, an empty array is assigned to it, even when not in the\nvalidation group. This effectively wipes out the collection data when you bind\nvalues.  To prevent this behavior, starting in 2.9.1 you may pass an optional second\nargument to  bindValues()  on either a fieldset or collection, $validationGroup ; when present, these instances will first check if the\ncollection is in the validation group before binding the value; if it is not,\nthe collection will not be represented. The  Form  class has been updated to\npass the validation group, if present, on to fieldset and collection instances\nwhen performing  bindValues()  operations.  For more details, refer to the following issues:   zendframework/zend-form#19  zendframework/zend-form#102  zendframework/zend-form#103  zendframework/zend-form#106",
            "title": "Preventing validation from wiping out previous collection items"
        },
        {
            "location": "/file-upload/",
            "text": "File Uploads\n\n\nzend-form provides support for file uploading by using features from each of\n\nzend-inputfilter\n,\n\nzend-validator\n,\n\nzend-filter\n, and\n\nzend-progressbar\n. These\nreusable framework components provide a convenient and secure way for handling\nfile uploads in your projects.\n\n\n\n\nLimited to POST uploads\n\n\nThe file upload features described here are specifically for forms using the\n\nPOST\n method.  zend-form does not currently provide specific support for\nhandling uploads via the \nPUT\n method, but it is possible with vanilla PHP.\nSee the \nPUT Method Support\n\nin the PHP documentation for more information.\n\n\n\n\nBasic Example\n\n\nHandling file uploads is \nessentially\n the same as how you would use \nZend\\Form\n\nfor form processing, but with some slight caveats that will be described below.\n\n\nIn this example we will:\n\n\n\n\nDefine a \nForm\n for backend validation and filtering.\n\n\nCreate a \nview template\n with a \n<form>\n containing a file input.\n\n\nProcess the form within a \nController action\n (zend-mvc) or in a \nRequest Handler\n (Expressive).\n\n\n\n\nThe Form and InputFilter\n\n\nHere we define a \nZend\\Form\\Element\\File\n input in a \nForm\n extension named\n\nUploadForm\n.\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload');\n        $file->setAttribute('id', 'image-file');\n\n        $this->add($file);\n    }\n}\n\n\n\nThe \nFile\n element provides several automated features:\n\n\n\n\nThe form's \nenctype\n will automatically be set to \nmultipart/form-data\n when\n  the form's \nprepare()\n method is called.\n\n\nThe file element's default input specification will create the correct \nInput\n\n  type: \nZend\\InputFilter\\FileInput\n.\n\n\nThe \nFileInput\n will automatically prepend an \nUploadFile validator\n\n  to securely validate that the file is actually an uploaded file, and to report\n  any upload errors to the user.\n\n\n\n\nThe View Template\n\n\nIn the view template, we render the \n<form>\n, a file input (with label and\nerrors), and a submit button.\n\n\n<!-- File: upload-form.phtml -->\n<?php\n    $form->prepare(); // The correct enctype is set here\n    $fileElement = $form->get('image-file');\n    echo $this->form()->openTag($form);\n?>\n\n    <div class=\"form-element\">\n        <?= $this->formLabel($fileElement) ?>\n        <?= $this->formFile($fileElement) ?>\n        <?= $this->formElementErrors($fileElement) ?>\n    </div>\n\n    <button>Submit</button>\n\n<?= $this->form()->closeTag() ?>\n\n\n\nWhen rendered, the HTML should look similar to:\n\n\n<form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\">\n    <div class=\"form-element\">\n        <label for=\"image-file\">Avatar Image Upload</label>\n        <input type=\"file\" name=\"image-file\" id=\"image-file\">\n    </div>\n\n    <button>Submit</button>\n</form>\n\n\n\nThe Controller Action\n\n\nWhen using zend-mvc, the final step will be to instantiate the \nUploadForm\n and\nprocess any postbacks in a controller action.\n\n\nThe form processing in the controller action will be similar to normal forms,\n\nexcept\n that you \nmust\n merge the \n$_FILES\n information in the request with\nthe other post data.\n\n\npublic function uploadFormAction()\n{\n    $form = new UploadForm('upload-form');\n\n    $request = $this->getRequest();\n    if ($request->isPost()) {\n        // Make certain to merge the $_FILES info!\n        $post = array_merge_recursive(\n            $request->getPost()->toArray(),\n            $request->getFiles()->toArray()\n        );\n\n        $form->setData($post);\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n            return $this->redirect()->toRoute('upload-form/success');\n        }\n    }\n\n    return ['form' => $form];\n}\n\n\n\nUpon a successful file upload, \n$form->getData()\n would return:\n\n\narray(1) {\n    [\"image-file\"] => array(5) {\n        [\"name\"]     => string(11) \"myimage.png\"\n        [\"type\"]     => string(9)  \"image/png\"\n        [\"tmp_name\"] => string(22) \"/private/tmp/phpgRXd58\"\n        [\"error\"]    => int(0)\n        [\"size\"]     => int(14908679)\n    }\n}\n\n\n\n\n\nUsing nested array notation for uploads\n\n\nIt is suggested that you always use the \nZend\\Http\\PhpEnvironment\\Request\n\nobject to retrieve and merge the \n$_FILES\n information with the form, instead\nof using \n$_FILES\n directly,  due to how the file information is\nmapped in the \n$_FILES\n array:\n\n\n// A $_FILES array with single input and multiple files:\narray(1) {\n    [\"image-file\"]=array(2) {\n        [\"name\"]=array(2) {\n            [0]=string(9)\"file0.txt\"\n            [1]=string(9)\"file1.txt\"\n        }\n        [\"type\"]=array(2) {\n            [0]=string(10)\"text/plain\"\n            [1]=string(10)\"text/html\"\n        }\n    }\n}\n\n// How Zend\\Http\\PhpEnvironment\\Request remaps the $_FILES array:\narray(1) {\n    [\"image-file\"]=array(2) {\n        [0]=array(2) {\n            [\"name\"]=string(9)\"file0.txt\"\n            [\"type\"]=string(10)\"text/plain\"\n        },\n        [1]=array(2) {\n            [\"name\"]=string(9)\"file1.txt\"\n            [\"type\"]=string(10)\"text/html\"\n        }\n    }\n}\n\n\n\nZend\\InputFilter\\FileInput\n expects the file data be in this\nre-mapped array format.\n\n\nNote: \nPSR-7\n also remaps the \n$_FILES\n\narray in this way.\n\n\n\n\nExpressive Request Handler\n\n\nIf you are using a \nPSR-15\n request handler\nwith \nPSR-7\n request payload, the final step\ninvolves merging \n$request->getParsedBody()\n with\n\n$request->getUploadedFiles()\n.\n\n\npublic function handle(ServerRequestInterface $request) : ResponseInterface\n{\n    $form = new UploadForm('upload-form');\n\n    if ($request->getMethod() === 'POST') {\n        $post = array_merge_recursive(\n            $request->getParsedBody(),\n            $request->getUploadedFiles()\n        );\n\n        $form->setData($post);\n\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n\n            return new RedirectResponse('upload-form/success');\n        }\n    }\n\n    return new HtmlResponse(\n        $this->template->render('app::page-template', [\n            'form' => $form,\n        ]);    \n    );\n}\n\n\n\nUpon a successful file upload, \n$form->getData()\n would return array including\nthe file field name as a key, and a new instance of \nUploadedFileInterface\n as\nits value.\n\n\n\n\nFurther operations on the uploaded file\n\n\nAfter running \nisValid()\n on the form instance, you should no longer trust the\n\nUploadedFileInterface\n instance stored in the PSR-7 \n$request\n to perform further\noperations on the uploaded file. The file may be moved by one of the filters\nattached to form input, but since the request is immutable, the change will not\nbe reflected in it. Therefore, after validation, always use the file\ninformation retrieved from \n$form->getData()\n, \nnot\n from\n\n$request->getUploadedFiles()\n.\n\n\n\n\nFile Post-Redirect-Get Plugin\n\n\nWhen using other standard form inputs (i.e. \ntext\n, \ncheckbox\n, \nselect\n, etc.)\nalong with file inputs in a form, you can encounter a situation where some\ninputs may become invalid and the user must re-select the file and re-upload.\nPHP will delete uploaded files from the temporary directory at the end of the\nrequest if it has not been moved away or renamed. Re-uploading a valid file each\ntime another form input is invalid is inefficient and annoying to users.\n\n\nOne strategy to get around this is to split the form into multiple forms. One\nform for the file upload inputs and another for the other standard inputs.\n\n\nWhen you cannot separate the forms, the \nFile Post-Redirect-Get\nPlugin\n can be used to\nmanage the file inputs and save off valid uploads until the entire form is\nvalid.\n\n\nChanging our earlier example to use the \nfileprg()\n plugin will require two\nchanges.\n\n\nRenameUpload filter\n\n\nFirst, we need to add a \nRenameUpload\n filter to our form's file input, with\ndetails on where the valid files should be stored:\n\n\nuse Zend\\InputFilter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n        $this->addInputFilter();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload')\n        $file->setAttribute('id', 'image-file');\n\n        $this->add($file);\n    }\n\n    public function addInputFilter()\n    {\n        $inputFilter = new InputFilter\\InputFilter();\n\n        // File Input\n        $fileInput = new InputFilter\\FileInput('image-file');\n        $fileInput->setRequired(true);\n        $fileInput->getFilterChain()->attachByName(\n            'filerenameupload',\n            [\n                'target'    => './data/tmpuploads/avatar.png',\n                'randomize' => true,\n            ]\n        );\n        $inputFilter->add($fileInput);\n\n        $this->setInputFilter($inputFilter);\n    }\n}\n\n\n\nThe \nfilerenameupload\n options above would cause an uploaded file to be\nrenamed and moved to: \n./data/tmpuploads/avatar_4b3403665fea6.png\n.\n\n\nSee the \nRenameUpload filter\n\ndocumentation for more information on its supported options.\n\n\n\n\nFurther operations on the uploaded file\n\n\nIf the file is coming in as a PSR-7 payload, the move operation will be\nperformed on the passed \nUploadedFileInterface\n instance. Therefore, it will\ncontain an expired stream and outdated target file name. After running this filter,\n\ndo not use\n the request object to get further details about the uploaded file;\nuse the new instance of \nUploadedFileInterface\n returned from the filter\ninvocation. \n\n\n\n\nCall the fileprg plugin\n\n\nNext, we need to update our controller action to use the \nfileprg\n plugin:\n\n\npublic function uploadFormAction()\n{\n    $form     = new UploadForm('upload-form');\n    $tempFile = null;\n\n    $prg = $this->fileprg($form);\n\n    if ($prg instanceof \\Zend\\Http\\PhpEnvironment\\Response) {\n        return $prg; // Return PRG redirect response\n    }\n\n    if (is_array($prg)) {\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n            return $this->redirect()->toRoute('upload-form/success');\n        }\n\n        // Form not valid, but file uploads might be valid...\n        // Get the temporary file information to show the user in the view\n        $fileErrors = $form->get('image-file')->getMessages();\n\n        if (empty($fileErrors)) {\n            $tempFile = $form->get('image-file')->getValue();\n        }\n    }\n\n    return [\n        'form'     => $form,\n        'tempFile' => $tempFile,\n    ];\n}\n\n\n\nBehind the scenes, the \nFilePRG\n plugin will:\n\n\n\n\nRun the Form's filters, namely the \nRenameUpload\n filter, to move the files\n  out of temporary storage.\n\n\nStore the valid POST data in the session across requests.\n\n\nChange the \nrequired\n flag of any file inputs that had valid uploads to\n  \nfalse\n. This is so that form re-submissions without uploads will not cause\n  validation errors.\n\n\n\n\n\n\nUser notifications\n\n\nIn the case of a partially valid form, it is up to the developer whether to\nnotify the user that files have been uploaded or not. For example, you may\nwish to hide the form input and/or display the file information. These things\nwould be implementation details in the view or in a custom view helper. Just\nnote that neither the \nFilePRG\n plugin nor the \nformFile\n view helper will do\nany automatic notifications or view changes when files have been successfully\nuploaded.\n\n\n\n\nHTML5 Multi-File Uploads\n\n\nWith HTML5, we are able to select multiple files from a single file input using\nthe \nmultiple\n attribute. Not all \nbrowsers support multiple file\nuploads\n, but the file input will safely remain\na single file upload for those browsers that do not support the feature.\n\n\nTo enable multiple file uploads in zend-form, set the file element's\n\nmultiple\n attribute to true:\n\n\nuse Zend\\InputFilter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n        $this->addInputFilter();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload');\n        $file->setAttribute('id', 'image-file');\n        $file->setAttribute('multiple', true);  // Marking as multiple\n\n        $this->add($file);\n    }\n\n    public function addInputFilter()\n    {\n        $inputFilter = new InputFilter\\InputFilter();\n\n        // File Input\n        $fileInput = new InputFilter\\FileInput('image-file');\n        $fileInput->setRequired(true);\n\n        // Define validators and filters as if only one file was being uploaded.\n        // All files will be run through the same validators and filters\n        // automatically.\n        $fileInput->getValidatorChain()\n            ->attachByName('filesize',      ['max' => 204800])\n            ->attachByName('filemimetype',  ['mimeType' => 'image/png,image/x-png'])\n            ->attachByName('fileimagesize', ['maxWidth' => 100, 'maxHeight' => 100]);\n\n        // All files will be renamed, e.g.:\n        //   ./data/tmpuploads/avatar_4b3403665fea6.png,\n        //   ./data/tmpuploads/avatar_5c45147660fb7.png\n        $fileInput->getFilterChain()->attachByName(\n            'filerenameupload',\n            [\n                'target'    => './data/tmpuploads/avatar.png',\n                'randomize' => true,\n            ]\n        );\n        $inputFilter->add($fileInput);\n\n        $this->setInputFilter($inputFilter);\n    }\n}\n\n\n\nYou do not need to do anything special with the validators and filters to\nsupport multiple file uploads. All of the files that are uploaded will have the\nsame validators and filters run against them automatically (from logic within\n\nFileInput\n). Define them as if a single file was being uploaded.\n\n\nUpload Progress\n\n\nWhile pure client-based upload progress meters are starting to become available\nwith \nHTML5's Progress Events\n, not all\nbrowsers have \nXMLHttpRequest level 2 support\n.\nFor upload progress to work in a greater number of browsers (IE9 and below), you\nmust use a server-side progress solution.\n\n\nZend\\ProgressBar\\Upload\n provides handlers that can give you the actual state\nof a file upload in progress. To use this feature, you need to choose one of the\n\nUpload Progress Handlers\n\n(APC, uploadprogress, or Session) and ensure that your server setup has the\nappropriate extension or feature enabled.\n\n\nVerify your \nphp.ini\n \nsession.upload\n settings before you begin:\n\n\nfile_uploads = On\npost_max_size = 50M\nupload_max_filesize = 50M\nsession.upload_progress.enabled = On\nsession.upload_progress.freq =  \"1%\"\nsession.upload_progress.min_freq = \"1\"\n; Also make certain 'upload_tmp_dir' is writable\n\n\n\nWhen uploading a file with a form POST, you must also include the progress\nidentifier in a hidden input. The \nfile upload progress view helpers\n\nprovides a convenient way to add the hidden input based on your handler type.\n\n\n<!-- File: upload-form.phtml -->\n<?php\n    $fileElement = $form->get('image-file');\n    $form->prepare();\n    echo $this->form()->openTag($form);\n    echo $this->formFileSessionProgress(); // Must come before the file input!\n?>\n\n    <div class=\"form-element\">\n        <?= $this->formLabel($fileElement) ?>\n        <?= $this->formFile($fileElement) ?>\n        <?= $this->formElementErrors($fileElement) ?>\n    </div>\n\n    <button>Submit</button>\n\n<?= $this->form()->closeTag() ?>\n\n\n\nWhen rendered, the HTML should look similar to:\n\n\n<form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\">\n\n    <div class=\"form-element\">\n        <label for=\"image-file\">Avatar Image Upload</label>\n        <input type=\"file\" name=\"image-file\" id=\"image-file\">\n    </div>\n\n    <button>Submit</button>\n</form>\n\n\n\nThere are a few different methods for getting progress information to the\nbrowser (long vs. short polling). Here we will use short polling since it is\nsimpler and less taxing on server resources, though keep in mind it is not as\nresponsive as long polling.\n\n\nWhen our form is submitted via AJAX, the browser will continuously poll the\nserver for upload progress.\n\n\nThe following is an example controller action which provides the progress\ninformation:\n\n\npublic function uploadProgressAction()\n{\n    $id = $this->params()->fromQuery('id', null);\n    $progress = new \\Zend\\ProgressBar\\Upload\\SessionProgress();\n    return new \\Zend\\View\\Model\\JsonModel($progress->getProgress($id));\n}\n\n// Returns JSON\n//{\n//    \"total\"    : 204800,\n//    \"current\"  : 10240,\n//    \"rate\"     : 1024,\n//    \"message\"  : \"10kB / 200kB\",\n//    \"done\"     : false\n//}\n\n\n\n\n\nPerformance overhead\n\n\nThis is \nnot\n the most efficient way of providing upload progress, since each\npolling request must go through the Zend Framework bootstrap process. A better\nexample would be to use a standalone php file in the public folder that\nbypasses the MVC bootstrapping and only uses the essential \nZend\\ProgressBar\n\nadapters.\n\n\n\n\nBack in our view template, we will add Javascript to perform the AJAX POST of\nthe form data, and to start a timeout interval for the progress polling. To keep\nthe example code relatively short, we are using the \njQuery Form plugin\n\nto do the AJAX form POST. If your project uses a different JavaScript framework\n(or none at all), this will hopefully at least illustrate the necessary\nhigh-level logic that would need to be performed.\n\n\n<?php // File: upload-form.phtml\n      // ...after the form...\n?>\n\n<!-- Twitter Bootstrap progress bar styles:\n     http://twitter.github.com/bootstrap/components.html#progress -->\n<div id=\"progress\" class=\"help-block\">\n    <div class=\"progress progress-info progress-striped\">\n        <div class=\"bar\"></div>\n    </div>\n    <p></p>\n</div>\n\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"/js/jquery.form.js\"></script>\n<script>\nvar progressInterval;\n\nfunction getProgress() {\n    // Poll our controller action with the progress id\n    var url = '/upload-form/upload-progress?id=' + $('#progress_key').val();\n    $.getJSON(url, function(data) {\n        if (data.status && !data.status.done) {\n            var value = Math.floor((data.status.current / data.status.total) * 100);\n            showProgress(value, 'Uploading...');\n        } else {\n            showProgress(100, 'Complete!');\n            clearInterval(progressInterval);\n        }\n    });\n}\n\nfunction startProgress() {\n    showProgress(0, 'Starting upload...');\n    progressInterval = setInterval(getProgress, 900);\n}\n\nfunction showProgress(amount, message) {\n    $('#progress').show();\n    $('#progress .bar').width(amount + '%');\n    $('#progress > p').html(message);\n    if (amount < 100) {\n        $('#progress .progress')\n            .addClass('progress-info active')\n            .removeClass('progress-success');\n    } else {\n        $('#progress .progress')\n            .removeClass('progress-info active')\n            .addClass('progress-success');\n    }\n}\n\n$(function() {\n    // Register a 'submit' event listener on the form to perform the AJAX POST\n    $('#upload-form').on('submit', function(e) {\n        e.preventDefault();\n\n        if ($('#image-file').val() == '') {\n            // No files selected, abort\n            return;\n        }\n\n        // Perform the submit\n        //$.fn.ajaxSubmit.debug = true;\n        $(this).ajaxSubmit({\n            beforeSubmit: function(arr, $form, options) {\n                // Notify backend that submit is via ajax\n                arr.push({ name: \"isAjax\", value: \"1\" });\n            },\n            success: function (response, statusText, xhr, $form) {\n                clearInterval(progressInterval);\n                showProgress(100, 'Complete!');\n\n                // TODO: You'll need to do some custom logic here to handle a successful\n                // form post, and when the form is invalid with validation errors.\n                if (response.status) {\n                    // TODO: Do something with a successful form post, like redirect\n                    // window.location.replace(response.redirect);\n                } else {\n                    // Clear the file input, otherwise the same file gets re-uploaded\n                    // http://stackoverflow.com/a/1043969\n                    var fileInput = $('#image-file');\n                    fileInput.replaceWith( fileInput.val('').clone( true ) );\n\n                    // TODO: Do something with these errors\n                    // showErrors(response.formErrors);\n                }\n            },\n            error: function(a, b, c) {\n                // NOTE: This callback is *not* called when the form is invalid.\n                // It is called when the browser is unable to initiate or complete the ajax submit.\n                // You will need to handle validation errors in the 'success' callback.\n                console.log(a, b, c);\n            }\n        });\n        // Start the progress polling\n        startProgress();\n    });\n});\n</script>\n\n\n\nAnd finally, our controller action can be modified to return form status and\nvalidation messages in JSON format if we see the 'isAjax' post parameter (which\nwas set in the JavaScript just before submit):\n\n\npublic function uploadFormAction()\n{\n    $form = new UploadForm('upload-form');\n\n    $request = $this->getRequest();\n\n    if (! $request->isPost()) {\n        return ['form' => $form];\n    }\n\n    // Make certain to merge the files info!\n    $post = array_merge_recursive(\n        $request->getPost()->toArray(),\n        $request->getFiles()->toArray()\n    );\n\n    $form->setData($post);\n    if ($form->isValid()) {\n        $data = $form->getData();\n\n        // Form is valid, save the form!\n        if (! empty($post['isAjax'])) {\n            return new JsonModel(array(\n                'status'   => true,\n                'redirect' => $this->url()->fromRoute('upload-form/success'),\n                'formData' => $data,\n            ));\n        }\n\n        // Fallback for non-JS clients\n        return $this->redirect()->toRoute('upload-form/success');\n    }\n\n    if (! empty($post['isAjax'])) {\n        // Send back failure information via JSON\n        return new JsonModel([\n            'status'     => false,\n            'formErrors' => $form->getMessages(),\n            'formData'   => $form->getData(),\n        ]);\n    }\n\n    return array('form' => $form);\n}\n\n\n\nAdditional Info\n\n\nRelated documentation:\n\n\n\n\nForm File Element\n\n\nForm File View Helper\n\n\nList of File Validators\n\n\nList of File Filters\n\n\nFile Post-Redirect-Get Controller Plugin\n\n\nZend\\InputFilter\\FileInput\n\n\nUpload Progress Handlers\n\n\nUpload Progress View Helpers\n\n\n\n\nExternal resources and blog posts from the community:\n\n\n\n\nZF2FileUploadExamples\n : A\n  ZF2 module with several file upload examples.",
            "title": "File Uploads"
        },
        {
            "location": "/file-upload/#file-uploads",
            "text": "zend-form provides support for file uploading by using features from each of zend-inputfilter , zend-validator , zend-filter , and zend-progressbar . These\nreusable framework components provide a convenient and secure way for handling\nfile uploads in your projects.",
            "title": "File Uploads"
        },
        {
            "location": "/file-upload/#limited-to-post-uploads",
            "text": "The file upload features described here are specifically for forms using the POST  method.  zend-form does not currently provide specific support for\nhandling uploads via the  PUT  method, but it is possible with vanilla PHP.\nSee the  PUT Method Support \nin the PHP documentation for more information.",
            "title": "Limited to POST uploads"
        },
        {
            "location": "/file-upload/#basic-example",
            "text": "Handling file uploads is  essentially  the same as how you would use  Zend\\Form \nfor form processing, but with some slight caveats that will be described below.  In this example we will:   Define a  Form  for backend validation and filtering.  Create a  view template  with a  <form>  containing a file input.  Process the form within a  Controller action  (zend-mvc) or in a  Request Handler  (Expressive).",
            "title": "Basic Example"
        },
        {
            "location": "/file-upload/#the-form-and-inputfilter",
            "text": "Here we define a  Zend\\Form\\Element\\File  input in a  Form  extension named UploadForm .  use Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload');\n        $file->setAttribute('id', 'image-file');\n\n        $this->add($file);\n    }\n}  The  File  element provides several automated features:   The form's  enctype  will automatically be set to  multipart/form-data  when\n  the form's  prepare()  method is called.  The file element's default input specification will create the correct  Input \n  type:  Zend\\InputFilter\\FileInput .  The  FileInput  will automatically prepend an  UploadFile validator \n  to securely validate that the file is actually an uploaded file, and to report\n  any upload errors to the user.",
            "title": "The Form and InputFilter"
        },
        {
            "location": "/file-upload/#the-view-template",
            "text": "In the view template, we render the  <form> , a file input (with label and\nerrors), and a submit button.  <!-- File: upload-form.phtml -->\n<?php\n    $form->prepare(); // The correct enctype is set here\n    $fileElement = $form->get('image-file');\n    echo $this->form()->openTag($form);\n?>\n\n    <div class=\"form-element\">\n        <?= $this->formLabel($fileElement) ?>\n        <?= $this->formFile($fileElement) ?>\n        <?= $this->formElementErrors($fileElement) ?>\n    </div>\n\n    <button>Submit</button>\n\n<?= $this->form()->closeTag() ?>  When rendered, the HTML should look similar to:  <form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\">\n    <div class=\"form-element\">\n        <label for=\"image-file\">Avatar Image Upload</label>\n        <input type=\"file\" name=\"image-file\" id=\"image-file\">\n    </div>\n\n    <button>Submit</button>\n</form>",
            "title": "The View Template"
        },
        {
            "location": "/file-upload/#the-controller-action",
            "text": "When using zend-mvc, the final step will be to instantiate the  UploadForm  and\nprocess any postbacks in a controller action.  The form processing in the controller action will be similar to normal forms, except  that you  must  merge the  $_FILES  information in the request with\nthe other post data.  public function uploadFormAction()\n{\n    $form = new UploadForm('upload-form');\n\n    $request = $this->getRequest();\n    if ($request->isPost()) {\n        // Make certain to merge the $_FILES info!\n        $post = array_merge_recursive(\n            $request->getPost()->toArray(),\n            $request->getFiles()->toArray()\n        );\n\n        $form->setData($post);\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n            return $this->redirect()->toRoute('upload-form/success');\n        }\n    }\n\n    return ['form' => $form];\n}  Upon a successful file upload,  $form->getData()  would return:  array(1) {\n    [\"image-file\"] => array(5) {\n        [\"name\"]     => string(11) \"myimage.png\"\n        [\"type\"]     => string(9)  \"image/png\"\n        [\"tmp_name\"] => string(22) \"/private/tmp/phpgRXd58\"\n        [\"error\"]    => int(0)\n        [\"size\"]     => int(14908679)\n    }\n}",
            "title": "The Controller Action"
        },
        {
            "location": "/file-upload/#using-nested-array-notation-for-uploads",
            "text": "It is suggested that you always use the  Zend\\Http\\PhpEnvironment\\Request \nobject to retrieve and merge the  $_FILES  information with the form, instead\nof using  $_FILES  directly,  due to how the file information is\nmapped in the  $_FILES  array:  // A $_FILES array with single input and multiple files:\narray(1) {\n    [\"image-file\"]=array(2) {\n        [\"name\"]=array(2) {\n            [0]=string(9)\"file0.txt\"\n            [1]=string(9)\"file1.txt\"\n        }\n        [\"type\"]=array(2) {\n            [0]=string(10)\"text/plain\"\n            [1]=string(10)\"text/html\"\n        }\n    }\n}\n\n// How Zend\\Http\\PhpEnvironment\\Request remaps the $_FILES array:\narray(1) {\n    [\"image-file\"]=array(2) {\n        [0]=array(2) {\n            [\"name\"]=string(9)\"file0.txt\"\n            [\"type\"]=string(10)\"text/plain\"\n        },\n        [1]=array(2) {\n            [\"name\"]=string(9)\"file1.txt\"\n            [\"type\"]=string(10)\"text/html\"\n        }\n    }\n}  Zend\\InputFilter\\FileInput  expects the file data be in this\nre-mapped array format.  Note:  PSR-7  also remaps the  $_FILES \narray in this way.",
            "title": "Using nested array notation for uploads"
        },
        {
            "location": "/file-upload/#expressive-request-handler",
            "text": "If you are using a  PSR-15  request handler\nwith  PSR-7  request payload, the final step\ninvolves merging  $request->getParsedBody()  with $request->getUploadedFiles() .  public function handle(ServerRequestInterface $request) : ResponseInterface\n{\n    $form = new UploadForm('upload-form');\n\n    if ($request->getMethod() === 'POST') {\n        $post = array_merge_recursive(\n            $request->getParsedBody(),\n            $request->getUploadedFiles()\n        );\n\n        $form->setData($post);\n\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n\n            return new RedirectResponse('upload-form/success');\n        }\n    }\n\n    return new HtmlResponse(\n        $this->template->render('app::page-template', [\n            'form' => $form,\n        ]);    \n    );\n}  Upon a successful file upload,  $form->getData()  would return array including\nthe file field name as a key, and a new instance of  UploadedFileInterface  as\nits value.",
            "title": "Expressive Request Handler"
        },
        {
            "location": "/file-upload/#further-operations-on-the-uploaded-file",
            "text": "After running  isValid()  on the form instance, you should no longer trust the UploadedFileInterface  instance stored in the PSR-7  $request  to perform further\noperations on the uploaded file. The file may be moved by one of the filters\nattached to form input, but since the request is immutable, the change will not\nbe reflected in it. Therefore, after validation, always use the file\ninformation retrieved from  $form->getData() ,  not  from $request->getUploadedFiles() .",
            "title": "Further operations on the uploaded file"
        },
        {
            "location": "/file-upload/#file-post-redirect-get-plugin",
            "text": "When using other standard form inputs (i.e.  text ,  checkbox ,  select , etc.)\nalong with file inputs in a form, you can encounter a situation where some\ninputs may become invalid and the user must re-select the file and re-upload.\nPHP will delete uploaded files from the temporary directory at the end of the\nrequest if it has not been moved away or renamed. Re-uploading a valid file each\ntime another form input is invalid is inefficient and annoying to users.  One strategy to get around this is to split the form into multiple forms. One\nform for the file upload inputs and another for the other standard inputs.  When you cannot separate the forms, the  File Post-Redirect-Get\nPlugin  can be used to\nmanage the file inputs and save off valid uploads until the entire form is\nvalid.  Changing our earlier example to use the  fileprg()  plugin will require two\nchanges.",
            "title": "File Post-Redirect-Get Plugin"
        },
        {
            "location": "/file-upload/#renameupload-filter",
            "text": "First, we need to add a  RenameUpload  filter to our form's file input, with\ndetails on where the valid files should be stored:  use Zend\\InputFilter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n        $this->addInputFilter();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload')\n        $file->setAttribute('id', 'image-file');\n\n        $this->add($file);\n    }\n\n    public function addInputFilter()\n    {\n        $inputFilter = new InputFilter\\InputFilter();\n\n        // File Input\n        $fileInput = new InputFilter\\FileInput('image-file');\n        $fileInput->setRequired(true);\n        $fileInput->getFilterChain()->attachByName(\n            'filerenameupload',\n            [\n                'target'    => './data/tmpuploads/avatar.png',\n                'randomize' => true,\n            ]\n        );\n        $inputFilter->add($fileInput);\n\n        $this->setInputFilter($inputFilter);\n    }\n}  The  filerenameupload  options above would cause an uploaded file to be\nrenamed and moved to:  ./data/tmpuploads/avatar_4b3403665fea6.png .  See the  RenameUpload filter \ndocumentation for more information on its supported options.",
            "title": "RenameUpload filter"
        },
        {
            "location": "/file-upload/#further-operations-on-the-uploaded-file_1",
            "text": "If the file is coming in as a PSR-7 payload, the move operation will be\nperformed on the passed  UploadedFileInterface  instance. Therefore, it will\ncontain an expired stream and outdated target file name. After running this filter, do not use  the request object to get further details about the uploaded file;\nuse the new instance of  UploadedFileInterface  returned from the filter\ninvocation.",
            "title": "Further operations on the uploaded file"
        },
        {
            "location": "/file-upload/#call-the-fileprg-plugin",
            "text": "Next, we need to update our controller action to use the  fileprg  plugin:  public function uploadFormAction()\n{\n    $form     = new UploadForm('upload-form');\n    $tempFile = null;\n\n    $prg = $this->fileprg($form);\n\n    if ($prg instanceof \\Zend\\Http\\PhpEnvironment\\Response) {\n        return $prg; // Return PRG redirect response\n    }\n\n    if (is_array($prg)) {\n        if ($form->isValid()) {\n            $data = $form->getData();\n\n            // Form is valid, save the form!\n            return $this->redirect()->toRoute('upload-form/success');\n        }\n\n        // Form not valid, but file uploads might be valid...\n        // Get the temporary file information to show the user in the view\n        $fileErrors = $form->get('image-file')->getMessages();\n\n        if (empty($fileErrors)) {\n            $tempFile = $form->get('image-file')->getValue();\n        }\n    }\n\n    return [\n        'form'     => $form,\n        'tempFile' => $tempFile,\n    ];\n}  Behind the scenes, the  FilePRG  plugin will:   Run the Form's filters, namely the  RenameUpload  filter, to move the files\n  out of temporary storage.  Store the valid POST data in the session across requests.  Change the  required  flag of any file inputs that had valid uploads to\n   false . This is so that form re-submissions without uploads will not cause\n  validation errors.",
            "title": "Call the fileprg plugin"
        },
        {
            "location": "/file-upload/#user-notifications",
            "text": "In the case of a partially valid form, it is up to the developer whether to\nnotify the user that files have been uploaded or not. For example, you may\nwish to hide the form input and/or display the file information. These things\nwould be implementation details in the view or in a custom view helper. Just\nnote that neither the  FilePRG  plugin nor the  formFile  view helper will do\nany automatic notifications or view changes when files have been successfully\nuploaded.",
            "title": "User notifications"
        },
        {
            "location": "/file-upload/#html5-multi-file-uploads",
            "text": "With HTML5, we are able to select multiple files from a single file input using\nthe  multiple  attribute. Not all  browsers support multiple file\nuploads , but the file input will safely remain\na single file upload for those browsers that do not support the feature.  To enable multiple file uploads in zend-form, set the file element's multiple  attribute to true:  use Zend\\InputFilter;\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Form;\n\nclass UploadForm extends Form\n{\n    public function __construct($name = null, $options = [])\n    {\n        parent::__construct($name, $options);\n        $this->addElements();\n        $this->addInputFilter();\n    }\n\n    public function addElements()\n    {\n        // File Input\n        $file = new Element\\File('image-file');\n        $file->setLabel('Avatar Image Upload');\n        $file->setAttribute('id', 'image-file');\n        $file->setAttribute('multiple', true);  // Marking as multiple\n\n        $this->add($file);\n    }\n\n    public function addInputFilter()\n    {\n        $inputFilter = new InputFilter\\InputFilter();\n\n        // File Input\n        $fileInput = new InputFilter\\FileInput('image-file');\n        $fileInput->setRequired(true);\n\n        // Define validators and filters as if only one file was being uploaded.\n        // All files will be run through the same validators and filters\n        // automatically.\n        $fileInput->getValidatorChain()\n            ->attachByName('filesize',      ['max' => 204800])\n            ->attachByName('filemimetype',  ['mimeType' => 'image/png,image/x-png'])\n            ->attachByName('fileimagesize', ['maxWidth' => 100, 'maxHeight' => 100]);\n\n        // All files will be renamed, e.g.:\n        //   ./data/tmpuploads/avatar_4b3403665fea6.png,\n        //   ./data/tmpuploads/avatar_5c45147660fb7.png\n        $fileInput->getFilterChain()->attachByName(\n            'filerenameupload',\n            [\n                'target'    => './data/tmpuploads/avatar.png',\n                'randomize' => true,\n            ]\n        );\n        $inputFilter->add($fileInput);\n\n        $this->setInputFilter($inputFilter);\n    }\n}  You do not need to do anything special with the validators and filters to\nsupport multiple file uploads. All of the files that are uploaded will have the\nsame validators and filters run against them automatically (from logic within FileInput ). Define them as if a single file was being uploaded.",
            "title": "HTML5 Multi-File Uploads"
        },
        {
            "location": "/file-upload/#upload-progress",
            "text": "While pure client-based upload progress meters are starting to become available\nwith  HTML5's Progress Events , not all\nbrowsers have  XMLHttpRequest level 2 support .\nFor upload progress to work in a greater number of browsers (IE9 and below), you\nmust use a server-side progress solution.  Zend\\ProgressBar\\Upload  provides handlers that can give you the actual state\nof a file upload in progress. To use this feature, you need to choose one of the Upload Progress Handlers \n(APC, uploadprogress, or Session) and ensure that your server setup has the\nappropriate extension or feature enabled.  Verify your  php.ini   session.upload  settings before you begin:  file_uploads = On\npost_max_size = 50M\nupload_max_filesize = 50M\nsession.upload_progress.enabled = On\nsession.upload_progress.freq =  \"1%\"\nsession.upload_progress.min_freq = \"1\"\n; Also make certain 'upload_tmp_dir' is writable  When uploading a file with a form POST, you must also include the progress\nidentifier in a hidden input. The  file upload progress view helpers \nprovides a convenient way to add the hidden input based on your handler type.  <!-- File: upload-form.phtml -->\n<?php\n    $fileElement = $form->get('image-file');\n    $form->prepare();\n    echo $this->form()->openTag($form);\n    echo $this->formFileSessionProgress(); // Must come before the file input!\n?>\n\n    <div class=\"form-element\">\n        <?= $this->formLabel($fileElement) ?>\n        <?= $this->formFile($fileElement) ?>\n        <?= $this->formElementErrors($fileElement) ?>\n    </div>\n\n    <button>Submit</button>\n\n<?= $this->form()->closeTag() ?>  When rendered, the HTML should look similar to:  <form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\">\n\n    <div class=\"form-element\">\n        <label for=\"image-file\">Avatar Image Upload</label>\n        <input type=\"file\" name=\"image-file\" id=\"image-file\">\n    </div>\n\n    <button>Submit</button>\n</form>  There are a few different methods for getting progress information to the\nbrowser (long vs. short polling). Here we will use short polling since it is\nsimpler and less taxing on server resources, though keep in mind it is not as\nresponsive as long polling.  When our form is submitted via AJAX, the browser will continuously poll the\nserver for upload progress.  The following is an example controller action which provides the progress\ninformation:  public function uploadProgressAction()\n{\n    $id = $this->params()->fromQuery('id', null);\n    $progress = new \\Zend\\ProgressBar\\Upload\\SessionProgress();\n    return new \\Zend\\View\\Model\\JsonModel($progress->getProgress($id));\n}\n\n// Returns JSON\n//{\n//    \"total\"    : 204800,\n//    \"current\"  : 10240,\n//    \"rate\"     : 1024,\n//    \"message\"  : \"10kB / 200kB\",\n//    \"done\"     : false\n//}",
            "title": "Upload Progress"
        },
        {
            "location": "/file-upload/#performance-overhead",
            "text": "This is  not  the most efficient way of providing upload progress, since each\npolling request must go through the Zend Framework bootstrap process. A better\nexample would be to use a standalone php file in the public folder that\nbypasses the MVC bootstrapping and only uses the essential  Zend\\ProgressBar \nadapters.   Back in our view template, we will add Javascript to perform the AJAX POST of\nthe form data, and to start a timeout interval for the progress polling. To keep\nthe example code relatively short, we are using the  jQuery Form plugin \nto do the AJAX form POST. If your project uses a different JavaScript framework\n(or none at all), this will hopefully at least illustrate the necessary\nhigh-level logic that would need to be performed.  <?php // File: upload-form.phtml\n      // ...after the form...\n?>\n\n<!-- Twitter Bootstrap progress bar styles:\n     http://twitter.github.com/bootstrap/components.html#progress -->\n<div id=\"progress\" class=\"help-block\">\n    <div class=\"progress progress-info progress-striped\">\n        <div class=\"bar\"></div>\n    </div>\n    <p></p>\n</div>\n\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"/js/jquery.form.js\"></script>\n<script>\nvar progressInterval;\n\nfunction getProgress() {\n    // Poll our controller action with the progress id\n    var url = '/upload-form/upload-progress?id=' + $('#progress_key').val();\n    $.getJSON(url, function(data) {\n        if (data.status && !data.status.done) {\n            var value = Math.floor((data.status.current / data.status.total) * 100);\n            showProgress(value, 'Uploading...');\n        } else {\n            showProgress(100, 'Complete!');\n            clearInterval(progressInterval);\n        }\n    });\n}\n\nfunction startProgress() {\n    showProgress(0, 'Starting upload...');\n    progressInterval = setInterval(getProgress, 900);\n}\n\nfunction showProgress(amount, message) {\n    $('#progress').show();\n    $('#progress .bar').width(amount + '%');\n    $('#progress > p').html(message);\n    if (amount < 100) {\n        $('#progress .progress')\n            .addClass('progress-info active')\n            .removeClass('progress-success');\n    } else {\n        $('#progress .progress')\n            .removeClass('progress-info active')\n            .addClass('progress-success');\n    }\n}\n\n$(function() {\n    // Register a 'submit' event listener on the form to perform the AJAX POST\n    $('#upload-form').on('submit', function(e) {\n        e.preventDefault();\n\n        if ($('#image-file').val() == '') {\n            // No files selected, abort\n            return;\n        }\n\n        // Perform the submit\n        //$.fn.ajaxSubmit.debug = true;\n        $(this).ajaxSubmit({\n            beforeSubmit: function(arr, $form, options) {\n                // Notify backend that submit is via ajax\n                arr.push({ name: \"isAjax\", value: \"1\" });\n            },\n            success: function (response, statusText, xhr, $form) {\n                clearInterval(progressInterval);\n                showProgress(100, 'Complete!');\n\n                // TODO: You'll need to do some custom logic here to handle a successful\n                // form post, and when the form is invalid with validation errors.\n                if (response.status) {\n                    // TODO: Do something with a successful form post, like redirect\n                    // window.location.replace(response.redirect);\n                } else {\n                    // Clear the file input, otherwise the same file gets re-uploaded\n                    // http://stackoverflow.com/a/1043969\n                    var fileInput = $('#image-file');\n                    fileInput.replaceWith( fileInput.val('').clone( true ) );\n\n                    // TODO: Do something with these errors\n                    // showErrors(response.formErrors);\n                }\n            },\n            error: function(a, b, c) {\n                // NOTE: This callback is *not* called when the form is invalid.\n                // It is called when the browser is unable to initiate or complete the ajax submit.\n                // You will need to handle validation errors in the 'success' callback.\n                console.log(a, b, c);\n            }\n        });\n        // Start the progress polling\n        startProgress();\n    });\n});\n</script>  And finally, our controller action can be modified to return form status and\nvalidation messages in JSON format if we see the 'isAjax' post parameter (which\nwas set in the JavaScript just before submit):  public function uploadFormAction()\n{\n    $form = new UploadForm('upload-form');\n\n    $request = $this->getRequest();\n\n    if (! $request->isPost()) {\n        return ['form' => $form];\n    }\n\n    // Make certain to merge the files info!\n    $post = array_merge_recursive(\n        $request->getPost()->toArray(),\n        $request->getFiles()->toArray()\n    );\n\n    $form->setData($post);\n    if ($form->isValid()) {\n        $data = $form->getData();\n\n        // Form is valid, save the form!\n        if (! empty($post['isAjax'])) {\n            return new JsonModel(array(\n                'status'   => true,\n                'redirect' => $this->url()->fromRoute('upload-form/success'),\n                'formData' => $data,\n            ));\n        }\n\n        // Fallback for non-JS clients\n        return $this->redirect()->toRoute('upload-form/success');\n    }\n\n    if (! empty($post['isAjax'])) {\n        // Send back failure information via JSON\n        return new JsonModel([\n            'status'     => false,\n            'formErrors' => $form->getMessages(),\n            'formData'   => $form->getData(),\n        ]);\n    }\n\n    return array('form' => $form);\n}",
            "title": "Performance overhead"
        },
        {
            "location": "/file-upload/#additional-info",
            "text": "Related documentation:   Form File Element  Form File View Helper  List of File Validators  List of File Filters  File Post-Redirect-Get Controller Plugin  Zend\\InputFilter\\FileInput  Upload Progress Handlers  Upload Progress View Helpers   External resources and blog posts from the community:   ZF2FileUploadExamples  : A\n  ZF2 module with several file upload examples.",
            "title": "Additional Info"
        },
        {
            "location": "/helper/intro/",
            "text": "View Helpers\n\n\nzend-form comes with an initial set of zend-view helper classes for tasks such\nas rendering forms, rendering a text input, rendering a selection box, etc.\n\n\nSee the \nview helpers documentation\n\nfor more information.",
            "title": "Intro"
        },
        {
            "location": "/helper/intro/#view-helpers",
            "text": "zend-form comes with an initial set of zend-view helper classes for tasks such\nas rendering forms, rendering a text input, rendering a selection box, etc.  See the  view helpers documentation \nfor more information.",
            "title": "View Helpers"
        },
        {
            "location": "/helper/abstract-helper/",
            "text": "AbstractHelper\n\n\nThe \nAbstractHelper\n is used as a base abstract class for zend-form view\nhelpers, providing methods for validating form HTML attributes, as well as\ncontrolling the doctype and character encoding. \nAbstractHelper\n also extends\nfrom \nZend\\I18n\\View\\Helper\\AbstractTranslatorHelper\n which provides an\nimplementation for the \nZend\\I18n\\Translator\\TranslatorAwareInterface\n that\nallows setting a translator and text domain.\n\n\nPublic methods\n\n\nThe following public methods are in addition to the inherited methods of\n\nZend\\I18n\\View\\Helper\\AbstractTranslatorHelper\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetDoctype(string $doctype) : void\n\n\nSets a doctype to use in the helper.\n\n\n\n\n\n\ngetDoctype() : string\n\n\nReturns the doctype used in the helper.\n\n\n\n\n\n\nsetEncoding(string $encoding) : void\n\n\nSet the translation text domain to use in helper when translating.\n\n\n\n\n\n\ngetEncoding() : string\n\n\nReturns the character encoding used in the helper.\n\n\n\n\n\n\ngetId() : string or null\n\n\nReturns the element id. If no ID attribute present, attempts to use the name attribute. If name attribute is also not present, returns \nnull\n.\n\n\n\n\n\n\naddTranslatableAttribute(string $attribute) : self\n\n\nMarks the given HTML attribute as translatable.\n\n\n\n\n\n\naddTranslatableAttributePrefix(string $prefix) : self\n\n\nMarks all HTML attributes that start with the given prefix as translatable.\n\n\n\n\n\n\naddTranslatableAttribute(string $attribute) : self\n\n\nMarks the given HTML attribute as translatable.\n\n\n\n\n\n\naddTranslatableAttributePrefix(string $prefix) : self\n\n\nMarks all HTML attributes that start with the given prefix as translatable.\n\n\n\n\n\n\naddDefaultTranslatableAttribute(string $attribute) : void\n\n\nMarks the given HTML attribute as translatable for all view helpers.\n\n\n\n\n\n\naddDefaultTranslatableAttributePrefix(string $prefix) : void\n\n\nMarks all HTML attributes that start with the given prefix as translatable for all view helpers.\n\n\n\n\n\n\naddValidAttribute(string $attribute) : self\n\n\nAdd an HTML attribute to the list of valid attributes for the given element.\n\n\n\n\n\n\naddValidAttributePrefix(string $prefix) : self\n\n\nAdd an HTML attribute prefix to the list of valid attribute prefixes. Any attribute with this preix will be considered valid. By default, the list includes \"data-\", \"aria-\", and \"x-\".\n\n\n\n\n\n\n\n\nTranslation\n\n\nAttaching a translator and setting a text domain (using the formLabel view helper as an example):\n\n\n// Setting a translator\n$this->formLabel()->setTranslator($translator);\n\n// Setting a text domain\n$this->formLabel()->setTranslatorTextDomain('my-text-domain');\n\n// Setting both\n$this->formLabel()->setTranslator($translator, 'my-text-domain');\n\n\n\n\n\nEnabling translation\n\n\nIf you have a translator in your application container under either the key,\n\ntranslator\n or \nMvcTranslator\n, the view helper plugin manager will\nautomatically attach the translator to the view helpers.\n\n\n\n\nWhat will be translated?\n\n\nThe specific view helpers are responsible to determine what exactly should be translated\n(e. g. the Label in the FormLabel view helper or the \"title\" HTML attribute).\n\n\nIf you want to have certain HTML attribute values translated you can mark them as \"translatable\":\n\n// mark one attribute as translatable\n$this->formLabel()->addTranslatableAttribute('data-translate-me');\n\n// mark an prefix as translatable\n$this->formLabel()->addTranslatableAttributePrefix('data-translatable-');\n\n\nOr you can mark them as translatable for all view helpers (e. g. the title attribute):\n\n// mark one attribute as translatable\n\\Zend\\Form\\View\\Helper\\AbstractHelper->addDefaultTranslatableAttribute('title');\n\n// mark an prefix as translatable\n\\Zend\\Form\\View\\Helper\\AbstractHelper->addDefaultTranslatableAttributePrefix('data-translatable-');\n\n\nAllowing framework-specific attributes\n\n\nMany JavaScript frameworks use custom attributes and/or attribute prefixes with\nelements, to facilitate various bindings and event listeners. Examples include\n\nng-\n for \nAngular\n elements, and \nv-\n for\n\nVue\n.\n\n\nzend-form view helpers are strict about what attributes they consider valid. If\nyou wish to allow additional attributes, you will need to notify the helper of\nthem.\n\n\nThe first mechanism is to add a specific attribute:\n\n\n$helper->addValidAttribute('some-attribute');\n\n\n\nIf you wish to allow a set of attributes with a common prefix, use the\nfollowing:\n\n\n$helper->addValidAttributePrefix('ng-');",
            "title": "AbstractHelper"
        },
        {
            "location": "/helper/abstract-helper/#abstracthelper",
            "text": "The  AbstractHelper  is used as a base abstract class for zend-form view\nhelpers, providing methods for validating form HTML attributes, as well as\ncontrolling the doctype and character encoding.  AbstractHelper  also extends\nfrom  Zend\\I18n\\View\\Helper\\AbstractTranslatorHelper  which provides an\nimplementation for the  Zend\\I18n\\Translator\\TranslatorAwareInterface  that\nallows setting a translator and text domain.",
            "title": "AbstractHelper"
        },
        {
            "location": "/helper/abstract-helper/#public-methods",
            "text": "The following public methods are in addition to the inherited methods of Zend\\I18n\\View\\Helper\\AbstractTranslatorHelper .     Method signature  Description      setDoctype(string $doctype) : void  Sets a doctype to use in the helper.    getDoctype() : string  Returns the doctype used in the helper.    setEncoding(string $encoding) : void  Set the translation text domain to use in helper when translating.    getEncoding() : string  Returns the character encoding used in the helper.    getId() : string or null  Returns the element id. If no ID attribute present, attempts to use the name attribute. If name attribute is also not present, returns  null .    addTranslatableAttribute(string $attribute) : self  Marks the given HTML attribute as translatable.    addTranslatableAttributePrefix(string $prefix) : self  Marks all HTML attributes that start with the given prefix as translatable.    addTranslatableAttribute(string $attribute) : self  Marks the given HTML attribute as translatable.    addTranslatableAttributePrefix(string $prefix) : self  Marks all HTML attributes that start with the given prefix as translatable.    addDefaultTranslatableAttribute(string $attribute) : void  Marks the given HTML attribute as translatable for all view helpers.    addDefaultTranslatableAttributePrefix(string $prefix) : void  Marks all HTML attributes that start with the given prefix as translatable for all view helpers.    addValidAttribute(string $attribute) : self  Add an HTML attribute to the list of valid attributes for the given element.    addValidAttributePrefix(string $prefix) : self  Add an HTML attribute prefix to the list of valid attribute prefixes. Any attribute with this preix will be considered valid. By default, the list includes \"data-\", \"aria-\", and \"x-\".",
            "title": "Public methods"
        },
        {
            "location": "/helper/abstract-helper/#translation",
            "text": "Attaching a translator and setting a text domain (using the formLabel view helper as an example):  // Setting a translator\n$this->formLabel()->setTranslator($translator);\n\n// Setting a text domain\n$this->formLabel()->setTranslatorTextDomain('my-text-domain');\n\n// Setting both\n$this->formLabel()->setTranslator($translator, 'my-text-domain');",
            "title": "Translation"
        },
        {
            "location": "/helper/abstract-helper/#enabling-translation",
            "text": "If you have a translator in your application container under either the key, translator  or  MvcTranslator , the view helper plugin manager will\nautomatically attach the translator to the view helpers.",
            "title": "Enabling translation"
        },
        {
            "location": "/helper/abstract-helper/#what-will-be-translated",
            "text": "The specific view helpers are responsible to determine what exactly should be translated\n(e. g. the Label in the FormLabel view helper or the \"title\" HTML attribute).  If you want to have certain HTML attribute values translated you can mark them as \"translatable\": // mark one attribute as translatable\n$this->formLabel()->addTranslatableAttribute('data-translate-me');\n\n// mark an prefix as translatable\n$this->formLabel()->addTranslatableAttributePrefix('data-translatable-');  Or you can mark them as translatable for all view helpers (e. g. the title attribute): // mark one attribute as translatable\n\\Zend\\Form\\View\\Helper\\AbstractHelper->addDefaultTranslatableAttribute('title');\n\n// mark an prefix as translatable\n\\Zend\\Form\\View\\Helper\\AbstractHelper->addDefaultTranslatableAttributePrefix('data-translatable-');",
            "title": "What will be translated?"
        },
        {
            "location": "/helper/abstract-helper/#allowing-framework-specific-attributes",
            "text": "Many JavaScript frameworks use custom attributes and/or attribute prefixes with\nelements, to facilitate various bindings and event listeners. Examples include ng-  for  Angular  elements, and  v-  for Vue .  zend-form view helpers are strict about what attributes they consider valid. If\nyou wish to allow additional attributes, you will need to notify the helper of\nthem.  The first mechanism is to add a specific attribute:  $helper->addValidAttribute('some-attribute');  If you wish to allow a set of attributes with a common prefix, use the\nfollowing:  $helper->addValidAttributePrefix('ng-');",
            "title": "Allowing framework-specific attributes"
        },
        {
            "location": "/helper/form-input/",
            "text": "FormInput\n\n\nThe \nFormInput\n view helper is used to render an \n<input>\n HTML form input tag.\nIt acts as a base class for all of the specifically typed form input helpers\n(\nFormText\n, \nFormCheckbox\n, \nFormSubmit\n, etc.), and is not suggested for\ndirect use.\n\n\nIt contains a general map of valid tag attributes and types for attribute\nfiltering. Each subclass of \nFormInput\n implements its own specific map of valid\ntag attributes.\n\n\nPublic methods\n\n\nThe following public methods are in addition to those inherited from the\n\nAbstractHelper\n:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrender(ElementInterface $element) : string\n\n\nRenders the \n<input>\n tag for the \n$element\n.",
            "title": "formInput"
        },
        {
            "location": "/helper/form-input/#forminput",
            "text": "The  FormInput  view helper is used to render an  <input>  HTML form input tag.\nIt acts as a base class for all of the specifically typed form input helpers\n( FormText ,  FormCheckbox ,  FormSubmit , etc.), and is not suggested for\ndirect use.  It contains a general map of valid tag attributes and types for attribute\nfiltering. Each subclass of  FormInput  implements its own specific map of valid\ntag attributes.",
            "title": "FormInput"
        },
        {
            "location": "/helper/form-input/#public-methods",
            "text": "The following public methods are in addition to those inherited from the AbstractHelper :     Method signature  Description      render(ElementInterface $element) : string  Renders the  <input>  tag for the  $element .",
            "title": "Public methods"
        },
        {
            "location": "/helper/form-element/",
            "text": "FormElement\n\n\nThe \nFormElement\n view helper proxies the rendering to specific form view\nhelpers depending on the type of the \nZend\\Form\\Element\n provided. For instance,\nif the provided element had a type of \"text\", the \nFormElement\n helper will\nretrieve and use the \nFormText\n helper to render the element.\n\n\nBasic usage:\n\n\nuse Zend\\Form\\Form;\nuse Zend\\Form\\Element;\n\n// Within your view...\n\n/**\n * Example #1: Render different types of form elements\n */\n$textElement     = new Element\\Text('my-text');\n$checkboxElement = new Element\\Checkbox('my-checkbox');\n\necho $this->formElement($textElement);\n// Result: <input type=\"text\" name=\"my-text\" value=\"\">\n\necho $this->formElement($checkboxElement);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"0\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #2: Loop through form elements and render them\n */\n$form = new Form();\n// ...add elements and input filter to form...\n$form->prepare();\n\n// Render the opening tag\necho $this->form()->openTag($form);\n\n// ...loop through and render the form elements...\nforeach ($form as $element) {\n    echo $this->formElement($element);\n    echo $this->formElementErrors($element);\n}\n\n// Render the closing tag\necho $this->form()->closeTag();",
            "title": "formElement"
        },
        {
            "location": "/helper/form-element/#formelement",
            "text": "The  FormElement  view helper proxies the rendering to specific form view\nhelpers depending on the type of the  Zend\\Form\\Element  provided. For instance,\nif the provided element had a type of \"text\", the  FormElement  helper will\nretrieve and use the  FormText  helper to render the element.",
            "title": "FormElement"
        },
        {
            "location": "/helper/form-element/#basic-usage",
            "text": "use Zend\\Form\\Form;\nuse Zend\\Form\\Element;\n\n// Within your view...\n\n/**\n * Example #1: Render different types of form elements\n */\n$textElement     = new Element\\Text('my-text');\n$checkboxElement = new Element\\Checkbox('my-checkbox');\n\necho $this->formElement($textElement);\n// Result: <input type=\"text\" name=\"my-text\" value=\"\">\n\necho $this->formElement($checkboxElement);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"0\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #2: Loop through form elements and render them\n */\n$form = new Form();\n// ...add elements and input filter to form...\n$form->prepare();\n\n// Render the opening tag\necho $this->form()->openTag($form);\n\n// ...loop through and render the form elements...\nforeach ($form as $element) {\n    echo $this->formElement($element);\n    echo $this->formElementErrors($element);\n}\n\n// Render the closing tag\necho $this->form()->closeTag();",
            "title": "Basic usage:"
        },
        {
            "location": "/helper/form-element-errors/",
            "text": "FormElementErrors\n\n\nThe \nFormElementErrors\n view helper is used to render the validation error\nmessages of an element.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Form;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\n\n// Create a form\n$form    = new Form();\n$element = new Element\\Text('my-text');\n$form->add($element);\n\n// Create a input\n$input = new Input('my-text');\n$input->setRequired(true);\n\n$inputFilter = new InputFilter();\n$inputFilter->add($input);\n$form->setInputFilter($inputFilter);\n\n// Force a failure\n$form->setData(array()); // Empty data\n$form->isValid();        // Not valid\n\n// Within your view...\n\n/**\n * Example #1: Default options\n */\necho $this->formElementErrors($element);\n// Result: <ul><li>Value is required and can&#039;t be empty</li></ul>\n\n/**\n * Example #2: Add attributes to open format\n */\necho $this->formElementErrors($element, ['class' => 'help-inline']);\n// Result:\n// <ul class=\"help-inline\"><li>Value is required and can&#039;t be empty</li></ul>\n\n/**\n * Example #3: Custom format\n */\n$helper = $this->formElementErrors();\n$helper->setMessageOpenFormat('<div class=\"help-inline\">');\n$helper->setMessageSeparatorString('</div><div class=\"help-inline\">');\n$helper->setMessageCloseString('</div>');\n\necho $helper->render($element);\n// Result: <div class=\"help-inline\">Value is required and can&#039;t be empty</div>\n\n\n\nPublic methods\n\n\nThe following public methods are in addition to those inherited from the\n\nAbstractHelper\n:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetMessageOpenFormat(string $messageOpenFormat) : void\n\n\nSet the (\nprintf\n) formatted string used to open message representation; uses \n<ul%s><li>\n by default; attributes are inserted for the placeholder.\n\n\n\n\n\n\ngetMessageOpenFormat() : string\n\n\nReturns the formatted string used to open message representation.\n\n\n\n\n\n\nsetMessageSeparatorString(string $messageSeparatorString) : string\n\n\nSets the string used to separate messages; defaults to \n</li><li>\n.\n\n\n\n\n\n\ngetMessageSeparatorString() : string\n\n\nReturns the string used to separate messages.\n\n\n\n\n\n\nsetMessageCloseString(string $messageCloseString) : void\n\n\nSets the string used to close message representation; defaults to \n</li></ul>\n.\n\n\n\n\n\n\ngetMessageCloseString() : string\n\n\nReturns the string used to close message representation.\n\n\n\n\n\n\nsetAttributes(array $attributes) : void\n\n\nSet the attributes that will go on the message open format as key/value pairs.\n\n\n\n\n\n\ngetAttributes() : array\n\n\nReturns the attributes that will go on the message open format.\n\n\n\n\n\n\nsetTranslateMessages(bool $flag) : self\n\n\nIndicate whether or not element validation error messages should be translated during \nrender()\n. Default is to translate them.\n\n\n\n\n\n\nrender(ElementInterface $element [, array $attributes = array()]) : string\n\n\nRenders validation errors for the provided \n$element\n. Attributes provided will be used in the \nmessageOpenFormat\n, and merged with any provided previously via \nsetAttributes()\n.",
            "title": "formElementErrors"
        },
        {
            "location": "/helper/form-element-errors/#formelementerrors",
            "text": "The  FormElementErrors  view helper is used to render the validation error\nmessages of an element.",
            "title": "FormElementErrors"
        },
        {
            "location": "/helper/form-element-errors/#basic-usage",
            "text": "use Zend\\Form\\Form;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\Input;\n\n// Create a form\n$form    = new Form();\n$element = new Element\\Text('my-text');\n$form->add($element);\n\n// Create a input\n$input = new Input('my-text');\n$input->setRequired(true);\n\n$inputFilter = new InputFilter();\n$inputFilter->add($input);\n$form->setInputFilter($inputFilter);\n\n// Force a failure\n$form->setData(array()); // Empty data\n$form->isValid();        // Not valid\n\n// Within your view...\n\n/**\n * Example #1: Default options\n */\necho $this->formElementErrors($element);\n// Result: <ul><li>Value is required and can&#039;t be empty</li></ul>\n\n/**\n * Example #2: Add attributes to open format\n */\necho $this->formElementErrors($element, ['class' => 'help-inline']);\n// Result:\n// <ul class=\"help-inline\"><li>Value is required and can&#039;t be empty</li></ul>\n\n/**\n * Example #3: Custom format\n */\n$helper = $this->formElementErrors();\n$helper->setMessageOpenFormat('<div class=\"help-inline\">');\n$helper->setMessageSeparatorString('</div><div class=\"help-inline\">');\n$helper->setMessageCloseString('</div>');\n\necho $helper->render($element);\n// Result: <div class=\"help-inline\">Value is required and can&#039;t be empty</div>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-element-errors/#public-methods",
            "text": "The following public methods are in addition to those inherited from the AbstractHelper :     Method signature  Description      setMessageOpenFormat(string $messageOpenFormat) : void  Set the ( printf ) formatted string used to open message representation; uses  <ul%s><li>  by default; attributes are inserted for the placeholder.    getMessageOpenFormat() : string  Returns the formatted string used to open message representation.    setMessageSeparatorString(string $messageSeparatorString) : string  Sets the string used to separate messages; defaults to  </li><li> .    getMessageSeparatorString() : string  Returns the string used to separate messages.    setMessageCloseString(string $messageCloseString) : void  Sets the string used to close message representation; defaults to  </li></ul> .    getMessageCloseString() : string  Returns the string used to close message representation.    setAttributes(array $attributes) : void  Set the attributes that will go on the message open format as key/value pairs.    getAttributes() : array  Returns the attributes that will go on the message open format.    setTranslateMessages(bool $flag) : self  Indicate whether or not element validation error messages should be translated during  render() . Default is to translate them.    render(ElementInterface $element [, array $attributes = array()]) : string  Renders validation errors for the provided  $element . Attributes provided will be used in the  messageOpenFormat , and merged with any provided previously via  setAttributes() .",
            "title": "Public methods"
        },
        {
            "location": "/helper/form-label/",
            "text": "FormLabel\n\n\nThe \nFormLabel\n view helper is used to render a \n<label>\n HTML element and its\nattributes. If you have a \nZend\\I18n\\Translator\\Translator\n attached,\n\nFormLabel\n will translate the label contents when rendering.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Text('my-text');\n$element->setLabel('Label');\n$element->setAttribute('id', 'text-id');\n$element->setLabelAttributes(['class' => 'control-label']);\n\n// Within your view...\n\n/**\n * Example #1: Render label in one shot\n */\necho $this->formLabel($element);\n// Result: <label class=\"control-label\" for=\"text-id\">Label</label>\n\necho $this->formLabel($element, $this->formText($element));\n// Result: <label class=\"control-label\" for=\"text-id\">Label<input type=\"text\" name=\"my-text\"></label>\n\necho $this->formLabel($element, $this->formText($element), 'append');\n// Result: <label class=\"control-label\" for=\"text-id\"><input type=\"text\" name=\"my-text\">Label</label>\n\n/**\n * Example #2: Render label in separate steps\n */\n// Render the opening tag\necho $this->formLabel()->openTag($element);\n// Result: <label class=\"control-label\" for=\"text-id\">\n\n// Render the closing tag\necho $this->formLabel()->closeTag();\n// Result: </label>\n\n/**\n * Example #3: Render html label after toggling off escape\n */\n$element->setLabel('<abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>');\n$element->setLabelOptions(['disable_html_escape' => true]);\necho $this->formLabel($element);\n// Result:\n// <label class=\"control-label\" for=\"text-id\">\n//     <abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>\n// </label>\n\n\n\n\n\nEscaping\n\n\nHTML escaping only applies to the \nElement::$label\n property, not to the\nhelper \n$labelContent\n parameter.\n\n\n\n\nLabel translation\n\n\nSee \nAbstractHelper Translation\n.\n\n\nPublic methods\n\n\nThe following public methods are in addition to those inherited from the\n\nAbstractHelper\n:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__invoke(ElementInterface $element = null, string $labelContent = null, string $position = null) : string\n\n\nRender a form label, optionally with content.  Always generates a \nfor\n attribute, as we cannot assume the form input will be provided in the \n$labelContent\n. If the \n$labelContent\n is \nnull\n, the helper uses the element's label value. \n$position\n is used to indicate where the label element should be rendered, and should be one of \nFormLabel::APPEND\n or \nFormLabel::PREPEND\n (the default).\n\n\n\n\n\n\nopenTag(array|ElementInterface $attributesOrElement = null) : string\n\n\nRenders the \n<label>\n open tag and attributes. \n$attributesOrElement\n should be an array of key/value pairs representing label attributes, or an \nElementInterface\n instance.\n\n\n\n\n\n\ncloseTag() : string\n\n\nRenders a \n</label>\n closing tag.",
            "title": "formLabel"
        },
        {
            "location": "/helper/form-label/#formlabel",
            "text": "The  FormLabel  view helper is used to render a  <label>  HTML element and its\nattributes. If you have a  Zend\\I18n\\Translator\\Translator  attached, FormLabel  will translate the label contents when rendering.",
            "title": "FormLabel"
        },
        {
            "location": "/helper/form-label/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Text('my-text');\n$element->setLabel('Label');\n$element->setAttribute('id', 'text-id');\n$element->setLabelAttributes(['class' => 'control-label']);\n\n// Within your view...\n\n/**\n * Example #1: Render label in one shot\n */\necho $this->formLabel($element);\n// Result: <label class=\"control-label\" for=\"text-id\">Label</label>\n\necho $this->formLabel($element, $this->formText($element));\n// Result: <label class=\"control-label\" for=\"text-id\">Label<input type=\"text\" name=\"my-text\"></label>\n\necho $this->formLabel($element, $this->formText($element), 'append');\n// Result: <label class=\"control-label\" for=\"text-id\"><input type=\"text\" name=\"my-text\">Label</label>\n\n/**\n * Example #2: Render label in separate steps\n */\n// Render the opening tag\necho $this->formLabel()->openTag($element);\n// Result: <label class=\"control-label\" for=\"text-id\">\n\n// Render the closing tag\necho $this->formLabel()->closeTag();\n// Result: </label>\n\n/**\n * Example #3: Render html label after toggling off escape\n */\n$element->setLabel('<abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>');\n$element->setLabelOptions(['disable_html_escape' => true]);\necho $this->formLabel($element);\n// Result:\n// <label class=\"control-label\" for=\"text-id\">\n//     <abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>\n// </label>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-label/#escaping",
            "text": "HTML escaping only applies to the  Element::$label  property, not to the\nhelper  $labelContent  parameter.",
            "title": "Escaping"
        },
        {
            "location": "/helper/form-label/#label-translation",
            "text": "See  AbstractHelper Translation .",
            "title": "Label translation"
        },
        {
            "location": "/helper/form-label/#public-methods",
            "text": "The following public methods are in addition to those inherited from the AbstractHelper :     Method signature  Description      __invoke(ElementInterface $element = null, string $labelContent = null, string $position = null) : string  Render a form label, optionally with content.  Always generates a  for  attribute, as we cannot assume the form input will be provided in the  $labelContent . If the  $labelContent  is  null , the helper uses the element's label value.  $position  is used to indicate where the label element should be rendered, and should be one of  FormLabel::APPEND  or  FormLabel::PREPEND  (the default).    openTag(array|ElementInterface $attributesOrElement = null) : string  Renders the  <label>  open tag and attributes.  $attributesOrElement  should be an array of key/value pairs representing label attributes, or an  ElementInterface  instance.    closeTag() : string  Renders a  </label>  closing tag.",
            "title": "Public methods"
        },
        {
            "location": "/helper/form-row/",
            "text": "FormRow\n\n\nThe \nFormRow\n view helper is used by \nForm\n view helper to render each row of a\nform, but can also be used stand-alone. A form row usually consists of the\noutput produced by the helper specific to an input, plus its label and errors,\nif any.\n\n\nFormRow\n handles different rendering options, having elements wrapped by the\n\n<label\\>\n HTML block by default, but also allowing to render them in separate\nblocks when the element has an \nid\n attribute specified, thus preserving browser\nusability features.\n\n\nOther options involve label positioning, escaping, toggling errors and using\ncustom partial templates.\n\n\nBasic Usage\n\n\n/**\n * inside view template\n *\n * @var \\Zend\\View\\Renderer\\PhpRenderer $this\n * @var \\Zend\\Form\\Form $form\n */\n\n// Prepare the form\n$form->prepare();\n\n// Render the opening tag\necho $this->form()->openTag($form);\n\n$element = $form->get('some_element');\n$element->setLabel('Some Label');\n\n// Render 'some_element' label, input, and errors if any:\necho $this->formRow($element);\n// Result: <label><span>Some Label</span><input type=\"text\" name=\"some_element\" value=\"\"></label>\n\n// Altering label position:\necho $this->formRow($element, 'append');\n// Result: <label><input type=\"text\" name=\"some_element\" value=\"\"><span>Some Label</span></label>\n\n// Setting the 'id' attribute will result in a separated label rather than a\n// wrapping one:\n$element->setAttribute('id', 'element_id');\necho $this->formRow($element);\n// Result: <label for=\"element_id\">Some Label</label><input type=\"text\" name=\"some_element\" id=\"element_id\" value=\"\">\n\n// Turn off escaping for HTML labels:\n$element->setLabel('<abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>');\n$element->setLabelOptions(['disable_html_escape' => true]);\n// Result:\n// <label>\n//   <span>\n//       <abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>\n//   </span>\n//   <input type=\"text\" name=\"some_element\" value=\"\">\n// </label>\n\n// Render the closing tag\necho $this->form()->closeTag();\n\n\n\n\n\nEscaping\n\n\nLabel content is escaped by default.",
            "title": "formRow"
        },
        {
            "location": "/helper/form-row/#formrow",
            "text": "The  FormRow  view helper is used by  Form  view helper to render each row of a\nform, but can also be used stand-alone. A form row usually consists of the\noutput produced by the helper specific to an input, plus its label and errors,\nif any.  FormRow  handles different rendering options, having elements wrapped by the <label\\>  HTML block by default, but also allowing to render them in separate\nblocks when the element has an  id  attribute specified, thus preserving browser\nusability features.  Other options involve label positioning, escaping, toggling errors and using\ncustom partial templates.",
            "title": "FormRow"
        },
        {
            "location": "/helper/form-row/#basic-usage",
            "text": "/**\n * inside view template\n *\n * @var \\Zend\\View\\Renderer\\PhpRenderer $this\n * @var \\Zend\\Form\\Form $form\n */\n\n// Prepare the form\n$form->prepare();\n\n// Render the opening tag\necho $this->form()->openTag($form);\n\n$element = $form->get('some_element');\n$element->setLabel('Some Label');\n\n// Render 'some_element' label, input, and errors if any:\necho $this->formRow($element);\n// Result: <label><span>Some Label</span><input type=\"text\" name=\"some_element\" value=\"\"></label>\n\n// Altering label position:\necho $this->formRow($element, 'append');\n// Result: <label><input type=\"text\" name=\"some_element\" value=\"\"><span>Some Label</span></label>\n\n// Setting the 'id' attribute will result in a separated label rather than a\n// wrapping one:\n$element->setAttribute('id', 'element_id');\necho $this->formRow($element);\n// Result: <label for=\"element_id\">Some Label</label><input type=\"text\" name=\"some_element\" id=\"element_id\" value=\"\">\n\n// Turn off escaping for HTML labels:\n$element->setLabel('<abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>');\n$element->setLabelOptions(['disable_html_escape' => true]);\n// Result:\n// <label>\n//   <span>\n//       <abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\">CAPTCHA</abbr>\n//   </span>\n//   <input type=\"text\" name=\"some_element\" value=\"\">\n// </label>\n\n// Render the closing tag\necho $this->form()->closeTag();",
            "title": "Basic Usage"
        },
        {
            "location": "/helper/form-row/#escaping",
            "text": "Label content is escaped by default.",
            "title": "Escaping"
        },
        {
            "location": "/helper/form-collection/",
            "text": "FormCollection\n\n\nZend\\Form\\View\\Helper\\FormCollection\n was originally developed for rendering\n\nZend\\Form\\Element\\Collection\n instances, but is capable of rendering any\niterable element type, including fieldsets and forms.\n\n\nInternally, it iterates the element provided, and calls one of the following\nview helpers based on the element encountered:\n\n\n\n\nIf a fieldset (or, by extension, collection or form) is encountered, it is\n  passed to itself (in other words, \nFormCollection\n).\n\n\nOtherwise, it is passed to \nFormRow\n.\n\n\n\n\nBasic usage\n\n\nuse My\\ContactFieldset;\nuse Zend\\Form\\Element;\n\n$collection = new Element\\Collection();\n$collection->setName('contacts');\n$collection->setShouldCreateTemplate(true);\n$collection->setAllowAdd(true);\n$collection->setTargetElement([ 'type' => ContactFieldset::class ]);\n\n// In a view script:\necho $this->formCollection($collection);\n\n\n\nThe above, assuming the fieldset is created correctly, will generate one or more\nfieldsets with the name \ncontacts[]\n, each containing the elements defined in\n\nMy\\ContactFieldset\n. The number of fieldsets created will be based on what data\nwas bound to the form.\n\n\nBy default, the collection is wrapped into \n<fieldset>\n tag. You can override\nthis behavior passing \nfalse\n as second parameter of the helper.\n\n\nYou can also prevent fieldset addition using \nsetShouldWrap()\n method.\n\n\n// In a view script\n// Both following lines are equivalent:\necho $this->formCollection($collection, false);\necho $this->formCollection($collection)->setShouldWrap(false);",
            "title": "formCollection"
        },
        {
            "location": "/helper/form-collection/#formcollection",
            "text": "Zend\\Form\\View\\Helper\\FormCollection  was originally developed for rendering Zend\\Form\\Element\\Collection  instances, but is capable of rendering any\niterable element type, including fieldsets and forms.  Internally, it iterates the element provided, and calls one of the following\nview helpers based on the element encountered:   If a fieldset (or, by extension, collection or form) is encountered, it is\n  passed to itself (in other words,  FormCollection ).  Otherwise, it is passed to  FormRow .",
            "title": "FormCollection"
        },
        {
            "location": "/helper/form-collection/#basic-usage",
            "text": "use My\\ContactFieldset;\nuse Zend\\Form\\Element;\n\n$collection = new Element\\Collection();\n$collection->setName('contacts');\n$collection->setShouldCreateTemplate(true);\n$collection->setAllowAdd(true);\n$collection->setTargetElement([ 'type' => ContactFieldset::class ]);\n\n// In a view script:\necho $this->formCollection($collection);  The above, assuming the fieldset is created correctly, will generate one or more\nfieldsets with the name  contacts[] , each containing the elements defined in My\\ContactFieldset . The number of fieldsets created will be based on what data\nwas bound to the form.  By default, the collection is wrapped into  <fieldset>  tag. You can override\nthis behavior passing  false  as second parameter of the helper.  You can also prevent fieldset addition using  setShouldWrap()  method.  // In a view script\n// Both following lines are equivalent:\necho $this->formCollection($collection, false);\necho $this->formCollection($collection)->setShouldWrap(false);",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form/",
            "text": "Form\n\n\nThe \nForm\n view helper is used to render a \n<form>\n HTML element and its\nattributes.\n\n\nIf provided a \nZend\\Form\\Form\n instance, it will:\n\n\n\n\nprepare()\n the instance\n\n\niterate it, and:\n\n\npass non-collection \nZend\\Form\\Element\n instances to the \nFormRow\n helper to\n    render, and\n\n\npass collections and fieldsets to the \nFormCollection\n helper to render.\n\n\n\n\nFor more fine-grained control, us the \nform()\n helper only for emitting the\nopening and closing \n<form>\n tags, and manually use other helpers to render the\nindividual elements and fieldsets.\n\n\nBasic usage\n\n\n/**\n * inside a view template\n *\n * @var \\Zend\\View\\Renderer\\PhpRenderer $this\n * @var \\Zend\\Form\\Form $form\n */\n\necho $this->form($form);\n\n\n\nmight result in markup like the following:\n\n\n<form action=\"\" method=\"POST\">\n   <label>\n      <span>Some Label</span>\n      <input type=\"text\" name=\"some_element\" value=\"\">\n   </label>\n</form>\n\n\n\nPublic methods\n\n\nThe following public methods are in addition to those inherited from the\n\nAbstractHelper\n:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__invoke(FormInterface $form = null) : string\n\n\nPrepares and renders the whole form.\n\n\n\n\n\n\nopenTag(FormInterface $form = null) : string\n\n\nRenders the \n<form>\n open tag for the \n$form\n instance.\n\n\n\n\n\n\ncloseTag() : string\n\n\nRenders a \n</form>\n closing tag.",
            "title": "form"
        },
        {
            "location": "/helper/form/#form",
            "text": "The  Form  view helper is used to render a  <form>  HTML element and its\nattributes.  If provided a  Zend\\Form\\Form  instance, it will:   prepare()  the instance  iterate it, and:  pass non-collection  Zend\\Form\\Element  instances to the  FormRow  helper to\n    render, and  pass collections and fieldsets to the  FormCollection  helper to render.   For more fine-grained control, us the  form()  helper only for emitting the\nopening and closing  <form>  tags, and manually use other helpers to render the\nindividual elements and fieldsets.",
            "title": "Form"
        },
        {
            "location": "/helper/form/#basic-usage",
            "text": "/**\n * inside a view template\n *\n * @var \\Zend\\View\\Renderer\\PhpRenderer $this\n * @var \\Zend\\Form\\Form $form\n */\n\necho $this->form($form);  might result in markup like the following:  <form action=\"\" method=\"POST\">\n   <label>\n      <span>Some Label</span>\n      <input type=\"text\" name=\"some_element\" value=\"\">\n   </label>\n</form>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form/#public-methods",
            "text": "The following public methods are in addition to those inherited from the AbstractHelper :     Method signature  Description      __invoke(FormInterface $form = null) : string  Prepares and renders the whole form.    openTag(FormInterface $form = null) : string  Renders the  <form>  open tag for the  $form  instance.    closeTag() : string  Renders a  </form>  closing tag.",
            "title": "Public methods"
        },
        {
            "location": "/helper/form-button/",
            "text": "FormButton\n\n\nThe \nFormButton\n view helper is used to render a \n<button>\n HTML element and its\nattributes.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Button('my-button');\n$element->setLabel('Reset');\n\n// Within your view...\n\n/**\n * Example #1: Render entire button in one shot...\n */\necho $this->formButton($element);\n// Result: <button name=\"my-button\" type=\"button\">Reset</button>\n\n/**\n * Example #2: Render button in 3 steps\n */\n// Render the opening tag\necho $this->formButton()->openTag($element);\n// Result: <button name=\"my-button\" type=\"button\">\n\necho '<span class=\"inner\">' . $element->getLabel() . '</span>';\n\n// Render the closing tag\necho $this->formButton()->closeTag();\n// Result: </button>\n\n/**\n * Example #3: Override the element label\n */\necho $this->formButton()->render($element, 'My Content');\n// Result: <button name=\"my-button\" type=\"button\">My Content</button>\n\n\n\nPublic methods\n\n\nThe following public methods are in addition to those inherited from the\n\nFormInput\n:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nopenTag($element = null) : string\n\n\nRenders the \n<button>\n open tag for the \n$element\n instance.\n\n\n\n\n\n\ncloseTag() : string\n\n\nRenders a \n</button>\n closing tag.\n\n\n\n\n\n\nrender(ElementInterface $element [, $buttonContent = null]) : string\n\n\nRenders a button's opening tag, inner content, and closing tag. If \n$buttonContent\n is \nnull\n, defaults to \n$element\n's label.",
            "title": "formButton"
        },
        {
            "location": "/helper/form-button/#formbutton",
            "text": "The  FormButton  view helper is used to render a  <button>  HTML element and its\nattributes.",
            "title": "FormButton"
        },
        {
            "location": "/helper/form-button/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Button('my-button');\n$element->setLabel('Reset');\n\n// Within your view...\n\n/**\n * Example #1: Render entire button in one shot...\n */\necho $this->formButton($element);\n// Result: <button name=\"my-button\" type=\"button\">Reset</button>\n\n/**\n * Example #2: Render button in 3 steps\n */\n// Render the opening tag\necho $this->formButton()->openTag($element);\n// Result: <button name=\"my-button\" type=\"button\">\n\necho '<span class=\"inner\">' . $element->getLabel() . '</span>';\n\n// Render the closing tag\necho $this->formButton()->closeTag();\n// Result: </button>\n\n/**\n * Example #3: Override the element label\n */\necho $this->formButton()->render($element, 'My Content');\n// Result: <button name=\"my-button\" type=\"button\">My Content</button>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-button/#public-methods",
            "text": "The following public methods are in addition to those inherited from the FormInput :     Method signature  Description      openTag($element = null) : string  Renders the  <button>  open tag for the  $element  instance.    closeTag() : string  Renders a  </button>  closing tag.    render(ElementInterface $element [, $buttonContent = null]) : string  Renders a button's opening tag, inner content, and closing tag. If  $buttonContent  is  null , defaults to  $element 's label.",
            "title": "Public methods"
        },
        {
            "location": "/helper/form-captcha/",
            "text": "FormCaptcha\n\n\nZend\\Form\\View\\Helper\\FormCaptcha\n will render a CAPTCHA as defined in a\n\nCaptcha\n element.\n\n\nBasic usage\n\n\nuse Zend\\Captcha;\nuse Zend\\Form\\Element;\n\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n// Within your view...\n\necho $this->formCaptcha($captcha);",
            "title": "formCaptcha"
        },
        {
            "location": "/helper/form-captcha/#formcaptcha",
            "text": "Zend\\Form\\View\\Helper\\FormCaptcha  will render a CAPTCHA as defined in a Captcha  element.",
            "title": "FormCaptcha"
        },
        {
            "location": "/helper/form-captcha/#basic-usage",
            "text": "use Zend\\Captcha;\nuse Zend\\Form\\Element;\n\n$captcha = new Element\\Captcha('captcha');\n$captcha->setCaptcha(new Captcha\\Dumb());\n$captcha->setLabel('Please verify you are human');\n\n// Within your view...\n\necho $this->formCaptcha($captcha);",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-checkbox/",
            "text": "FormCheckbox\n\n\nThe \nFormCheckbox\n view helper can be used to render an \n<input\ntype=\"checkbox\">\n HTML form input. It is meant to work with the\n\ncheckbox element\n, which provides a default input\nspecification for validating the checkbox values.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Checkbox('my-checkbox');\n\n// Within your view...\n\n/**\n * Example #1: Default options\n */\necho $this->formCheckbox($element);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"0\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #2: Disable hidden element\n */\n$element->setUseHiddenElement(false);\necho $this->formCheckbox($element);\n// Result: <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #3: Change checked/unchecked values\n */\n$element->setUseHiddenElement(true);\n$element->setUncheckedValue('no');\n$element->setCheckedValue('yes');\necho $this->formCheckbox($element);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"no\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"yes\">",
            "title": "formCheckbox"
        },
        {
            "location": "/helper/form-checkbox/#formcheckbox",
            "text": "The  FormCheckbox  view helper can be used to render an  <input\ntype=\"checkbox\">  HTML form input. It is meant to work with the checkbox element , which provides a default input\nspecification for validating the checkbox values.",
            "title": "FormCheckbox"
        },
        {
            "location": "/helper/form-checkbox/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Checkbox('my-checkbox');\n\n// Within your view...\n\n/**\n * Example #1: Default options\n */\necho $this->formCheckbox($element);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"0\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #2: Disable hidden element\n */\n$element->setUseHiddenElement(false);\necho $this->formCheckbox($element);\n// Result: <input type=\"checkbox\" name=\"my-checkbox\" value=\"1\">\n\n/**\n * Example #3: Change checked/unchecked values\n */\n$element->setUseHiddenElement(true);\n$element->setUncheckedValue('no');\n$element->setCheckedValue('yes');\necho $this->formCheckbox($element);\n// Result:\n// <input type=\"hidden\" name=\"my-checkbox\" value=\"no\">\n// <input type=\"checkbox\" name=\"my-checkbox\" value=\"yes\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-color/",
            "text": "FormColor\n\n\nThe \nFormColor\n view helper can be used to render a \n<input type=\"color\">\n HTML5\nform input. It is meant to work with the \ncolor element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Color('my-color');\n\n// Within your view...\necho $this->formColor($element);\n\n\n\nOutput:\n\n\n<input type=\"color\" name=\"my-color\" value=\"\">",
            "title": "formColor"
        },
        {
            "location": "/helper/form-color/#formcolor",
            "text": "The  FormColor  view helper can be used to render a  <input type=\"color\">  HTML5\nform input. It is meant to work with the  color element .",
            "title": "FormColor"
        },
        {
            "location": "/helper/form-color/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Color('my-color');\n\n// Within your view...\necho $this->formColor($element);  Output:  <input type=\"color\" name=\"my-color\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-date/",
            "text": "FormDate\n\n\nThe \nFormDate\n view helper can be used to render a \n<input type=\"date\">\n HTML5\nform input. It is meant to work with the \ndate element\n,\nwhich provides a default input specification for validating HTML5 date values.\n\n\nFormDate\n extends from the \nFormDateTime helper\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Date('my-date');\n\n// Within your view...\n\necho $this->formDate($element);\n// Result: <input type=\"date\" name=\"my-date\" value=\"\">",
            "title": "formDate"
        },
        {
            "location": "/helper/form-date/#formdate",
            "text": "The  FormDate  view helper can be used to render a  <input type=\"date\">  HTML5\nform input. It is meant to work with the  date element ,\nwhich provides a default input specification for validating HTML5 date values.  FormDate  extends from the  FormDateTime helper .",
            "title": "FormDate"
        },
        {
            "location": "/helper/form-date/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Date('my-date');\n\n// Within your view...\n\necho $this->formDate($element);\n// Result: <input type=\"date\" name=\"my-date\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-date-time/",
            "text": "FormDateTime\n\n\nThe \nFormDateTime\n view helper can be used to render a \n<input type=\"datetime\">\n\nHTML5 form input. It is meant to work with the \nDateTime element\n,\nwhich provides a default input specification for validating HTML5 datetime\nvalues.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\DateTime('my-datetime');\n\n// Within your view...\n\necho $this->formDateTime($element);\n// Result: <input type=\"datetime\" name=\"my-datetime\" value=\"\">",
            "title": "formDateTime"
        },
        {
            "location": "/helper/form-date-time/#formdatetime",
            "text": "The  FormDateTime  view helper can be used to render a  <input type=\"datetime\"> \nHTML5 form input. It is meant to work with the  DateTime element ,\nwhich provides a default input specification for validating HTML5 datetime\nvalues.",
            "title": "FormDateTime"
        },
        {
            "location": "/helper/form-date-time/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\DateTime('my-datetime');\n\n// Within your view...\n\necho $this->formDateTime($element);\n// Result: <input type=\"datetime\" name=\"my-datetime\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-date-time-local/",
            "text": "FormDateTimeLocal\n\n\nThe \nFormDateTimeLocal\n view helper can be used to render a \n<input\ntype=\"datetime-local\">\n HTML5 form input. It is meant to work with the\n\nDateTimeLocal element\n, which provides a default\ninput specification for validating HTML5 datetime values.\n\n\nFormDateTimeLocal\n extends from \nFormDateTime\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\DateTimeLocal('my-datetime');\n\n// Within your view...\n\necho $this->formDateTimeLocal($element);\n// Result: <input type=\"datetime-local\" name=\"my-datetime\" value=\"\">",
            "title": "formDateTimeLocal"
        },
        {
            "location": "/helper/form-date-time-local/#formdatetimelocal",
            "text": "The  FormDateTimeLocal  view helper can be used to render a  <input\ntype=\"datetime-local\">  HTML5 form input. It is meant to work with the DateTimeLocal element , which provides a default\ninput specification for validating HTML5 datetime values.  FormDateTimeLocal  extends from  FormDateTime .",
            "title": "FormDateTimeLocal"
        },
        {
            "location": "/helper/form-date-time-local/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\DateTimeLocal('my-datetime');\n\n// Within your view...\n\necho $this->formDateTimeLocal($element);\n// Result: <input type=\"datetime-local\" name=\"my-datetime\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-email/",
            "text": "FormEmail\n\n\nThe \nFormEmail\n view helper can be used to render a \n<input type=\"email\">\n HTML5\nform input. It is meant to work with the \nEmail element\n,\nwhich provides a default input specification with an email validator.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Email('my-email');\n\n// Within your view...\n\necho $this->formEmail($element);\n// Result: <input type=\"email\" name=\"my-email\" value=\"\">",
            "title": "formEmail"
        },
        {
            "location": "/helper/form-email/#formemail",
            "text": "The  FormEmail  view helper can be used to render a  <input type=\"email\">  HTML5\nform input. It is meant to work with the  Email element ,\nwhich provides a default input specification with an email validator.",
            "title": "FormEmail"
        },
        {
            "location": "/helper/form-email/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Email('my-email');\n\n// Within your view...\n\necho $this->formEmail($element);\n// Result: <input type=\"email\" name=\"my-email\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-file/",
            "text": "FormFile\n\n\nThe \nFormFile\n view helper can be used to render an \n<input type=\"file\">\n form\ninput. It is meant to work with the \nFile element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\File('my-file');\n\n// Within your view...\n\necho $this->formFile($element);\n// Result: <input type=\"file\" name=\"my-file\">\n\n\n\nFor HTML5 multiple file uploads, the \nmultiple\n attribute can be used. Browsers\nthat do not support HTML5 will default to a single upload input.\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\File('my-file');\n$element->setAttribute('multiple', true);\n\n// Within your view...\n\necho $this->formFile($element);\n// Result: <input type=\"file\" name=\"my-file\" multiple=\"multiple\">",
            "title": "formFile"
        },
        {
            "location": "/helper/form-file/#formfile",
            "text": "The  FormFile  view helper can be used to render an  <input type=\"file\">  form\ninput. It is meant to work with the  File element .",
            "title": "FormFile"
        },
        {
            "location": "/helper/form-file/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\File('my-file');\n\n// Within your view...\n\necho $this->formFile($element);\n// Result: <input type=\"file\" name=\"my-file\">  For HTML5 multiple file uploads, the  multiple  attribute can be used. Browsers\nthat do not support HTML5 will default to a single upload input.  use Zend\\Form\\Element;\n\n$element = new Element\\File('my-file');\n$element->setAttribute('multiple', true);\n\n// Within your view...\n\necho $this->formFile($element);\n// Result: <input type=\"file\" name=\"my-file\" multiple=\"multiple\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-hidden/",
            "text": "FormHidden\n\n\nThe \nFormHidden\n view helper can be used to render an \n<input type=\"hidden\">\n\nHTML form input. It is meant to work with the \nHidden element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Hidden('my-hidden');\n$element->setValue('foo');\n\n// Within your view...\n\necho $this->formHidden($element);\n// Result: <input type=\"hidden\" name=\"my-hidden\" value=\"foo\">",
            "title": "formHidden"
        },
        {
            "location": "/helper/form-hidden/#formhidden",
            "text": "The  FormHidden  view helper can be used to render an  <input type=\"hidden\"> \nHTML form input. It is meant to work with the  Hidden element .",
            "title": "FormHidden"
        },
        {
            "location": "/helper/form-hidden/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Hidden('my-hidden');\n$element->setValue('foo');\n\n// Within your view...\n\necho $this->formHidden($element);\n// Result: <input type=\"hidden\" name=\"my-hidden\" value=\"foo\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-image/",
            "text": "FormImage\n\n\nThe \nFormImage\n view helper can be used to render an \n<input type=\"image\">\n HTML form input. It is meant to work with the \nImage element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Image('my-image');\n$element->setAttribute('src', '/img/my-pic.png');\n\n// Within your view...\n\necho $this->formImage($element);\n// Result: <input type=\"image\" name=\"my-image\" src=\"/img/my-pic.png\">",
            "title": "formImage"
        },
        {
            "location": "/helper/form-image/#formimage",
            "text": "The  FormImage  view helper can be used to render an  <input type=\"image\">  HTML form input. It is meant to work with the  Image element .",
            "title": "FormImage"
        },
        {
            "location": "/helper/form-image/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Image('my-image');\n$element->setAttribute('src', '/img/my-pic.png');\n\n// Within your view...\n\necho $this->formImage($element);\n// Result: <input type=\"image\" name=\"my-image\" src=\"/img/my-pic.png\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-month/",
            "text": "FormMonth\n\n\nThe \nFormMonth\n view helper can be used to render an \n<input type=\"month\">\n\nHTML5 form input. It is meant to work with the \nMonth element\n,\nwhich provides a default input specification for validating HTML5 date values.\n\n\nFormMonth\n extends from \nFormDateTime\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Month('my-month');\n\n// Within your view...\n\necho $this->formMonth($element);\n// Result: <input type=\"month\" name=\"my-month\" value=\"\">",
            "title": "formMonth"
        },
        {
            "location": "/helper/form-month/#formmonth",
            "text": "The  FormMonth  view helper can be used to render an  <input type=\"month\"> \nHTML5 form input. It is meant to work with the  Month element ,\nwhich provides a default input specification for validating HTML5 date values.  FormMonth  extends from  FormDateTime .",
            "title": "FormMonth"
        },
        {
            "location": "/helper/form-month/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Month('my-month');\n\n// Within your view...\n\necho $this->formMonth($element);\n// Result: <input type=\"month\" name=\"my-month\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-month-select/",
            "text": "FormMonthSelect\n\n\nThe \nFormMonthSelect\n view helper renders two select elements, one with a list\nof months, another with a list of years. It works in conjection with the\n\nMonthSelect\n element, which provides the data for\nthe selects, as well as validation around input provided by them.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$monthYear = new Element\\MonthSelect('monthyear');\n$monthYear->setLabel('Select a month and a year');\n$monthYear->setMinYear(1986);\n\n// Within your view...\n\necho $this->formMonthSelect($monthYear);\n// Result:\n// <select name=\"monthyear[month]\"> ... </select>\n// <select name=\"monthyear[year]\"> ... </select>",
            "title": "formMonthSelect"
        },
        {
            "location": "/helper/form-month-select/#formmonthselect",
            "text": "The  FormMonthSelect  view helper renders two select elements, one with a list\nof months, another with a list of years. It works in conjection with the MonthSelect  element, which provides the data for\nthe selects, as well as validation around input provided by them.",
            "title": "FormMonthSelect"
        },
        {
            "location": "/helper/form-month-select/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$monthYear = new Element\\MonthSelect('monthyear');\n$monthYear->setLabel('Select a month and a year');\n$monthYear->setMinYear(1986);\n\n// Within your view...\n\necho $this->formMonthSelect($monthYear);\n// Result:\n// <select name=\"monthyear[month]\"> ... </select>\n// <select name=\"monthyear[year]\"> ... </select>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-multicheckbox/",
            "text": "FormMultiCheckbox\n\n\nThe \nFormMultiCheckbox\n view helper can be used to render a group of \n<input\ntype=\"checkbox\">\n HTML form inputs. It is meant to work with the\n\nMultiCheckbox element\n, which provides a default\ninput specification for validating checkbox groups.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\MultiCheckbox('my-multicheckbox');\n$element->setValueOptions([\n   '0' => 'Apple',\n   '1' => 'Orange',\n   '2' => 'Lemon',\n]);\n\n// Within your view...\n\n/**\n * Example #1: using the default label placement\n */\necho $this->formMultiCheckbox($element);\n// Result:\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\">Apple</label>\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\">Orange</label>\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\">Lemon</label>\n\n/**\n * Example #2: using the prepend label placement\n */\necho $this->formMultiCheckbox($element, 'prepend');\n// Result:\n// <label>Apple<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"></label>\n// <label>Orange<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"></label>\n// <label>Lemon<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"></label>",
            "title": "formMultiCheckbox"
        },
        {
            "location": "/helper/form-multicheckbox/#formmulticheckbox",
            "text": "The  FormMultiCheckbox  view helper can be used to render a group of  <input\ntype=\"checkbox\">  HTML form inputs. It is meant to work with the MultiCheckbox element , which provides a default\ninput specification for validating checkbox groups.",
            "title": "FormMultiCheckbox"
        },
        {
            "location": "/helper/form-multicheckbox/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\MultiCheckbox('my-multicheckbox');\n$element->setValueOptions([\n   '0' => 'Apple',\n   '1' => 'Orange',\n   '2' => 'Lemon',\n]);\n\n// Within your view...\n\n/**\n * Example #1: using the default label placement\n */\necho $this->formMultiCheckbox($element);\n// Result:\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\">Apple</label>\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\">Orange</label>\n// <label><input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\">Lemon</label>\n\n/**\n * Example #2: using the prepend label placement\n */\necho $this->formMultiCheckbox($element, 'prepend');\n// Result:\n// <label>Apple<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"></label>\n// <label>Orange<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"></label>\n// <label>Lemon<input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"></label>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-number/",
            "text": "FormNumber\n\n\nThe \nFormNumber\n view helper can be used to render an \n<input type=\"number\">\n\nHTML form input. It is meant to work with the \nNumber element\n,\nwhich provides a default input specification for validating numerical values.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Number('my-number');\n\n// Within your view...\necho $this->formNumber($element);\n\n\n\nOutput:\n\n\n<input type=\"number\" name=\"my-number\" value=\"\">\n\n\n\nUsage of \nmin\n, \nmax\n and \nstep\n attributes:\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Number('my-number');\n$element->setAttributes([\n    'min'  => 5,\n    'max'  => 20,\n    'step' => 0.5,\n]);\n$element->setValue(12);\n\n// Within your view...\necho $this->formNumber($element);\n\n\n\nOutput:\n\n\n<input type=\"number\" name=\"my-number\" min=\"5\" max=\"20\" step=\"0.5\" value=\"12\">",
            "title": "formNumber"
        },
        {
            "location": "/helper/form-number/#formnumber",
            "text": "The  FormNumber  view helper can be used to render an  <input type=\"number\"> \nHTML form input. It is meant to work with the  Number element ,\nwhich provides a default input specification for validating numerical values.",
            "title": "FormNumber"
        },
        {
            "location": "/helper/form-number/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Number('my-number');\n\n// Within your view...\necho $this->formNumber($element);  Output:  <input type=\"number\" name=\"my-number\" value=\"\">  Usage of  min ,  max  and  step  attributes:  use Zend\\Form\\Element;\n\n$element = new Element\\Number('my-number');\n$element->setAttributes([\n    'min'  => 5,\n    'max'  => 20,\n    'step' => 0.5,\n]);\n$element->setValue(12);\n\n// Within your view...\necho $this->formNumber($element);  Output:  <input type=\"number\" name=\"my-number\" min=\"5\" max=\"20\" step=\"0.5\" value=\"12\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-password/",
            "text": "FormPassword\n\n\nThe \nFormPassword\n view helper can be used to render an \n<input\ntype=\"password\">\n HTML form input. It is meant to work with the\n\nPassword element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Password('my-password');\n\n// Within your view...\necho $this->formPassword($element);\n\n\n\nOutput:\n\n\n<input type=\"password\" name=\"my-password\" value=\"\">",
            "title": "formPassword"
        },
        {
            "location": "/helper/form-password/#formpassword",
            "text": "The  FormPassword  view helper can be used to render an  <input\ntype=\"password\">  HTML form input. It is meant to work with the Password element .",
            "title": "FormPassword"
        },
        {
            "location": "/helper/form-password/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Password('my-password');\n\n// Within your view...\necho $this->formPassword($element);  Output:  <input type=\"password\" name=\"my-password\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-radio/",
            "text": "FormRadio\n\n\nThe \nFormRadio\n view helper can be used to render a group of \n<input\ntype=\"radio\">\n HTML form inputs. It is meant to work with the\n\nRadio element\n, which provides a default input\nspecification for validating a radio.\n\n\nFormRadio\n extends from \nFormMultiCheckbox\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Radio('likes_chocolate');\n$element->setValueOptions([\n   '0' => 'No',\n   '1' => 'Yes',\n]);\n\n// Within your view...\n\n/**\n * Example #1: using the default label placement\n */\necho $this->formRadio($element);\n// Result:\n// <label><input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\">No</label>\n// <label><input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\">Yes</label>\n\n/**\n * Example #2: using the prepend label placement\n */\necho $this->formRadio($element, 'prepend');\n// Result:\n// <label>No<input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"></label>\n// <label>Yes<input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"></label>",
            "title": "formRadio"
        },
        {
            "location": "/helper/form-radio/#formradio",
            "text": "The  FormRadio  view helper can be used to render a group of  <input\ntype=\"radio\">  HTML form inputs. It is meant to work with the Radio element , which provides a default input\nspecification for validating a radio.  FormRadio  extends from  FormMultiCheckbox .",
            "title": "FormRadio"
        },
        {
            "location": "/helper/form-radio/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Radio('likes_chocolate');\n$element->setValueOptions([\n   '0' => 'No',\n   '1' => 'Yes',\n]);\n\n// Within your view...\n\n/**\n * Example #1: using the default label placement\n */\necho $this->formRadio($element);\n// Result:\n// <label><input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\">No</label>\n// <label><input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\">Yes</label>\n\n/**\n * Example #2: using the prepend label placement\n */\necho $this->formRadio($element, 'prepend');\n// Result:\n// <label>No<input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"></label>\n// <label>Yes<input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"></label>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-range/",
            "text": "FormRange\n\n\nThe \nFormRange\n view helper can be used to render an \n<input type=\"range\">\n HTML\nform input. It is meant to work with the \nRange element\n,\nwhich provides a default input specification for validating numerical ranges.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Range('my-range');\n\n// Within your view...\necho $this->formRange($element);\n\n\n\nOutput:\n\n\n<input type=\"range\" name=\"my-range\" value=\"\">\n\n\n\nUsage of \nmin\n, \nmax\n and \nstep\n attributes:\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Range('my-range');\n$element->setAttributes([\n    'min'  => 0,\n    'max'  => 100,\n    'step' => 5,\n]);\n$element->setValue(20);\n\n// Within your view...\necho $this->formRange($element);\n\n\n\nOutput:\n\n\n<input type=\"range\" name=\"my-range\" min=\"0\" max=\"100\" step=\"5\" value=\"20\">",
            "title": "formRange"
        },
        {
            "location": "/helper/form-range/#formrange",
            "text": "The  FormRange  view helper can be used to render an  <input type=\"range\">  HTML\nform input. It is meant to work with the  Range element ,\nwhich provides a default input specification for validating numerical ranges.",
            "title": "FormRange"
        },
        {
            "location": "/helper/form-range/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Range('my-range');\n\n// Within your view...\necho $this->formRange($element);  Output:  <input type=\"range\" name=\"my-range\" value=\"\">  Usage of  min ,  max  and  step  attributes:  use Zend\\Form\\Element;\n\n$element = new Element\\Range('my-range');\n$element->setAttributes([\n    'min'  => 0,\n    'max'  => 100,\n    'step' => 5,\n]);\n$element->setValue(20);\n\n// Within your view...\necho $this->formRange($element);  Output:  <input type=\"range\" name=\"my-range\" min=\"0\" max=\"100\" step=\"5\" value=\"20\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-reset/",
            "text": "FormReset\n\n\nThe \nFormReset\n view helper can be used to render an \n<input type=\"reset\">\n HTML\nform input.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element('my-reset');\n$element->setAttribute('value', 'Reset');\n\n// Within your view...\necho $this->formReset($element);\n\n\n\nOutput:\n\n\n<input type=\"reset\" name=\"my-reset\" value=\"Reset\">",
            "title": "formReset"
        },
        {
            "location": "/helper/form-reset/#formreset",
            "text": "The  FormReset  view helper can be used to render an  <input type=\"reset\">  HTML\nform input.",
            "title": "FormReset"
        },
        {
            "location": "/helper/form-reset/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element('my-reset');\n$element->setAttribute('value', 'Reset');\n\n// Within your view...\necho $this->formReset($element);  Output:  <input type=\"reset\" name=\"my-reset\" value=\"Reset\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-search/",
            "text": "FormSearch\n\n\nThe \nFormSearch\n view helper can be used to render an \n<input type=\"search\">\n\nHTML5 form input.\n\n\nFormSearch\n extends from \nFormText\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element('my-search');\n\n// Within your view...\necho $this->formSearch($element);\n\n\n\nOutput:\n\n\n<input type=\"search\" name=\"my-search\" value=\"\">",
            "title": "formSearch"
        },
        {
            "location": "/helper/form-search/#formsearch",
            "text": "The  FormSearch  view helper can be used to render an  <input type=\"search\"> \nHTML5 form input.  FormSearch  extends from  FormText .",
            "title": "FormSearch"
        },
        {
            "location": "/helper/form-search/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element('my-search');\n\n// Within your view...\necho $this->formSearch($element);  Output:  <input type=\"search\" name=\"my-search\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-select/",
            "text": "FormSelect\n\n\nThe \nFormSelect\n view helper can be used to render an \n<input type=\"select\">\n\nHTML form input with its options. It is meant to work with the \nSelect element\n,\nwhich provides a default input specification for validating a select.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Select('language');\n$element->setValueOptions([\n   '0' => 'French',\n   '1' => 'English',\n   '2' => 'Japanese',\n   '3' => 'Chinese'\n]);\n\n// Within your view...\necho $this->formSelect($element);",
            "title": "formSelect"
        },
        {
            "location": "/helper/form-select/#formselect",
            "text": "The  FormSelect  view helper can be used to render an  <input type=\"select\"> \nHTML form input with its options. It is meant to work with the  Select element ,\nwhich provides a default input specification for validating a select.",
            "title": "FormSelect"
        },
        {
            "location": "/helper/form-select/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Select('language');\n$element->setValueOptions([\n   '0' => 'French',\n   '1' => 'English',\n   '2' => 'Japanese',\n   '3' => 'Chinese'\n]);\n\n// Within your view...\necho $this->formSelect($element);",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-submit/",
            "text": "FormSubmit\n\n\nThe \nFormSubmit\n view helper can be used to render an \n<input type=\"submit\">\n\nHTML form input. It is meant to work with the \nSubmit element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Submit('my-submit');\n\n// Within your view...\necho $this->formSubmit($element);\n\n\n\nOutput:\n\n\n<input type=\"submit\" name=\"my-submit\" value=\"\">",
            "title": "formSubmit"
        },
        {
            "location": "/helper/form-submit/#formsubmit",
            "text": "The  FormSubmit  view helper can be used to render an  <input type=\"submit\"> \nHTML form input. It is meant to work with the  Submit element .",
            "title": "FormSubmit"
        },
        {
            "location": "/helper/form-submit/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Submit('my-submit');\n\n// Within your view...\necho $this->formSubmit($element);  Output:  <input type=\"submit\" name=\"my-submit\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-tel/",
            "text": "FormTel\n\n\nThe \nFormTel\n view helper can be used to render an \n<input type=\"tel\">\n HTML5\nform input.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element('my-tel');\n\n// Within your view...\necho $this->formTel($element);\n\n\n\nOutput:\n\n\n<input type=\"tel\" name=\"my-tel\" value=\"\">",
            "title": "formTel"
        },
        {
            "location": "/helper/form-tel/#formtel",
            "text": "The  FormTel  view helper can be used to render an  <input type=\"tel\">  HTML5\nform input.",
            "title": "FormTel"
        },
        {
            "location": "/helper/form-tel/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element('my-tel');\n\n// Within your view...\necho $this->formTel($element);  Output:  <input type=\"tel\" name=\"my-tel\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-text/",
            "text": "FormText\n\n\nThe \nFormText\n view helper can be used to render an \n<input type=\"text\">\n HTML\nform input. It is meant to work with the \nText element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Text('my-text');\n\n// Within your view...\necho $this->formText($element);\n\n\n\nOutput:\n\n\n<input type=\"text\" name=\"my-text\" value=\"\">",
            "title": "formText"
        },
        {
            "location": "/helper/form-text/#formtext",
            "text": "The  FormText  view helper can be used to render an  <input type=\"text\">  HTML\nform input. It is meant to work with the  Text element .",
            "title": "FormText"
        },
        {
            "location": "/helper/form-text/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Text('my-text');\n\n// Within your view...\necho $this->formText($element);  Output:  <input type=\"text\" name=\"my-text\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-textarea/",
            "text": "FormTextarea\n\n\nThe \nFormTextarea\n view helper can be used to render a \n<textarea></textarea>\n\nHTML form input. It is meant to work with the \nTextarea element\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Textarea('my-textarea');\n\n// Within your view...\necho $this->formTextarea($element);\n\n\n\nOutput:\n\n\n<textarea name=\"my-textarea\"></textarea>",
            "title": "formTextarea"
        },
        {
            "location": "/helper/form-textarea/#formtextarea",
            "text": "The  FormTextarea  view helper can be used to render a  <textarea></textarea> \nHTML form input. It is meant to work with the  Textarea element .",
            "title": "FormTextarea"
        },
        {
            "location": "/helper/form-textarea/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Textarea('my-textarea');\n\n// Within your view...\necho $this->formTextarea($element);  Output:  <textarea name=\"my-textarea\"></textarea>",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-time/",
            "text": "FormTime\n\n\nThe \nFormTime\n view helper can be used to render an \n<input type=\"time\">\n HTML5\nform input. It is meant to work with the \nTime element\n,\nwhich provides a default input specification for validating HTML5 time values.\n\n\nFormTime\n extends from \nFormDateTime\n.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Time('my-time');\n\n// Within your view...\necho $this->formTime($element);\n// Result: <input type=\"time\" name=\"my-time\" value=\"\">",
            "title": "formTime"
        },
        {
            "location": "/helper/form-time/#formtime",
            "text": "The  FormTime  view helper can be used to render an  <input type=\"time\">  HTML5\nform input. It is meant to work with the  Time element ,\nwhich provides a default input specification for validating HTML5 time values.  FormTime  extends from  FormDateTime .",
            "title": "FormTime"
        },
        {
            "location": "/helper/form-time/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Time('my-time');\n\n// Within your view...\necho $this->formTime($element);\n// Result: <input type=\"time\" name=\"my-time\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-url/",
            "text": "FormUrl\n\n\nThe \nFormUrl\n view helper can be used to render an \n<input type=\"url\">\n HTML\nform input. It is meant to work with the \nUrl element\n, which\nprovides a default input specification with an URL validator.\n\n\nBasic usage\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Url('my-url');\n\n// Within your view...\necho $this->formUrl($element);\n\n\n\nOutput:\n\n\n<input type=\"url\" name=\"my-url\" value=\"\">\n\n\n\nUsage of custom regular expression pattern:\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Url('my-url');\n$element->setAttribute('pattern', 'https?://.+');\n\n// Within your view...\necho $this->formUrl($element);\n\n\n\nOutput:\n\n\n<input type=\"url\" name=\"my-url\" pattern=\"https?://.+\" value=\"\">",
            "title": "formUrl"
        },
        {
            "location": "/helper/form-url/#formurl",
            "text": "The  FormUrl  view helper can be used to render an  <input type=\"url\">  HTML\nform input. It is meant to work with the  Url element , which\nprovides a default input specification with an URL validator.",
            "title": "FormUrl"
        },
        {
            "location": "/helper/form-url/#basic-usage",
            "text": "use Zend\\Form\\Element;\n\n$element = new Element\\Url('my-url');\n\n// Within your view...\necho $this->formUrl($element);  Output:  <input type=\"url\" name=\"my-url\" value=\"\">  Usage of custom regular expression pattern:  use Zend\\Form\\Element;\n\n$element = new Element\\Url('my-url');\n$element->setAttribute('pattern', 'https?://.+');\n\n// Within your view...\necho $this->formUrl($element);  Output:  <input type=\"url\" name=\"my-url\" pattern=\"https?://.+\" value=\"\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-week/",
            "text": "FormWeek\n\n\nThe \nFormWeek\n view helper can be used to render an \n<input type=\"week\">\n HTML5\nform input. It is meant to work with the \nWeek element\n,\nwhich provides a default input specification for validating HTML5 week values.\n\n\nFormWeek\n extends from \nFormDateTime\n.\n\n\nBasic usage:\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Week('my-week');\n\n// Within your view...\necho $this->formWeek($element);\n\n\n\nOutput:\n\n\n<input type=\"week\" name=\"my-week\" value=\"\">\n\n\n\nUsage of \nmin\n, \nmax\n and \nstep\n attributes:\n\n\nuse Zend\\Form\\Element;\n\n$element = new Element\\Week('my-week');\n$element->setAttributes([\n    'min'  => '2012-W01',\n    'max'  => '2020-W01',\n    'step' => 2, // weeks; default step interval is 1 week\n]);\n$element->setValue('2014-W10');\n\n// Within your view...\necho $this->formWeek($element);\n\n\n\nOutput:\n\n\n<input type=\"week\" name=\"my-week\" min=\"2012-W01\" max=\"2020-W01\" step=\"2\" value=\"2014-W10\">",
            "title": "formWeek"
        },
        {
            "location": "/helper/form-week/#formweek",
            "text": "The  FormWeek  view helper can be used to render an  <input type=\"week\">  HTML5\nform input. It is meant to work with the  Week element ,\nwhich provides a default input specification for validating HTML5 week values.  FormWeek  extends from  FormDateTime .  Basic usage:  use Zend\\Form\\Element;\n\n$element = new Element\\Week('my-week');\n\n// Within your view...\necho $this->formWeek($element);  Output:  <input type=\"week\" name=\"my-week\" value=\"\">  Usage of  min ,  max  and  step  attributes:  use Zend\\Form\\Element;\n\n$element = new Element\\Week('my-week');\n$element->setAttributes([\n    'min'  => '2012-W01',\n    'max'  => '2020-W01',\n    'step' => 2, // weeks; default step interval is 1 week\n]);\n$element->setValue('2014-W10');\n\n// Within your view...\necho $this->formWeek($element);  Output:  <input type=\"week\" name=\"my-week\" min=\"2012-W01\" max=\"2020-W01\" step=\"2\" value=\"2014-W10\">",
            "title": "FormWeek"
        },
        {
            "location": "/helper/upload-progress-helpers/",
            "text": "Upload Progress Helpers\n\n\nzend-form provides several helpers to use in conjunction with\n\nzend-progressbar\n for the\npuproses of rending upload progress information. These include:\n\n\n\n\nFormFileApcProgress\n, which works with the APC\n  extension.\n\n\nFormFileSessionProgress\n, which works with the\n  built-in support via the session extension.\n\n\nFormFileUploadProgress\n, which works with the\n  UploadProgress extension.",
            "title": "Intro"
        },
        {
            "location": "/helper/upload-progress-helpers/#upload-progress-helpers",
            "text": "zend-form provides several helpers to use in conjunction with zend-progressbar  for the\npuproses of rending upload progress information. These include:   FormFileApcProgress , which works with the APC\n  extension.  FormFileSessionProgress , which works with the\n  built-in support via the session extension.  FormFileUploadProgress , which works with the\n  UploadProgress extension.",
            "title": "Upload Progress Helpers"
        },
        {
            "location": "/helper/form-file-apc-progress/",
            "text": "FormFileApcProgress\n\n\nThe \nFormFileApcProgress\n view helper can be used to render a \n<input\ntype=\"hidden\" ...>\n with a progress ID value used by the APC File Upload\nProgress feature. The APC PHP module is required for this view helper to work.\nUnlike other Form view helpers, the \nFormFileSessionProgress\n helper does not\naccept an \nElement\n as a parameter.\n\n\nAn \nid\n attribute with a value of \n\"progress_key\"\n will automatically be added.\n\n\n\n\nRender early\n\n\nThe view helper \nmust\n be rendered \nbefore\n the file input in the form, or\nupload progress will not work correctly.\n\n\n\n\nBest used with the \nZend\\ProgressBar\\Upload\\ApcProgress\n\nhandler.\n\n\nSee the \napc.rfc1867\n ini setting in the \nAPC Configuration\n\ndocumentation for more information.\n\n\nBasic usage\n\n\n// Within your view...\n\necho $this->formFileApcProgress();\n// Result: <input type=\"hidden\" id=\"progress_key\" name=\"APC_UPLOAD_PROGRESS\" value=\"12345abcde\">",
            "title": "formFileApcProgress"
        },
        {
            "location": "/helper/form-file-apc-progress/#formfileapcprogress",
            "text": "The  FormFileApcProgress  view helper can be used to render a  <input\ntype=\"hidden\" ...>  with a progress ID value used by the APC File Upload\nProgress feature. The APC PHP module is required for this view helper to work.\nUnlike other Form view helpers, the  FormFileSessionProgress  helper does not\naccept an  Element  as a parameter.  An  id  attribute with a value of  \"progress_key\"  will automatically be added.",
            "title": "FormFileApcProgress"
        },
        {
            "location": "/helper/form-file-apc-progress/#render-early",
            "text": "The view helper  must  be rendered  before  the file input in the form, or\nupload progress will not work correctly.   Best used with the  Zend\\ProgressBar\\Upload\\ApcProgress \nhandler.  See the  apc.rfc1867  ini setting in the  APC Configuration \ndocumentation for more information.",
            "title": "Render early"
        },
        {
            "location": "/helper/form-file-apc-progress/#basic-usage",
            "text": "// Within your view...\n\necho $this->formFileApcProgress();\n// Result: <input type=\"hidden\" id=\"progress_key\" name=\"APC_UPLOAD_PROGRESS\" value=\"12345abcde\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-file-session-progress/",
            "text": "FormFileSessionProgress\n\n\nThe \nFormFileSessionProgress\n view helper can be used to render a \n<input\ntype=\"hidden\" ...>\n which can be used by the PHP 5.4+ File Upload Session\nProgress feature.Unlike other zend-form view helpers, the\n\nFormFileSessionProgress\n helper does not accept an \nElement\n as a parameter.\n\n\nAn \nid\n attribute with a value of \n\"progress_key\"\n will automatically be added.\n\n\n\n\nRender early\n\n\nThe view helper \nmust\n be rendered \nbefore\n the file input in the form, or\nupload progress will not work correctly.\n\n\n\n\nBest used with the \nZend\\ProgressBar\\Upload\\SessionProgress\n\nhandler.\n\n\nSee the \nSession Upload Progress\n\nchapter in the PHP documentation for more information.\n\n\nBasic usage\n\n\n// Within your view...\n\necho $this->formFileSessionProgress();\n// Result: <input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\">",
            "title": "formFileSessionProgress"
        },
        {
            "location": "/helper/form-file-session-progress/#formfilesessionprogress",
            "text": "The  FormFileSessionProgress  view helper can be used to render a  <input\ntype=\"hidden\" ...>  which can be used by the PHP 5.4+ File Upload Session\nProgress feature.Unlike other zend-form view helpers, the FormFileSessionProgress  helper does not accept an  Element  as a parameter.  An  id  attribute with a value of  \"progress_key\"  will automatically be added.",
            "title": "FormFileSessionProgress"
        },
        {
            "location": "/helper/form-file-session-progress/#render-early",
            "text": "The view helper  must  be rendered  before  the file input in the form, or\nupload progress will not work correctly.   Best used with the  Zend\\ProgressBar\\Upload\\SessionProgress \nhandler.  See the  Session Upload Progress \nchapter in the PHP documentation for more information.",
            "title": "Render early"
        },
        {
            "location": "/helper/form-file-session-progress/#basic-usage",
            "text": "// Within your view...\n\necho $this->formFileSessionProgress();\n// Result: <input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\">",
            "title": "Basic usage"
        },
        {
            "location": "/helper/form-file-upload-progress/",
            "text": "FormFileUploadProgress\n\n\nThe \nFormFileUploadProgress\n view helper can be used to render an \n<input\ntype=\"hidden\" ...>\n containing the upload progress token, and which can be used by\nthe PECL uploadprogress extension. Unlike other zend-form view helpers, the\n\nFormFileUploadProgress\n helper does not accept an \nElement\n as a parameter.\n\n\nAn \nid\n attribute with a value of \nprogress_key\n will automatically be added.\n\n\n\n\nRender early\n\n\nThe view helper \nmust\n be rendered \nbefore\n the file input in the form, or\nupload progress will not work correctly.\n\n\n\n\nThis element should be used with the \nZend\\ProgressBar\\Upload\\UploadProgress\n\nhandler.\n\n\nSee the \nPECL uploadprogress extension\n\nfor more information.\n\n\nBasic usage\n\n\n// Within your view...\n\necho $this->formFileSessionProgress();\n// Result <input type=\"hidden\" id=\"progress_key\" name=\"UPLOAD_IDENTIFIER\" value=\"12345abcde\">",
            "title": "formFileUploadProgress"
        },
        {
            "location": "/helper/form-file-upload-progress/#formfileuploadprogress",
            "text": "The  FormFileUploadProgress  view helper can be used to render an  <input\ntype=\"hidden\" ...>  containing the upload progress token, and which can be used by\nthe PECL uploadprogress extension. Unlike other zend-form view helpers, the FormFileUploadProgress  helper does not accept an  Element  as a parameter.  An  id  attribute with a value of  progress_key  will automatically be added.",
            "title": "FormFileUploadProgress"
        },
        {
            "location": "/helper/form-file-upload-progress/#render-early",
            "text": "The view helper  must  be rendered  before  the file input in the form, or\nupload progress will not work correctly.   This element should be used with the  Zend\\ProgressBar\\Upload\\UploadProgress \nhandler.  See the  PECL uploadprogress extension \nfor more information.",
            "title": "Render early"
        },
        {
            "location": "/helper/form-file-upload-progress/#basic-usage",
            "text": "// Within your view...\n\necho $this->formFileSessionProgress();\n// Result <input type=\"hidden\" id=\"progress_key\" name=\"UPLOAD_IDENTIFIER\" value=\"12345abcde\">",
            "title": "Basic usage"
        },
        {
            "location": "/advanced/",
            "text": "Advanced use cases\n\n\nBeginning with version 2.1, forms elements can be registered using a\ndesignated plugin manager, in the same way that view helpers, controller\nplugins, and filters are registered. This new feature has a number of benefits,\nespecially when you need to handle complex dependencies in forms/fieldsets.\n\n\nShort names\n\n\nThe first advantage of pulling form elements from the service manager is that\nnow you can use short names to create new elements through the factory.\nTherefore, this code:\n\n\n$form->add([\n    'type' => Element\\Email::class,\n    'name' => 'email',\n]);\n\n\n\ncan now be replaced by:\n\n\n$form->add([\n     'type' => 'Email',\n     'name' => 'email'\n]);\n\n\n\nEach element provided out-of-the-box by zend-form supports this natively.\n\n\n\n\nUse the ::class constant\n\n\nWhile using aliases leads to compact code, they're also can more easily result\nin typographic mistakes. We recommend using the \n::class\n constant in most\nsituations, as these can be more easily scanned with static analysis tools for\ncorrectness.\n\n\n\n\nCreating custom elements\n\n\nzend-form also supports custom form elements.\n\n\nTo create a custom form element, make it extend the \nZend\\Form\\Element\n class,\nor, if you have a more specific dependency, extend one of the classes in the\n\nZend\\Form\\Element\n namespace.\n\n\nIn the following, we will demonstrate creating a custom \nPhone\n element for\nentering phone numbers. It will extend \nZend\\Form\\Element\n class and provide\nsome default input rules.\n\n\nOur custom phone element could look something like this:\n\n\nnamespace Application\\Form\\Element;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputProviderInterface;\nuse Zend\\Validator\\Regex as RegexValidator;\n\nclass Phone extends Element implements InputProviderInterface\n{\n    /**\n     * @var ValidatorInterface\n     */\n    protected $validator;\n\n    /**\n    * Get a validator if none has been set.\n    *\n    * @return ValidatorInterface\n    */\n    public function getValidator()\n    {\n        if (null === $this->validator) {\n            $validator = new RegexValidator('/^\\+?\\d{11,12}$/');\n            $validator->setMessage(\n                'Please enter 11 or 12 digits only!',\n                RegexValidator::NOT_MATCH\n            );\n\n            $this->validator = $validator;\n        }\n\n        return $this->validator;\n    }\n\n    /**\n     * Sets the validator to use for this element\n     *\n     * @param  ValidatorInterface $validator\n     * @return self\n     */\n    public function setValidator(ValidatorInterface $validator)\n    {\n        $this->validator = $validator;\n        return $this;\n    }\n\n    /**\n     * Provide default input rules for this element\n     *\n     * Attaches a phone number validator.\n     *\n     * @return array\n     */\n    public function getInputSpecification()\n    {\n        return [\n            'name' => $this->getName(),\n            'required' => true,\n            'filters' => [\n                ['name' => Filter\\StringTrim::class],\n            ],\n            'validators' => [\n                $this->getValidator(),\n            ],\n        ];\n    }\n}\n\n\n\nBy implementing \nZend\\InputFilter\\InputProviderInterface\n interface, we are\nhinting to our form object that this element provides some default input rules\nfor filtering and/or validating values. In this example, the default input\nspecification provides a \nZend\\Filter\\StringTrim\n filter and a\n\nZend\\Validator\\Regex\n validator that validates that the value optionally has a\n\n+\n sign at the beginning, and is followed by 11 or 12 digits.\n\n\nTo use the new element in our forms, we can specify it by its fully qualified\nclass name (FQCN):\n\n\nuse Application\\Form\\Element\\Phone;\nuse Zend\\Form\\Form;\n\n$form = Form();\n$form->add(array(\n    'name' => 'phone',\n    'type' => Phone::class,\n));\n\n\n\nOr, if you are extending \nZend\\Form\\Form\n:\n\n\nnamespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass MyForm extends Form\n{\n    public function __construct($name = null)\n    {\n        parent::__construct($name);\n\n        $this->add([\n            'name' => 'phone',\n            'type' => Element\\Phone::class,\n        ]);\n    }\n}\n\n\n\nIf you don't want to use the custom element's FQCN, but rather a short name,\nadd an entry for it to \nZend\\Form\\FormElementManager\n. You can do this by adding\nan entry under the \nform_elements\n configuration, or within your \nModule\n class\nvia a \ngetFormElementConfig()\n method.\n\n\nConfiguration via a config file (e.g., \nmodule.config.php\n) file looks like the\nfollowing:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'form_elements' => [\n        'aliases' => [\n            'phone' => Application\\Form\\Element\\Phone::class,\n        ],\n        'factories' => [\n            Application\\Form\\Element\\Phone::class => InvokableFactory::class,\n        ],\n    ],\n];\n\n\n\nThe following demonstrates using your \nModule\n class:\n\n\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\FormElementProviderInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass Module implements FormElementProviderInterface\n{\n    public function getFormElementConfig()\n    {\n        return [\n            'aliases' => [\n                'phone' => Form\\Element\\Phone::class,\n            ],\n            'factories' => [\n                Form\\Element\\Phone::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nIf needed, you can define a custom factory for handling dependencies.\n\n\nAnd now comes the first catch.\n\n\nIf you are creating your form class by extending \nZend\\Form\\Form\n, you \nmust\nnot\n add the custom element in the constructor (as we have done in the previous\nexample where we used the custom element's FQCN), but rather in the \ninit()\n\nmethod:\n\n\nnamespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass MyForm extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'phone',\n            'type' => 'phone',\n        ]);\n    }\n}\n\n\n\nThe second catch\n is that you \nmust not\n directly instantiate your form\nclass, but rather get an instance of it through \nZend\\Form\\FormElementManager\n:\n\n\nnamespace Application\\Controller;\n\nuse Application\\Form\\MyForm;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass IndexController extends AbstractActionController\n{\n    private $form;\n\n    public function __construct(MyForm $form)\n    {\n        $this->form = $form;\n    }\n\n    public function indexAction()\n    {\n        return array('form' => $this->form);\n    }\n}\n\n\n\nThis now requires a factory to inject the form instance:\n\n\nnamespace Application\\Controller;\n\nuse Interop\\Container\\ContainerInterface;\nuse Application\\Form\\MyForm;\n\nclass IndexControllerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $formManager = $container->get('FormElementManager');\n        return new IndexController($formManager->get(MyForm::class));\n    }\n}\n\n\n\nWhich in turn requires that you map the controller to the factory:\n\n\n// In module.config.php\nreturn [\n    /* ... */\n    'controllers' => [\n        'factories' => [\n            Application\\Controller\\IndexController::class => Application\\Controller\\IndexControllerFactory::class,\n        ],\n    ],\n];\n\n\n\nThe biggest gain of this is that you can easily override any built-in form\nelements if they do not fit your needs. For instance, if you want to create your\nown \nEmail\n element instead of the standard one, create your custom element, and\nadd it to the form element config with the same key as the element you want to\nreplace:\n\n\nnamespace Application;\n\nuse Zend\\Form\\Element\\Email;\nuse Zend\\ModuleManager\\Feature\\FormElementProviderInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass Module implements FormElementProviderInterface\n{\n    public function getFormElementConfig()\n    {\n        return [\n            'aliases' => [\n                'email' => Form\\Element\\MyEmail::class,\n                'Email' => Form\\Element\\MyEmail::class,\n            ],\n            'factories' => [\n                Form\\Element\\MyEmail::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nNow whenever you create an element with a \ntype\n of 'email',\nit will create the custom element instead of the built-in one.\n\n\n\n\nUse the original?\n\n\nIf you want to be able to use both the built-in one and your own one, you can\nstill provide the FQCN of the element, e.g. \nZend\\Form\\Element\\Email\n.\n\n\n\n\nIn summary, to create your own form elements (or even reusable fieldsets!) and\nbe able to use them in your form, you need to:\n\n\n\n\nCreate your element (like you did before).\n\n\nAdd it to the form element manager either via the \nform_elements\n\n   configuration in your module, or by defining a \ngetFormElementConfig()\n in\n   your \nModule\n class.\n\n\nMake sure the custom form element is not added in the form's constructor,\n   but rather in its \ninit()\n method, or after getting an instance of the form.\n\n\nRetrieve your form through the form element manager instead of directly\n   instantiating it, and inject it in your controller.\n\n\n\n\nHandling dependencies\n\n\nDependency management can be complex. For instance, a very frequent use case is\na form that creates a fieldset, but itself need access to the database to\npopulate a \nSelect\n element. Retrieving forms from the \nFormElementManager\n\nsolves this issue, as factories it invokes have access to the application\nservice container, and can use it to provide dependencies.\n\n\nFor instance, let's say that a form create a fieldset called \nAlbumFieldset\n:\n\n\nnamespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass CreateAlbum extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'album',\n            'type' => AlbumFieldset::class,\n        ]);\n    }\n}\n\n\n\nLet's now create the \nAlbumFieldset\n, and have it depend on an \nAlbumTable\n\nobject that allows us to fetch albums from the database.\n\n\nnamespace Application\\Form;\n\nuse Album\\Model\\AlbumTable;\nuse Zend\\Form\\Fieldset;\n\nclass AlbumFieldset extends Fieldset\n{\n    public function __construct(AlbumTable $albumTable)\n    {\n        // Add any elements that need to fetch data from database\n        // using the album table !\n    }\n}\n\n\n\nTo enable this, we'll create a factory for our \nAlbumFieldset\n as follows:\n\n\nnamespace Application\\Form;\n\nuse Album\\Model\\AlbumTable;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass AlbumFieldsetFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, array $options = null)\n    {\n        return new AlbumFieldset($container->get(AlbumTable::class));\n    }\n\n    public function createService(ServiceLocatorInterface $formManager)\n    {\n        return $this(\n            $formManager->getServiceLocator() ?: $formManager,\n            AlbumFieldset::class\n        );\n    }\n}\n\n\n\n\n\nCompatibility\n\n\nThe above factory was written to work with both the v2 and v3 releases of\nzend-servicemanager. If you know you will only be using v3, you can remove the\n\ncreateService()\n implementation.\n\n\n\n\nYou can now map the fieldset to the factory in your configuration:\n\n\n// In module.config.php:\nreturn [\n    'form_elements' => [\n        'factories' => [\n            Application\\Form\\AlbumFieldset::class => Application\\Form\\AlbumFieldsetFactory::class,\n        ],\n    ],\n];\n\n\n\nInject your form into your controller, per the example in the previous section.\n\n\nAs a reminder, to use your fieldset in a view, you need to use the\n\nformCollection\n helper:\n\n\necho $this->form()->openTag($form);\necho $this->formCollection($form->get('album'));\necho $this->form()->closeTag();\n\n\n\nInitialization\n\n\nAs noted in previous sections, and in the chapter on elements, we recommend\ndefining an \ninit()\n method for initializing your elements, fieldsets, and\nforms. Where does this come from, and when exactly is it invoked in the object\nlifecycle?\n\n\nThe method is defined in \nZend\\Stdlib\\InitializableInterface\n, which\n\nZend\\Form\\Element\n implements. It is \nnot\n, however, automatically invoked on\ninstantiation!\n\n\nWithin zend-form, the \nFormElementManager\n defines an\n\ninitializer\n\nthat is pushed to the bottom of the initializer stack, making it the last\ninitializer invoked. This initializer checks if the instance created implements\n\nInitializableInterface\n, and, if so, calls its \ninit()\n method.\n\n\nThis approach ensures that dependencies are fully injected prior to any methods\nyou call from your \ninit()\n method. As a result, when pulling items from the\n\nFormElementManager\n, you can be assured that all factories are correctly setup\nand populated, and shared across all specifications you provide.",
            "title": "Advanced"
        },
        {
            "location": "/advanced/#advanced-use-cases",
            "text": "Beginning with version 2.1, forms elements can be registered using a\ndesignated plugin manager, in the same way that view helpers, controller\nplugins, and filters are registered. This new feature has a number of benefits,\nespecially when you need to handle complex dependencies in forms/fieldsets.",
            "title": "Advanced use cases"
        },
        {
            "location": "/advanced/#short-names",
            "text": "The first advantage of pulling form elements from the service manager is that\nnow you can use short names to create new elements through the factory.\nTherefore, this code:  $form->add([\n    'type' => Element\\Email::class,\n    'name' => 'email',\n]);  can now be replaced by:  $form->add([\n     'type' => 'Email',\n     'name' => 'email'\n]);  Each element provided out-of-the-box by zend-form supports this natively.",
            "title": "Short names"
        },
        {
            "location": "/advanced/#use-the-class-constant",
            "text": "While using aliases leads to compact code, they're also can more easily result\nin typographic mistakes. We recommend using the  ::class  constant in most\nsituations, as these can be more easily scanned with static analysis tools for\ncorrectness.",
            "title": "Use the ::class constant"
        },
        {
            "location": "/advanced/#creating-custom-elements",
            "text": "zend-form also supports custom form elements.  To create a custom form element, make it extend the  Zend\\Form\\Element  class,\nor, if you have a more specific dependency, extend one of the classes in the Zend\\Form\\Element  namespace.  In the following, we will demonstrate creating a custom  Phone  element for\nentering phone numbers. It will extend  Zend\\Form\\Element  class and provide\nsome default input rules.  Our custom phone element could look something like this:  namespace Application\\Form\\Element;\n\nuse Zend\\Filter;\nuse Zend\\Form\\Element;\nuse Zend\\InputFilter\\InputProviderInterface;\nuse Zend\\Validator\\Regex as RegexValidator;\n\nclass Phone extends Element implements InputProviderInterface\n{\n    /**\n     * @var ValidatorInterface\n     */\n    protected $validator;\n\n    /**\n    * Get a validator if none has been set.\n    *\n    * @return ValidatorInterface\n    */\n    public function getValidator()\n    {\n        if (null === $this->validator) {\n            $validator = new RegexValidator('/^\\+?\\d{11,12}$/');\n            $validator->setMessage(\n                'Please enter 11 or 12 digits only!',\n                RegexValidator::NOT_MATCH\n            );\n\n            $this->validator = $validator;\n        }\n\n        return $this->validator;\n    }\n\n    /**\n     * Sets the validator to use for this element\n     *\n     * @param  ValidatorInterface $validator\n     * @return self\n     */\n    public function setValidator(ValidatorInterface $validator)\n    {\n        $this->validator = $validator;\n        return $this;\n    }\n\n    /**\n     * Provide default input rules for this element\n     *\n     * Attaches a phone number validator.\n     *\n     * @return array\n     */\n    public function getInputSpecification()\n    {\n        return [\n            'name' => $this->getName(),\n            'required' => true,\n            'filters' => [\n                ['name' => Filter\\StringTrim::class],\n            ],\n            'validators' => [\n                $this->getValidator(),\n            ],\n        ];\n    }\n}  By implementing  Zend\\InputFilter\\InputProviderInterface  interface, we are\nhinting to our form object that this element provides some default input rules\nfor filtering and/or validating values. In this example, the default input\nspecification provides a  Zend\\Filter\\StringTrim  filter and a Zend\\Validator\\Regex  validator that validates that the value optionally has a +  sign at the beginning, and is followed by 11 or 12 digits.  To use the new element in our forms, we can specify it by its fully qualified\nclass name (FQCN):  use Application\\Form\\Element\\Phone;\nuse Zend\\Form\\Form;\n\n$form = Form();\n$form->add(array(\n    'name' => 'phone',\n    'type' => Phone::class,\n));  Or, if you are extending  Zend\\Form\\Form :  namespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass MyForm extends Form\n{\n    public function __construct($name = null)\n    {\n        parent::__construct($name);\n\n        $this->add([\n            'name' => 'phone',\n            'type' => Element\\Phone::class,\n        ]);\n    }\n}  If you don't want to use the custom element's FQCN, but rather a short name,\nadd an entry for it to  Zend\\Form\\FormElementManager . You can do this by adding\nan entry under the  form_elements  configuration, or within your  Module  class\nvia a  getFormElementConfig()  method.  Configuration via a config file (e.g.,  module.config.php ) file looks like the\nfollowing:  use Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'form_elements' => [\n        'aliases' => [\n            'phone' => Application\\Form\\Element\\Phone::class,\n        ],\n        'factories' => [\n            Application\\Form\\Element\\Phone::class => InvokableFactory::class,\n        ],\n    ],\n];  The following demonstrates using your  Module  class:  namespace Application;\n\nuse Zend\\ModuleManager\\Feature\\FormElementProviderInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass Module implements FormElementProviderInterface\n{\n    public function getFormElementConfig()\n    {\n        return [\n            'aliases' => [\n                'phone' => Form\\Element\\Phone::class,\n            ],\n            'factories' => [\n                Form\\Element\\Phone::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}  If needed, you can define a custom factory for handling dependencies.  And now comes the first catch.  If you are creating your form class by extending  Zend\\Form\\Form , you  must\nnot  add the custom element in the constructor (as we have done in the previous\nexample where we used the custom element's FQCN), but rather in the  init() \nmethod:  namespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass MyForm extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'phone',\n            'type' => 'phone',\n        ]);\n    }\n}  The second catch  is that you  must not  directly instantiate your form\nclass, but rather get an instance of it through  Zend\\Form\\FormElementManager :  namespace Application\\Controller;\n\nuse Application\\Form\\MyForm;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass IndexController extends AbstractActionController\n{\n    private $form;\n\n    public function __construct(MyForm $form)\n    {\n        $this->form = $form;\n    }\n\n    public function indexAction()\n    {\n        return array('form' => $this->form);\n    }\n}  This now requires a factory to inject the form instance:  namespace Application\\Controller;\n\nuse Interop\\Container\\ContainerInterface;\nuse Application\\Form\\MyForm;\n\nclass IndexControllerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $formManager = $container->get('FormElementManager');\n        return new IndexController($formManager->get(MyForm::class));\n    }\n}  Which in turn requires that you map the controller to the factory:  // In module.config.php\nreturn [\n    /* ... */\n    'controllers' => [\n        'factories' => [\n            Application\\Controller\\IndexController::class => Application\\Controller\\IndexControllerFactory::class,\n        ],\n    ],\n];  The biggest gain of this is that you can easily override any built-in form\nelements if they do not fit your needs. For instance, if you want to create your\nown  Email  element instead of the standard one, create your custom element, and\nadd it to the form element config with the same key as the element you want to\nreplace:  namespace Application;\n\nuse Zend\\Form\\Element\\Email;\nuse Zend\\ModuleManager\\Feature\\FormElementProviderInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass Module implements FormElementProviderInterface\n{\n    public function getFormElementConfig()\n    {\n        return [\n            'aliases' => [\n                'email' => Form\\Element\\MyEmail::class,\n                'Email' => Form\\Element\\MyEmail::class,\n            ],\n            'factories' => [\n                Form\\Element\\MyEmail::class => InvokableFactory::class,\n            ],\n        ];\n    }\n}  Now whenever you create an element with a  type  of 'email',\nit will create the custom element instead of the built-in one.",
            "title": "Creating custom elements"
        },
        {
            "location": "/advanced/#use-the-original",
            "text": "If you want to be able to use both the built-in one and your own one, you can\nstill provide the FQCN of the element, e.g.  Zend\\Form\\Element\\Email .   In summary, to create your own form elements (or even reusable fieldsets!) and\nbe able to use them in your form, you need to:   Create your element (like you did before).  Add it to the form element manager either via the  form_elements \n   configuration in your module, or by defining a  getFormElementConfig()  in\n   your  Module  class.  Make sure the custom form element is not added in the form's constructor,\n   but rather in its  init()  method, or after getting an instance of the form.  Retrieve your form through the form element manager instead of directly\n   instantiating it, and inject it in your controller.",
            "title": "Use the original?"
        },
        {
            "location": "/advanced/#handling-dependencies",
            "text": "Dependency management can be complex. For instance, a very frequent use case is\na form that creates a fieldset, but itself need access to the database to\npopulate a  Select  element. Retrieving forms from the  FormElementManager \nsolves this issue, as factories it invokes have access to the application\nservice container, and can use it to provide dependencies.  For instance, let's say that a form create a fieldset called  AlbumFieldset :  namespace Application\\Form;\n\nuse Zend\\Form\\Form;\n\nclass CreateAlbum extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'album',\n            'type' => AlbumFieldset::class,\n        ]);\n    }\n}  Let's now create the  AlbumFieldset , and have it depend on an  AlbumTable \nobject that allows us to fetch albums from the database.  namespace Application\\Form;\n\nuse Album\\Model\\AlbumTable;\nuse Zend\\Form\\Fieldset;\n\nclass AlbumFieldset extends Fieldset\n{\n    public function __construct(AlbumTable $albumTable)\n    {\n        // Add any elements that need to fetch data from database\n        // using the album table !\n    }\n}  To enable this, we'll create a factory for our  AlbumFieldset  as follows:  namespace Application\\Form;\n\nuse Album\\Model\\AlbumTable;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass AlbumFieldsetFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, array $options = null)\n    {\n        return new AlbumFieldset($container->get(AlbumTable::class));\n    }\n\n    public function createService(ServiceLocatorInterface $formManager)\n    {\n        return $this(\n            $formManager->getServiceLocator() ?: $formManager,\n            AlbumFieldset::class\n        );\n    }\n}",
            "title": "Handling dependencies"
        },
        {
            "location": "/advanced/#compatibility",
            "text": "The above factory was written to work with both the v2 and v3 releases of\nzend-servicemanager. If you know you will only be using v3, you can remove the createService()  implementation.   You can now map the fieldset to the factory in your configuration:  // In module.config.php:\nreturn [\n    'form_elements' => [\n        'factories' => [\n            Application\\Form\\AlbumFieldset::class => Application\\Form\\AlbumFieldsetFactory::class,\n        ],\n    ],\n];  Inject your form into your controller, per the example in the previous section.  As a reminder, to use your fieldset in a view, you need to use the formCollection  helper:  echo $this->form()->openTag($form);\necho $this->formCollection($form->get('album'));\necho $this->form()->closeTag();",
            "title": "Compatibility"
        },
        {
            "location": "/advanced/#initialization",
            "text": "As noted in previous sections, and in the chapter on elements, we recommend\ndefining an  init()  method for initializing your elements, fieldsets, and\nforms. Where does this come from, and when exactly is it invoked in the object\nlifecycle?  The method is defined in  Zend\\Stdlib\\InitializableInterface , which Zend\\Form\\Element  implements. It is  not , however, automatically invoked on\ninstantiation!  Within zend-form, the  FormElementManager  defines an initializer \nthat is pushed to the bottom of the initializer stack, making it the last\ninitializer invoked. This initializer checks if the instance created implements InitializableInterface , and, if so, calls its  init()  method.  This approach ensures that dependencies are fully injected prior to any methods\nyou call from your  init()  method. As a result, when pulling items from the FormElementManager , you can be assured that all factories are correctly setup\nand populated, and shared across all specifications you provide.",
            "title": "Initialization"
        }
    ]
}